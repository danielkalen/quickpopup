(function(f){typeof define==='function'&&define.amd?define(f):f();}((function(){'use strict';function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var REGEX_LEN_VAL = /^\d+(?:[a-z]|\%)+$/i;
var REGEX_DIGITS = /\d+$/;
var REGEX_SPACE = /\s/;
var REGEX_KEBAB = /([A-Z])+/g;
var IMPORTANT = 'important';
var POSSIBLE_PREFIXES = ['webkit', 'moz', 'ms', 'o'];
var REQUIRES_UNIT_VALUE = ['background-position-x', 'background-position-y', 'block-size', 'border-width', 'columnRule-width', 'cx', 'cy', 'font-size', 'grid-column-gap', 'grid-row-gap', 'height', 'inline-size', 'line-height', 'minBlock-size', 'min-height', 'min-inline-size', 'min-width', 'max-height', 'max-width', 'outline-offset', 'outline-width', 'perspective', 'shape-margin', 'stroke-dashoffset', 'stroke-width', 'text-indent', 'width', 'word-spacing', 'top', 'bottom', 'left', 'right', 'x', 'y'];
var QUAD_SHORTHANDS = ['margin', 'padding', 'border', 'border-radius'];
var DIRECTIONS = ['top', 'bottom', 'left', 'right'];
QUAD_SHORTHANDS.forEach(function (property) {
  var direction, i, len;
  REQUIRES_UNIT_VALUE.push(property);

  for (i = 0, len = DIRECTIONS.length; i < len; i++) {
    direction = DIRECTIONS[i];
    REQUIRES_UNIT_VALUE.push(property + '-' + direction);
  }
});
var SAMPLE_STYLE, styleConfig;
SAMPLE_STYLE = document.createElement('div').style;

var includes = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var isIterable = function isIterable(target) {
  return target && _typeof(target) === 'object' && typeof target.length === 'number' && !target.nodeType;
};

var toKebabCase = function toKebabCase(string) {
  return string.replace(REGEX_KEBAB, function (e, letter) {
    return "-".concat(letter.toLowerCase());
  });
};

var isPropSupported = function isPropSupported(property) {
  return typeof SAMPLE_STYLE[property] !== 'undefined';
};

var isValueSupported = function isValueSupported(property, value) {
  if (window.CSS && window.CSS.supports) {
    return window.CSS.supports(property, value);
  } else {
    SAMPLE_STYLE[property] = value;
    return SAMPLE_STYLE[property] === '' + value;
  }
};

var getPrefix = function getPrefix(property, skipInitialCheck) {
  var j, len1, prefix;

  if (skipInitialCheck || !isPropSupported(property)) {
    for (j = 0, len1 = POSSIBLE_PREFIXES.length; j < len1; j++) {
      prefix = POSSIBLE_PREFIXES[j];

      if (isPropSupported("-".concat(prefix, "-").concat(property))) {
        /* istanbul ignore next */
        return "-".concat(prefix, "-");
      }
    }
  }

  return '';
};

var normalizeProperty = function normalizeProperty(property) {
  property = toKebabCase(property);

  if (isPropSupported(property)) {
    return property;
  } else {
    return "".concat(getPrefix(property, true)).concat(property);
  }
};

var normalizeValue = function normalizeValue(property, value) {
  if (includes(REQUIRES_UNIT_VALUE, property) && value !== null) {
    value = '' + value;

    if (REGEX_DIGITS.test(value) && !REGEX_LEN_VAL.test(value) && !REGEX_SPACE.test(value)) {
      value += property === 'line-height' ? 'em' : 'px';
    }
  }

  return value;
};

var sort = function sort(array) {
  var great, i, len, less, pivot;

  if (array.length < 2) {
    return array;
  } else {
    pivot = array[0];
    less = [];
    great = [];
    len = array.length;
    i = 0;

    while (++i !== len) {
      if (array[i] <= pivot) {
        less.push(array[i]);
      } else {
        great.push(array[i]);
      }
    }

    return sort(less).concat(pivot, sort(great));
  }
};

var hash = function hash(string) {
  var hsh, i, length;
  hsh = 5381;
  i = -1;
  length = string.length;

  while (++i !== string.length) {
    hsh = (hsh << 5) - hsh + string.charCodeAt(i);
    hsh |= 0;
  }

  return '_' + (hsh < 0 ? hsh * -2 : hsh);
};

var ruleToString = function ruleToString(rule, important) {
  var j, len1, output, prop, property, props, value;
  output = '';
  props = sort(Object.keys(rule));

  for (j = 0, len1 = props.length; j < len1; j++) {
    prop = props[j];

    if (typeof rule[prop] === 'string' || typeof rule[prop] === 'number') {
      property = normalizeProperty(prop);
      value = normalizeValue(property, rule[prop]);

      if (important) {
        value += " !important";
      }

      output += "".concat(property, ":").concat(value, ";");
    }
  }

  return output;
};

var inlineStyleConfig = styleConfig = Object.create(null);

var inlineStyle = function inlineStyle(rule, valueToStore, level) {
  var config, styleEl;

  if (!(config = styleConfig[level])) {
    styleEl = document.createElement('style');
    styleEl.id = "quickcss".concat(level || '');
    document.head.appendChild(styleEl);
    styleConfig[level] = config = {
      el: styleEl,
      content: '',
      cache: Object.create(null)
    };
  }

  if (!config.cache[rule]) {
    config.cache[rule] = valueToStore || true;
    config.el.textContent = config.content += rule;
  }
};

var clearInlineStyle = function clearInlineStyle(level) {
  var config, j, key, keys, len1;

  if (config = styleConfig[level]) {
    if (!config.content) {
      return;
    }

    config.el.textContent = config.content = '';
    keys = Object.keys(config.cache);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];
      config.cache[key] = null;
    }
  }
};

var version = "1.4.4";

var _quickcss;

var index = _quickcss = function quickcss(targetEl, property, value, important) {
  var computedStyle, i, len, subEl, subProperty, subValue;

  switch (false) {
    case !isIterable(targetEl):
      for (i = 0, len = targetEl.length; i < len; i++) {
        subEl = targetEl[i];

        _quickcss(subEl, property, value);
      }

      break;

    case _typeof(property) !== 'object':
      // Passed a style map
      for (subProperty in property) {
        subValue = property[subProperty];

        _quickcss(targetEl, subProperty, subValue);
      }

      break;

    default:
      property = normalizeProperty(property);

      if (typeof value === 'undefined') {
        computedStyle = targetEl._computedStyle || (targetEl._computedStyle = getComputedStyle(targetEl));
        return computedStyle[property];
      } else if (property) {
        targetEl.style.setProperty(property, normalizeValue(property, value), important ? IMPORTANT : null);
      }

  }
};

_quickcss.animation = function (name, frames) {
  var frame, generated, prefix, rules;

  if (name && typeof name === 'string' && frames && _typeof(frames) === 'object') {
    prefix = getPrefix('animation');
    generated = '';

    for (frame in frames) {
      rules = frames[frame];
      generated += "".concat(frame, " {").concat(ruleToString(rules), "}");
    }

    generated = "@".concat(prefix, "keyframes ").concat(name, " {").concat(generated, "}");
    return inlineStyle(generated, true, 0);
  }
};

_quickcss.register = function (rule, level, important) {
  var className, ref, style;

  if (rule && _typeof(rule) === 'object') {
    level || (level = 0);
    rule = ruleToString(rule, important);

    if (!(className = (ref = inlineStyleConfig[level]) != null ? ref[rule] : void 0)) {
      className = hash(rule);
      style = ".".concat(className, " {").concat(rule, "}");
      inlineStyle(style, className, level);
    }

    return className;
  }
};

_quickcss.clearRegistered = function (level) {
  return clearInlineStyle(level || 0);
};
/* istanbul ignore next */


_quickcss.UNSET = function () {
  switch (false) {
    case !isValueSupported('display', 'unset'):
      return 'unset';

    case !isValueSupported('display', 'initial'):
      return 'initial';

    case !isValueSupported('display', 'inherit'):
      return 'inherit';
  }
}();

_quickcss.supports = isValueSupported;
_quickcss.supportsProperty = isPropSupported;
_quickcss.normalizeProperty = normalizeProperty;
_quickcss.normalizeValue = normalizeValue;
_quickcss.version = version;function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

var _extend, isArray, isObject, _shouldDeepExtend;

isArray = function isArray(target) {
  return Array.isArray(target);
};

isObject = function isObject(target) {
  return target && Object.prototype.toString.call(target) === '[object Object]' || isArray(target);
};

_shouldDeepExtend = function shouldDeepExtend(options, target, parentKey) {
  if (options.deep) {
    if (options.notDeep) {
      return !options.notDeep[target];
    } else {
      return true;
    }
  } else if (options.deepOnly) {
    return options.deepOnly[target] || parentKey && _shouldDeepExtend(options, parentKey);
  }
}; // else false


var extend = _extend = function extend(options, target, sources, parentKey) {
  var i, key, len, source, sourceValue, subTarget, targetValue;

  if (!target || _typeof$1(target) !== 'object' && typeof target !== 'function') {
    target = {};
  }

  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];

    if (source != null) {
      for (key in source) {
        sourceValue = source[key];
        targetValue = target[key];

        if (sourceValue === target || sourceValue === void 0 || sourceValue === null && !options.allowNull && !options.nullDeletes || options.keys && !options.keys[key] || options.notKeys && options.notKeys[key] || options.own && !source.hasOwnProperty(key) || options.globalFilter && !options.globalFilter(sourceValue, key, source) || options.filters && options.filters[key] && !options.filters[key](sourceValue, key, source)) {
          continue;
        }

        if (sourceValue === null && options.nullDeletes) {
          delete target[key];
          continue;
        }

        if (options.globalTransform) {
          sourceValue = options.globalTransform(sourceValue, key, source);
        }

        if (options.transforms && options.transforms[key]) {
          sourceValue = options.transforms[key](sourceValue, key, source);
        }

        switch (false) {
          case !(options.concat && isArray(sourceValue) && isArray(targetValue)):
            target[key] = targetValue.concat(sourceValue);
            break;

          case !(_shouldDeepExtend(options, key, parentKey) && isObject(sourceValue)):
            subTarget = isObject(targetValue) ? targetValue : isArray(sourceValue) ? [] : {};
            target[key] = _extend(options, subTarget, [sourceValue], key);
            break;

          default:
            target[key] = sourceValue;
        }
      }
    }
  }

  return target;
};

var version$1 = "1.7.4";
var modifiers, newBuilder, normalizeKeys, primaryBuilder;

normalizeKeys = function normalizeKeys(keys) {
  var i, key, len, output;

  if (keys) {
    output = {};

    if (_typeof$1(keys) !== 'object') {
      output[keys] = true;
    } else {
      if (!Array.isArray(keys)) {
        keys = Object.keys(keys);
      }

      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        output[key] = true;
      }
    }

    return output;
  }
};

newBuilder = function newBuilder(isBase) {
  var _builder;

  _builder = function builder(target) {
    var theTarget;
    var $_len = arguments.length,
        $_i = -1,
        sources = new Array($_len);

    while (++$_i < $_len) sources[$_i] = arguments[$_i];

    if (_builder.options.target) {
      theTarget = _builder.options.target;
    } else {
      theTarget = target;
      sources.shift();
    }

    return extend(_builder.options, theTarget, sources);
  };

  if (isBase) {
    _builder.isBase = true;
  }

  _builder.options = {};
  Object.defineProperties(_builder, modifiers);
  return _builder;
};

modifiers = {
  'deep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.deep = true;
      return _;
    }
  },
  'own': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.own = true;
      return _;
    }
  },
  'allowNull': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.allowNull = true;
      return _;
    }
  },
  'nullDeletes': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.nullDeletes = true;
      return _;
    }
  },
  'concat': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.concat = true;
      return _;
    }
  },
  'clone': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.target = {};
      return _;
    }
  },
  'notDeep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notDeep = normalizeKeys(keys);
        return _;
      };
    }
  },
  'deepOnly': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.deepOnly = normalizeKeys(keys);
        return _;
      };
    }
  },
  'keys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.keys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'notKeys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notKeys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'transform': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (transform) {
        if (typeof transform === 'function') {
          _.options.globalTransform = transform;
        } else if (transform && _typeof$1(transform) === 'object') {
          _.options.transforms = transform;
        }

        return _;
      };
    }
  },
  'filter': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (filter) {
        if (typeof filter === 'function') {
          _.options.globalFilter = filter;
        } else if (filter && _typeof$1(filter) === 'object') {
          _.options.filters = filter;
        }

        return _;
      };
    }
  }
};
primaryBuilder = newBuilder(true);
primaryBuilder.version = version$1;
var primaryBuilder$1 = primaryBuilder;function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$2(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var defined = function defined(subject) {
  return subject !== void 0;
};

var array = function array(subject) {
  return subject instanceof Array;
};

var object = function object(subject) {
  return _typeof$2(subject) === 'object' && subject; // 2nd check is to test against 'null' values
};

var objectPlain = function objectPlain(subject) {
  return object(subject) && Object.prototype.toString.call(subject) === '[object Object]' && subject.constructor === Object;
};

var string = function string(subject) {
  return typeof subject === 'string';
};

var number = function number(subject) {
  return typeof subject === 'number' && !isNaN(subject);
};

var numberLoose = function numberLoose(subject) {
  return number(subject) || string(subject) && number(Number(subject));
};

var iterable = function iterable(subject) {
  return object(subject) && number(subject.length);
};

var function_ = function function_(subject) {
  return typeof subject === 'function';
};

var natives = /*#__PURE__*/Object.freeze({
  defined: defined,
  array: array,
  object: object,
  objectPlain: objectPlain,
  string: string,
  number: number,
  numberLoose: numberLoose,
  iterable: iterable,
  function_: function_
});

var domDoc = function domDoc(subject) {
  return subject && subject.nodeType === 9;
};

var domEl = function domEl(subject) {
  return subject && subject.nodeType === 1;
};

var domText = function domText(subject) {
  return subject && subject.nodeType === 3;
};

var domNode = function domNode(subject) {
  return domEl(subject) || domText(subject);
};

var domTextarea = function domTextarea(subject) {
  return subject && subject.nodeName === 'TEXTAREA';
};

var domInput = function domInput(subject) {
  return subject && subject.nodeName === 'INPUT';
};

var domSelect = function domSelect(subject) {
  return subject && subject.nodeName === 'SELECT';
};

var domField = function domField(subject) {
  return domInput(subject) || domTextarea(subject) || domSelect(subject);
};

var dom = /*#__PURE__*/Object.freeze({
  domDoc: domDoc,
  domEl: domEl,
  domText: domText,
  domNode: domNode,
  domTextarea: domTextarea,
  domInput: domInput,
  domSelect: domSelect,
  domField: domField
});
var AVAIL_SETS, Checks;
AVAIL_SETS = {
  natives: natives,
  dom: dom
};

Checks = /*#__PURE__*/function () {
  _createClass(Checks, [{
    key: "create",
    value: function create() {
      var args;

      if (arguments.length) {
        args = Array.prototype.slice.call(arguments);
      }

      return new Checks(args);
    }
  }]);

  function Checks(sets) {
    _classCallCheck(this, Checks);

    var i, len, set;

    if (sets == null) {
      sets = ['natives'];
    }

    for (i = 0, len = sets.length; i < len; i++) {
      set = sets[i];

      if (AVAIL_SETS[set]) {
        this.load(AVAIL_SETS[set]);
      }
    }
  }

  _createClass(Checks, [{
    key: "load",
    value: function load(set) {
      var key, value;

      if (AVAIL_SETS.natives.string(set)) {
        set = AVAIL_SETS[set];
      }

      if (!AVAIL_SETS.natives.objectPlain(set)) {
        return;
      }

      for (key in set) {
        value = set[key];

        if (key === 'function_') {
          key = 'function';
        }

        this[key] = value;
      }
    }
  }]);

  return Checks;
}();

var index$1 = Checks.prototype.create();function _typeof$3(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$3(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var template = ['id', 'name', 'type', 'href', 'selected', 'checked', 'className']; // To copy from DOM Elements

var element = ['id', 'ref', 'type', 'name', 'text', 'style', 'class', 'className', 'url', 'href', 'selected', 'checked', 'props', 'attrs', 'passStateToChildren', 'stateTriggers', 'unpassableStates']; // Used in QuickElement::toJSON
// 'relatedInstance'

var IS;
IS = index$1.create('natives', 'dom');
IS.load({
  quickDomEl: function quickDomEl(subject) {
    return subject && subject.constructor.name === 'QuickElement';
  },
  template: function template(subject) {
    return subject && subject.constructor.name === 'QuickTemplate';
  }
}); // batch: (subject)-> subject and subject.constructor.name is 'QuickBatch'

var IS$1 = IS;

var QuickElement, QuickWindow, _quickdom;

QuickElement = null;
QuickWindow = null;

_quickdom = function quickdom() {
  var arg, args, element, i, j, len, prevCount;
  args = new Array(arguments.length);

  for (i = j = 0, len = arguments.length; j < len; i = ++j) {
    arg = arguments[i];
    args[i] = arg;
  }

  prevCount = QuickElement.count;
  element = _quickdom.create(args);

  if (element && element._postCreation && QuickElement.count !== prevCount) {
    element._postCreation();
  }

  return element;
};

_quickdom.create = function (args) {
  var argsLength, child, children, element, i, j, len, options, type;

  switch (false) {
    case !IS$1.array(args[0]):
      return _quickdom.apply(void 0, _toConsumableArray(args[0]));

    case !IS$1.template(args[0]):
      return args[0].spawn();

    case !IS$1.quickDomEl(args[0]):
      if (args[1]) {
        return args[0].updateOptions(args[1]);
      } else {
        return args[0];
      }

    case !(IS$1.domNode(args[0]) || IS$1.domDoc(args[0])):
      if (args[0]._quickElement) {
        return args[0]._quickElement;
      }

      type = args[0].nodeName.toLowerCase().replace('#', '');
      options = args[1] || {};
      options.existing = args[0];
      return new QuickElement(type, options);

    case args[0] !== window:
      return QuickWindow;

    case !IS$1.string(args[0]):
      type = args[0].toLowerCase();

      if (type === 'text') {
        options = IS$1.object(args[1]) ? args[1] : {
          text: args[1] || ''
        };
      } else {
        options = IS$1.object(args[1]) ? args[1] : {};
      }

      element = new QuickElement(type, options);

      if (args.length > 2) {
        children = new Array(argsLength = args.length);
        i = 1;

        while (++i < argsLength) {
          children[i + 1] = args[i];
        }

        for (j = 0, len = children.length; j < len; j++) {
          child = children[j];

          if (IS$1.string(child)) {
            child = _quickdom.text(child);
          }

          if (IS$1.array(child)) {
            child = _quickdom.apply(void 0, _toConsumableArray(child));
          }

          if (IS$1.quickDomEl(child)) {
            element.append(child);
          }
        }
      }

      return element;

    case !(args[0] && (IS$1.domNode(args[0][0]) || IS$1.domDoc(args[0][0]))):
      return _quickdom(args[0][0]);
  }
};

_quickdom.html = function (innerHTML) {
  var children, container;
  container = document.createElement('div');
  container.innerHTML = innerHTML;
  children = Array.prototype.slice.call(container.childNodes);
  return _quickdom.batch(children);
};

_quickdom.isQuickEl = function (target) {
  return IS$1.quickDomEl(target);
};

_quickdom.isEl = function (target) {
  return IS$1.domEl(target);
};

var init = function init(QuickElement_, QuickWindow_) {
  QuickElement = QuickElement_;
  QuickWindow = QuickWindow_;
  return _quickdom;
};

var includes$1 = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var removeItem = function removeItem(target, item) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    target.splice(itemIndex, 1);
  }

  return target;
};

var normalizeElementArg = function normalizeElementArg(targetEl) {
  switch (false) {
    case !IS$1.string(targetEl):
      return quickdom.text(targetEl);

    case !IS$1.domNode(targetEl):
      return quickdom(targetEl);

    case !IS$1.template(targetEl):
      return targetEl.spawn();

    default:
      return targetEl;
  }
};

var isStateStyle = function isStateStyle(string) {
  return string[0] === '$' || string[0] === '@';
};

var registerStyle = function registerStyle(rule, level, important) {
  var cached, i, len, output, prop, props;
  level || (level = 0);
  cached = styleCache.get(rule, level);

  if (cached) {
    return cached;
  }

  output = {
    className: [index.register(rule, level, important)],
    fns: [],
    rule: rule
  };
  props = Object.keys(rule);

  for (i = 0, len = props.length; i < len; i++) {
    prop = props[i];

    if (typeof rule[prop] === 'function') {
      output.fns.push([prop, rule[prop]]);
    }
  }

  return styleCache.set(rule, output, level);
};

var styleCache = new ( /*#__PURE__*/function () {
  function _class() {
    _classCallCheck$1(this, _class);

    this.keys = Object.create(null);
    this.values = Object.create(null);
  }

  _createClass$1(_class, [{
    key: "get",
    value: function get(key, level) {
      var index;

      if (this.keys[level]) {
        index = this.keys[level].indexOf(key);

        if (index !== -1) {
          return this.values[level][index];
        }
      }
    }
  }, {
    key: "set",
    value: function set(key, value, level) {
      if (!this.keys[level]) {
        this.keys[level] = [];
        this.values[level] = [];
      }

      this.keys[level].push(key);
      this.values[level].push(value);
      return value;
    }
  }]);

  return _class;
}())();
var REGEX_WHITESPACE;
REGEX_WHITESPACE = /\s+/;

var on_ = function on_(eventNames, callback, useCapture, isPrivate) {
  var _this = this;

  var callbackRef, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (IS$1.string(eventNames) && IS$1["function"](callback)) {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];

    if (eventNames === 'inserted' && this._inserted) {
      callback.call(this, this._parent);
      return this;
    }

    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var base;

      if (!_this._eventCallbacks[eventName]) {
        _this._eventCallbacks[eventName] = [];

        if (!isPrivate) {
          _this._listenTo(eventName, function (event) {
            return _this._invokeHandlers(eventName, event);
          }, useCapture);
        }
      }

      if (callbackRef) {
        if ((base = _this._eventCallbacks.__refs)[eventName] == null) {
          base[eventName] = {};
        }

        _this._eventCallbacks.__refs[eventName][callbackRef] = callback;
      }

      return _this._eventCallbacks[eventName].push(callback);
    });
  }

  return this;
};

var once = function once(eventNames, callback) {
  var _this2 = this;

  var _onceCallback;

  if (IS$1.string(eventNames) && IS$1["function"](callback)) {
    this.on(eventNames, _onceCallback = function onceCallback(event) {
      _this2.off(eventNames, _onceCallback);

      return callback.call(_this2, event);
    });
  }

  return this;
};

var off_ = function off_(eventNames, callback) {
  var _this3 = this;

  var callbackRef, eventName, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (!IS$1.string(eventNames)) {
    for (eventName in this._eventCallbacks) {
      this.off(eventName);
    }
  } else {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];
    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var ref;

      if (_this3._eventCallbacks[eventName]) {
        if (callback == null) {
          callback = (ref = _this3._eventCallbacks.__refs[eventName]) != null ? ref[callbackRef] : void 0;
        }

        if (IS$1["function"](callback)) {
          return removeItem(_this3._eventCallbacks[eventName], callback);
        } else if (!callbackRef) {
          return _this3._eventCallbacks[eventName].length = 0;
        }
      }
    });
  }

  return this;
};

var emit = function emit(eventName) {
  var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var data = arguments.length > 3 ? arguments[3] : undefined;
  var event;

  if (eventName && IS$1.string(eventName)) {
    event = document.createEvent('Event');
    event.initEvent(eventName, bubbles, cancelable);

    if (data && _typeof$3(data) === 'object') {
      primaryBuilder$1(event, data);
    }

    this.el.dispatchEvent(event);
  }

  return this;
};

var emitPrivate = function emitPrivate(eventName, arg) {
  var ref;

  if (eventName && IS$1.string(eventName) && ((ref = this._eventCallbacks) != null ? ref[eventName] : void 0)) {
    this._invokeHandlers(eventName, arg);
  }

  return this;
};

var _invokeHandlers = function _invokeHandlers(eventName, arg) {
  var callbacks, cb, i, len;
  callbacks = this._eventCallbacks[eventName].slice();

  for (i = 0, len = callbacks.length; i < len; i++) {
    cb = callbacks[i];
    cb.call(this, arg);
  }
};
/* istanbul ignore next */


var _listenTo = function _listenTo(eventName, callback, useCapture) {
  var eventNameToListenFor, listenMethod;
  listenMethod = this.el.addEventListener ? 'addEventListener' : 'attachEvent';
  eventNameToListenFor = this.el.addEventListener ? eventName : "on".concat(eventName);
  this.el[listenMethod](eventNameToListenFor, callback, useCapture);
  return this;
};

function events(QuickElement) {
  QuickElement.prototype.on = on_;
  QuickElement.prototype.once = once;
  QuickElement.prototype.off = off_;
  QuickElement.prototype.emit = emit;
  QuickElement.prototype.emitPrivate = emitPrivate;
  QuickElement.prototype._invokeHandlers = _invokeHandlers;
  return QuickElement.prototype._listenTo = _listenTo;
}
/**
* Sets/gets the value of a style property. In getter mode the computed property of
* the style will be returned unless the element is not inserted into the DOM. In
* webkit browsers all computed properties of a detached node are always an empty
* string but in gecko they reflect on the actual computed value, hence we need
* to "normalize" this behavior and make sure that even on gecko an empty string
* is returned
* @return {[type]} [description]
*/


var style = function style(property) {
  var _this = this;

  var args, i, key, keys, result, value;

  if (this.type === 'text') {
    return;
  }

  args = arguments;

  if (IS$1.string(property)) {
    value = typeof args[1] === 'function' ? args[1].call(this, this.related) : args[1];

    if (args[1] === null && IS$1.defined(this.currentStateStyle(property)) && !IS$1["function"](this.currentStateStyle(property))) {
      value = index.UNSET;
    }

    if (value && typeof value.then === 'function') {
      value.then(function (value) {
        return index(_this.el, property, value, _this.options.forceStyle);
      });
    } else {
      result = index(this.el, property, value, this.options.forceStyle);
    }

    if (args.length === 1) {
      /* istanbul ignore next */
      if (this._inserted) {
        return result;
      } else if (!result) {
        return result;
      } else {
        return '';
      }
    }
  } else if (IS$1.object(property)) {
    keys = Object.keys(property);
    i = -1;

    while (key = keys[++i]) {
      this.style(key, property[key]);
    }
  }

  return this;
};
/**
 * Attempts to resolve the value for a given property in the following order if each one isn't a valid value:
 * 1. from computed style (for dom-inserted els)
 * 2. from DOMElement.style object (for non-inserted els; if options.styleAfterInsert, will only have state styles)
 * 3. from provided style options
 * (for non-inserted els; checking only $base since state styles will always be applied to the style object even for non-inserted)
 */


var styleSafe = function styleSafe(property, skipComputed) {
  var computed, result, sample;

  if (this.type === 'text') {
    return;
  }

  sample = this.el.style[property];

  if (IS$1.string(sample) || IS$1.number(sample)) {
    computed = skipComputed ? 0 : this.style(property);
    result = computed || this.el.style[property] || this.currentStateStyle(property) || '';

    if (typeof result === 'function') {
      return result.call(this, this.related);
    } else {
      return result;
    }
  }

  return this;
};

var styleParsed = function styleParsed(property, skipComputed) {
  return parseFloat(this.styleSafe(property, skipComputed));
};

var recalcStyle = function recalcStyle(recalcChildren) {
  var child, j, len, ref, targetStyles;
  targetStyles = this._resolveFnStyles(this._getActiveStates(), true);
  this.style(targetStyles);

  if (recalcChildren) {
    ref = this._children;

    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      child.recalcStyle();
    }
  }

  return this;
};

var currentStateStyle = function currentStateStyle(property) {
  var i, state, states;

  if (property) {
    if (this._state.length) {
      states = this._state.slice();

      if (this._stateShared && this._stateShared.length) {
        var _states;

        (_states = states).push.apply(_states, _toConsumableArray(this._stateShared));
      }

      i = states.length;

      while (state = states[--i]) {
        if (this._styles[state] && IS$1.defined(this._styles[state].rule[property])) {
          return this._styles[state].rule[property];
        }
      }
    }

    if (this._styles.base) {
      return this._styles.base.rule[property];
    }
  }
};

var hide = function hide() {
  return this.style('display', 'none');
};

var show = function show(display) {
  var ref;

  if (!display) {
    display = this.currentStateStyle('display');

    if (display === 'none' || !display) {
      display = 'block';
    }
  }

  if (display == null) {
    display = ((ref = this._styles.base) != null ? ref.display : void 0) || 'block';
  }

  return this.style('display', display);
};

var orientationGetter = {
  get: function get() {
    if (this.width > this.height) {
      return 'landscape';
    } else {
      return 'portrait';
    }
  }
};
var aspectRatioGetter = {
  get: function get() {
    return this.width / this.height;
  }
};

function style$1(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'orientation': orientationGetter,
    'aspectRatio': aspectRatioGetter,
    'rect': {
      get: function get() {
        return this.el.getBoundingClientRect();
      }
    },
    'width': {
      get: function get() {
        return parseFloat(this.style('width'));
      },
      set: function set(value) {
        return this.style('width', value);
      }
    },
    'height': {
      get: function get() {
        return parseFloat(this.style('height'));
      },
      set: function set(value) {
        return this.style('height', value);
      }
    }
  });
  QuickElement.prototype.style = style;
  QuickElement.prototype.styleSafe = styleSafe;
  QuickElement.prototype.styleParsed = styleParsed;
  QuickElement.prototype.recalcStyle = recalcStyle;
  QuickElement.prototype.currentStateStyle = currentStateStyle;
  QuickElement.prototype.hide = hide;
  return QuickElement.prototype.show = show;
}

var QuickWindow$1;
var QuickWindow$2 = QuickWindow$1 = {
  type: 'window',
  el: window,
  raw: window,
  _eventCallbacks: {
    __refs: {}
  }
};
QuickWindow$1.on = on_;
QuickWindow$1.off = off_;
QuickWindow$1.emit = emit;
QuickWindow$1.emitPrivate = emitPrivate;
QuickWindow$1._listenTo = _listenTo;
QuickWindow$1._invokeHandlers = _invokeHandlers;
Object.defineProperties(QuickWindow$1, {
  'width': {
    get: function get() {
      return window.innerWidth;
    }
  },
  'height': {
    get: function get() {
      return window.innerHeight;
    }
  },
  'orientation': orientationGetter,
  'aspectRatio': aspectRatioGetter
});
var MediaQuery, RULE_DEILIMITER;
RULE_DEILIMITER = /,\s*/;
var MediaQuery$1 = MediaQuery = new function () {
  var callbacks, testRule;
  callbacks = [];
  window.addEventListener('resize', function () {
    var callback, i, len;

    for (i = 0, len = callbacks.length; i < len; i++) {
      callback = callbacks[i];
      callback();
    }
  });

  this.parseQuery = function (target, queryString) {
    var querySplit, rules, source;
    querySplit = queryString.split('(');
    source = querySplit[0];

    source = function () {
      switch (source) {
        case 'window':
          return QuickWindow$2;

        case 'parent':
          return target.parent;

        case 'self':
          return target;

        default:
          return target.parentMatching(function (parent) {
            return parent.ref === source.slice(1);
          });
      }
    }();

    rules = querySplit[1].slice(0, -1).split(RULE_DEILIMITER).map(function (rule) {
      var getter, key, keyPrefix, max, min, split, value;
      split = rule.split(':');
      value = parseFloat(split[1]);

      if (isNaN(value)) {
        value = split[1];
      }

      key = split[0];
      keyPrefix = key.slice(0, 4);
      max = keyPrefix === 'max-';
      min = !max && keyPrefix === 'min-';

      if (max || min) {
        key = key.slice(4);
      }

      getter = function () {
        switch (key) {
          case 'orientation':
            return function () {
              return source.orientation;
            };

          case 'aspect-ratio':
            return function () {
              return source.aspectRatio;
            };

          case 'width':
          case 'height':
            return function () {
              return source[key];
            };

          default:
            return function () {
              var parsedValue, stringValue;
              stringValue = source.style(key);
              parsedValue = parseFloat(stringValue);

              if (isNaN(parsedValue)) {
                return stringValue;
              } else {
                return parsedValue;
              }
            };
        }
      }();

      return {
        key: key,
        value: value,
        min: min,
        max: max,
        getter: getter
      };
    });
    return {
      source: source,
      rules: rules
    };
  };

  this.register = function (target, queryString) {
    var callback, query;
    query = this.parseQuery(target, queryString);

    if (query.source) {
      callbacks.push(callback = function callback() {
        return testRule(target, query, queryString);
      });
      callback();
    }

    return query;
  };

  testRule = function testRule(target, query, queryString) {
    var currentValue, i, len, passed, ref, rule;
    passed = true;
    ref = query.rules;

    for (i = 0, len = ref.length; i < len; i++) {
      rule = ref[i];
      currentValue = rule.getter();

      passed = function () {
        switch (false) {
          case !rule.min:
            return currentValue >= rule.value;

          case !rule.max:
            return currentValue <= rule.value;

          default:
            return currentValue === rule.value;
        }
      }();

      if (!passed) {
        break;
      }
    }

    return target.state(queryString, passed);
  };

  return this;
}();
var StateChain;

var StateChain$1 = StateChain = /*#__PURE__*/function () {
  function StateChain(states) {
    _classCallCheck$1(this, StateChain);

    this.string = states.join('+');
    this.array = states.slice();
    this.length = states.length;
  }

  _createClass$1(StateChain, [{
    key: "includes",
    value: function includes(target) {
      var i, len, ref, state;
      ref = this.array;

      for (i = 0, len = ref.length; i < len; i++) {
        state = ref[i];

        if (state === target) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "without",
    value: function without(target) {
      return this.array.filter(function (state) {
        return state !== target;
      }).join('+');
    }
  }, {
    key: "isApplicable",
    value: function isApplicable(target, otherActive) {
      var active;
      active = this.array.filter(function (state) {
        return state === target || otherActive.indexOf(state) !== -1;
      });
      return active.length === this.array.length;
    }
  }]);

  return StateChain;
}();

var BASE_STATE_TRIGGERS, CACHED_FN_INSERTED;
BASE_STATE_TRIGGERS = {
  'hover': {
    on: 'mouseenter',
    off: 'mouseleave',
    bubbles: true
  },
  'focus': {
    on: 'focus',
    off: 'blur',
    bubbles: true
  }
};

var _normalizeOptions = function _normalizeOptions() {
  var base1, base2, base3, base4, base5;

  if (this.options.relatedInstance) {
    (base1 = this.options).related || (base1.related = this.options.relatedInstance);
    this.options.relatedInstance = null;
  }

  this.related = (base2 = this.options).related != null ? base2.related : base2.related = this;

  if (this.options["class"]) {
    this.options.className = this.options["class"];
  }

  if (this.options.url) {
    this.options.href = this.options.url;
  }

  if ((base3 = this.options).unpassableStates == null) {
    base3.unpassableStates = [];
  }

  if ((base4 = this.options).passStateToChildren == null) {
    base4.passStateToChildren = true;
  }

  if ((base5 = this.options).passDataToChildren == null) {
    base5.passDataToChildren = true;
  }

  this.options.stateTriggers = this.options.stateTriggers ? primaryBuilder$1.clone.deep(BASE_STATE_TRIGGERS, this.options.stateTriggers) : BASE_STATE_TRIGGERS;

  if (this.type === 'text') {
    primaryBuilder$1(this, this._parseTexts(this.options.text, this._texts));
  } else {
    primaryBuilder$1(this, this._parseStyles(this.options.style, this._styles));
  }
};

var _parseStyles = function _parseStyles(styles, store) {
  var _mediaStates, _providedStates, _providedStatesShared, _stateShared, _styles, base, _flattenNestedStates, forceStyle, i, keys, len, specialStates, state, stateStyles, state_, states;

  if (!IS$1.objectPlain(styles)) {
    return;
  }

  keys = Object.keys(styles);
  states = keys.filter(function (key) {
    return isStateStyle(key);
  });
  specialStates = removeItem(states.slice(), '$base');
  _mediaStates = states.filter(function (key) {
    return key[0] === '@';
  }).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.map(function (state) {
    return state.slice(1); // Remove '$' prefix
  });
  _styles = store || {};
  _stateShared = _providedStatesShared = void 0;
  base = !includes$1(states, '$base') ? styles : styles.$base;
  _styles.base = registerStyle(base, 0, forceStyle = this.options.forceStyle);

  if (specialStates.length) {
    _flattenNestedStates = function flattenNestedStates(styleObject, chain, level) {
      var hasNonStateProps, i, len, output, state, stateChain, state_, styleKeys;
      styleKeys = Object.keys(styleObject);
      output = {};
      hasNonStateProps = false;

      for (i = 0, len = styleKeys.length; i < len; i++) {
        state = styleKeys[i];

        if (!isStateStyle(state)) {
          hasNonStateProps = true;
          output[state] = styleObject[state];
        } else {
          chain.push(state_ = state.slice(1));
          stateChain = new StateChain$1(chain);

          if (_stateShared == null) {
            _stateShared = [];
          }

          if (_providedStatesShared == null) {
            _providedStatesShared = [];
          }

          _providedStatesShared.push(stateChain);

          if (state[0] === '@') {
            _mediaStates.push(state_);
          }

          _styles[stateChain.string] = registerStyle(_flattenNestedStates(styleObject[state], chain, level + 1), level + 1, forceStyle);
        }
      }

      if (hasNonStateProps) {
        return output;
      }
    };

    for (i = 0, len = specialStates.length; i < len; i++) {
      state = specialStates[i];
      state_ = state.slice(1);
      stateStyles = _flattenNestedStates(styles[state], [state_], 1);

      if (stateStyles) {
        _styles[state_] = registerStyle(stateStyles, 1);
      }
    }
  }

  return {
    _styles: _styles,
    _mediaStates: _mediaStates,
    _stateShared: _stateShared,
    _providedStates: _providedStates,
    _providedStatesShared: _providedStatesShared
  };
};

var _parseTexts = function _parseTexts(texts, store) {
  var _providedStates, _texts, i, len, state, states;

  if (!IS$1.objectPlain(texts)) {
    return;
  }

  states = Object.keys(texts).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.filter(function (state) {
    return state !== 'base';
  });
  _texts = store || {};
  _texts = {
    base: ''
  };

  for (i = 0, len = states.length; i < len; i++) {
    state = states[i];
    _texts[state] = texts['$' + state];
  }

  return {
    _texts: _texts,
    _providedStates: _providedStates
  };
};

var _applyOptions = function _applyOptions() {
  var _this = this;

  var event, handler, method, ref, ref1, ref2, value;

  if (ref = this.options.id || this.options.ref) {
    this.attr('data-ref', this.ref = ref);
  }

  if (this.options.id) {
    this.el.id = this.options.id;
  }

  if (this.options.className) {
    this.el.className = this.options.className;
  }

  if (this.options.src) {
    this.el.src = this.options.src;
  }

  if (this.options.href) {
    this.el.href = this.options.href;
  }

  if (this.options.type) {
    this.el.type = this.options.type;
  }

  if (this.options.name) {
    this.el.name = this.options.name;
  }

  if (this.options.value) {
    this.el.value = this.options.value;
  }

  if (this.options.selected) {
    this.el.selected = this.options.selected;
  }

  if (this.options.checked) {
    this.el.checked = this.options.checked;
  }

  if (this.options.props) {
    this.prop(this.options.props);
  }

  if (this.options.attrs) {
    this.attr(this.options.attrs);
  }

  this._applyRegisteredStyle(this._styles.base, null, null, this.options.styleAfterInsert);

  if (this._texts) {
    this.text = this._texts.base;
  }

  this.on('inserted', CACHED_FN_INSERTED, false, true);

  if (this.options.invokeComputersOnce) {
    this._invokedComputers = {};
  }

  if (this.options.recalcOnResize) {
    window.addEventListener('resize', function () {
      return _this.recalcStyle();
    });
  }

  if (this.options.events) {
    ref1 = this.options.events;

    for (event in ref1) {
      handler = ref1[event];
      this.on(event, handler);
    }
  }

  if (this.options.methods) {
    ref2 = this.options.methods;

    for (method in ref2) {
      value = ref2[method];

      if (!this[method]) {
        if (IS$1["function"](value)) {
          this[method] = value;
        } else if (IS$1.object(value)) {
          Object.defineProperty(this, method, {
            configurable: true,
            get: value.get,
            set: value.set
          });
        }
      }
    }
  }

  if (this.type !== 'text' && IS$1.object(this.options.text)) {
    this.append(_quickdom('text', {
      text: this.options.text
    }));
  }
};

var _postCreation = function _postCreation(data) {
  if (this.options.computers) {
    if (data && this.options.data) {
      data = primaryBuilder$1.clone(this.options.data, data);
    }

    data || (data = this.options.data);
    this.applyData(data, false);

    if (this.options.computers._init) {
      this._runComputer('_init', data);
    }
  }

  if (this.options.state) {
    this.state(this.options.state);
  }
};

var _attachStateEvents = function _attachStateEvents(force) {
  var _this2 = this;

  var states;
  states = Object.keys(this.options.stateTriggers);
  states.forEach(function (state) {
    var disabler, enabler, trigger;
    trigger = _this2.options.stateTriggers[state];

    if (!includes$1(_this2._providedStates, state) && !force && !trigger.force) {
      return;
    }

    enabler = IS$1.string(trigger) ? trigger : trigger.on;

    if (IS$1.object(trigger)) {
      disabler = trigger.off;
    }

    _this2._listenTo(enabler, function () {
      return _this2.state(state, true, trigger.bubbles);
    });

    if (disabler) {
      return _this2._listenTo(disabler, function () {
        return _this2.state(state, false, trigger.bubbles);
      });
    }
  });
};

var _proxyParent = function _proxyParent() {
  var parent;
  parent = void 0;
  return Object.defineProperty(this, '_parent', {
    get: function get() {
      return parent;
    },
    set: function set(newParent) {
      var _this3 = this;

      var lastParent;

      if (parent = newParent) {
        lastParent = this.parents.slice(-1)[0];

        if (lastParent.raw === document.documentElement) {
          this._unproxyParent(newParent);
        } else {
          parent.on('inserted', function () {
            if (parent === newParent) {
              return _this3._unproxyParent(newParent);
            }
          });
        }
      }
    }
  });
};

var _unproxyParent = function _unproxyParent(newParent) {
  delete this._parent;
  this._parent = newParent;
  this.emitPrivate('inserted', newParent);
};

CACHED_FN_INSERTED = function CACHED_FN_INSERTED() {
  var i, len, mediaStates, queryString, results;
  this._inserted = this;

  if (this.options.styleAfterInsert) {
    this.recalcStyle();
  }

  if ((mediaStates = this._mediaStates) && this._mediaStates.length) {
    this._mediaStates = Object.create(null);
    results = [];

    for (i = 0, len = mediaStates.length; i < len; i++) {
      queryString = mediaStates[i];
      results.push(this._mediaStates[queryString] = MediaQuery$1.register(this, queryString));
    }

    return results;
  }
};

function init$1(QuickElement) {
  QuickElement.prototype._normalizeOptions = _normalizeOptions;
  QuickElement.prototype._parseStyles = _parseStyles;
  QuickElement.prototype._parseTexts = _parseTexts;
  QuickElement.prototype._applyOptions = _applyOptions;
  QuickElement.prototype._postCreation = _postCreation;
  QuickElement.prototype._attachStateEvents = _attachStateEvents;
  QuickElement.prototype._proxyParent = _proxyParent;
  return QuickElement.prototype._unproxyParent = _unproxyParent;
}

function aliases(QuickElement) {
  return Object.defineProperties(QuickElement.prototype, {
    'raw': {
      get: function get() {
        return this.el;
      }
    },
    '0': {
      get: function get() {
        return this.el;
      }
    },
    'css': {
      get: function get() {
        return this.style;
      }
    },
    'replaceWith': {
      get: function get() {
        return this.replace;
      }
    },
    'removeListener': {
      get: function get() {
        return this.off;
      }
    }
  });
}

var parentsUntil = function parentsUntil(filter) {
  return _getParents(this, filter);
};

var parentMatching = function parentMatching(filter) {
  var isRef, nextParent;

  if (IS$1["function"](filter) || (isRef = IS$1.string(filter))) {
    nextParent = this.parent;

    while (nextParent) {
      if (isRef) {
        if (nextParent.ref === filter) {
          return nextParent;
        }
      } else {
        if (filter(nextParent)) {
          return nextParent;
        }
      }

      nextParent = nextParent.parent;
    }
  }
};

var query = function query(selector) {
  return _quickdom(this.raw.querySelector(selector));
};

var queryAll = function queryAll(selector) {
  var i, item, len, output, result;
  result = this.raw.querySelectorAll(selector);
  output = [];

  for (i = 0, len = result.length; i < len; i++) {
    item = result[i];
    output.push(item);
  }

  return _quickdom.batch(output);
};

var _getParents = function _getParents(targetEl, filter) {
  var isRef, nextParent, parents;

  if (!IS$1["function"](filter) && !(isRef = IS$1.string(filter))) {
    filter = void 0;
  }

  parents = [];
  nextParent = targetEl.parent;

  while (nextParent) {
    parents.push(nextParent);
    nextParent = nextParent.parent;

    if (isRef) {
      if (nextParent && nextParent.ref === filter) {
        nextParent = null;
      }
    } else if (filter) {
      if (filter(nextParent)) {
        nextParent = null;
      }
    }
  }

  return parents;
};

var _getChildRefs = function _getChildRefs(target, freshCopy) {
  var child, childRefs, children, el, i, len, ref, refs;

  if (freshCopy || !target._childRefs) {
    target._childRefs = {};
  }

  refs = target._childRefs;

  if (target.ref) {
    refs[target.ref] = target;
  }

  children = target.children;

  if (children.length) {
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      childRefs = _getChildRefs(child, freshCopy);

      for (ref in childRefs) {
        el = childRefs[ref];
        refs[ref] || (refs[ref] = el);
      }
    }
  }

  return refs;
};

var _getIndexByProp = function _getIndexByProp(main, prop) {
  var parent;

  if (!(parent = main.parent)) {
    return null;
  } else {
    return parent.children.filter(function (child) {
      return child[prop] === main[prop];
    }).indexOf(main);
  }
};

var _filterElements = function _filterElements(array) {
  var i, item, len, output;

  if (!array.length) {
    return array;
  } else {
    output = [];

    for (i = 0, len = array.length; i < len; i++) {
      item = array[i];

      if (item.type !== 'text') {
        output.push(item);
      }
    }

    return output;
  }
};

function traversing(QuickElement) {
  QuickElement.prototype.parentsUntil = parentsUntil;
  QuickElement.prototype.parentMatching = parentMatching;
  QuickElement.prototype.query = query;
  QuickElement.prototype.queryAll = queryAll;
  return Object.defineProperties(QuickElement.prototype, {
    'children': {
      get: function get() {
        var child, i, len, ref1;

        if (this.el.childNodes.length !== this._children.length) {
          // Re-collect children	
          this._children.length = 0; // Empty out children array

          ref1 = this.el.childNodes;

          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];

            if (child.nodeType < 4) {
              this._children.push(_quickdom(child));
            }
          }
        }

        return this._children;
      }
    },
    'elementChildren': {
      get: function get() {
        return _filterElements(this.children);
      }
    },
    'parent': {
      get: function get() {
        if ((!this._parent || this._parent.el !== this.el.parentNode) && !IS$1.domDoc(this.el.parentNode)) {
          this._parent = _quickdom(this.el.parentNode);
        }

        return this._parent;
      }
    },
    'parents': {
      get: function get() {
        return _getParents(this);
      }
    },
    'next': {
      get: function get() {
        return _quickdom(this.el.nextSibling);
      }
    },
    'nextEl': {
      get: function get() {
        return _quickdom(this.el.nextElementSibling);
      }
    },
    'nextElAll': {
      get: function get() {
        return _filterElements(this.nextAll);
      }
    },
    'nextAll': {
      get: function get() {
        var nextSibling, siblings;
        siblings = [];
        nextSibling = _quickdom(this.el.nextSibling);

        while (nextSibling) {
          siblings.push(nextSibling);
          nextSibling = nextSibling.next;
        }

        return siblings;
      }
    },
    'prev': {
      get: function get() {
        return _quickdom(this.el.previousSibling);
      }
    },
    'prevEl': {
      get: function get() {
        return _quickdom(this.el.previousElementSibling);
      }
    },
    'prevElAll': {
      get: function get() {
        return _filterElements(this.prevAll);
      }
    },
    'prevAll': {
      get: function get() {
        var prevSibling, siblings;
        siblings = [];
        prevSibling = _quickdom(this.el.previousSibling);

        while (prevSibling) {
          siblings.push(prevSibling);
          prevSibling = prevSibling.prev;
        }

        return siblings;
      }
    },
    'siblings': {
      get: function get() {
        return this.prevAll.reverse().concat(this.nextAll);
      }
    },
    'elementSiblings': {
      get: function get() {
        return _filterElements(this.siblings);
      }
    },
    'child': {
      get: function get() {
        return this._childRefs || _getChildRefs(this);
      }
    },
    'childf': {
      get: function get() {
        return _getChildRefs(this, true);
      }
    },
    'firstChild': {
      get: function get() {
        return this.children[0];
      }
    },
    'lastChild': {
      get: function get() {
        var children;
        children = this.children;
        return children[children.length - 1];
      }
    },
    'index': {
      get: function get() {
        var parent;

        if (!(parent = this.parent)) {
          return null;
        } else {
          return parent.children.indexOf(this);
        }
      }
    },
    'indexType': {
      get: function get() {
        return _getIndexByProp(this, 'type');
      }
    },
    'indexRef': {
      get: function get() {
        return _getIndexByProp(this, 'ref');
      }
    }
  });
}

_quickdom.query = function (target) {
  return _quickdom(document).query(target);
};

_quickdom.queryAll = function (target) {
  return _quickdom(document).queryAll(target);
};

var DUMMY_ARRAY;
DUMMY_ARRAY = [];

var state = function state(targetState, value, bubbles, source) {
  var activeStates, child, desiredValue, i, j, key, keys, len, prop, ref, toggle;

  if (arguments.length === 0) {
    return this._state.slice();
  }

  if (arguments.length === 1) {
    if (IS$1.string(targetState)) {
      return includes$1(this._state, targetState);
    } else if (IS$1.object(targetState)) {
      keys = Object.keys(targetState);
      i = -1;

      while (key = keys[++i]) {
        this.state(key, targetState[key]);
      }

      return this;
    }
  } else if (this._statePipeTarget && source !== this) {
    this._statePipeTarget.state(targetState, value, bubbles, this);

    return this;
  } else if (IS$1.string(targetState)) {
    if (targetState[0] === '$') {
      targetState = targetState.slice(1);
    }

    if (targetState === 'base') {
      return this;
    }

    desiredValue = !!value; // Convert the value to a boolean

    activeStates = this._getActiveStates(targetState, false); // ==== Toggle styles for this state =================================================================================

    if (this.state(targetState) !== desiredValue) {
      prop = this.type === 'text' ? 'Text' : 'Style';

      if (desiredValue) {
        //is on
        this._state.push(targetState);

        toggle = 'ON';
      } else {
        removeItem(this._state, targetState);
        toggle = 'OFF';
      }

      this['_turn' + prop + toggle](targetState, activeStates);
      this.emitPrivate("stateChange:".concat(targetState), desiredValue);
    } // ==== Pass state to parent/children =================================================================================


    if (!includes$1(this.options.unpassableStates, targetState)) {
      if (bubbles) {
        if (this.parent) {
          this._parent.state(targetState, value, true, source || this);
        }
      } else if (this.options.passStateToChildren) {
        ref = this._children;

        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.state(targetState, value, false, source || this);
        }
      }
    }

    return this;
  }
};

var toggleState = function toggleState(targetState) {
  return this.state(targetState, !this.state(targetState));
};

var resetState = function resetState() {
  var activeState, j, len, ref;
  ref = this._state.slice();

  for (j = 0, len = ref.length; j < len; j++) {
    activeState = ref[j];
    this.state(activeState, false);
  }

  return this;
};

var pipeState = function pipeState(targetEl) {
  var activeState, j, len, ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      this._statePipeTarget = targetEl;
      ref = this._state;

      for (j = 0, len = ref.length; j < len; j++) {
        activeState = ref[j];
        targetEl.state(activeState, true);
      }
    }
  } else if (targetEl === false) {
    delete this._statePipeTarget;
  }

  return this;
};

var _applyRegisteredStyle = function _applyRegisteredStyle(targetStyle, superiorStates, includeBase, skipFns) {
  var className, entry, j, k, len, len1, ref, ref1, superiorStyles;

  if (targetStyle) {
    ref = targetStyle.className;

    for (j = 0, len = ref.length; j < len; j++) {
      className = ref[j];
      this.addClass(className);
    }

    if (targetStyle.fns.length && !skipFns) {
      if (superiorStates) {
        superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
      }

      ref1 = targetStyle.fns;

      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];

        if (!(superiorStyles && superiorStyles[entry[0]])) {
          this.style(entry[0], entry[1]);
        }
      }
    }
  }
};

var _removeRegisteredStyle = function _removeRegisteredStyle(targetStyle, superiorStates, includeBase) {
  var className, entry, j, k, len, len1, ref, ref1, resetValue, superiorStyles;
  ref = targetStyle.className;

  for (j = 0, len = ref.length; j < len; j++) {
    className = ref[j];
    this.removeClass(className);
  }

  if (targetStyle.fns.length) {
    if (superiorStates) {
      superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
    }

    ref1 = targetStyle.fns;

    for (k = 0, len1 = ref1.length; k < len1; k++) {
      entry = ref1[k];
      resetValue = superiorStyles && superiorStyles[entry[0]] || null;
      this.style(entry[0], resetValue);
    }
  }
};

var _turnStyleON = function _turnStyleON(targetState, activeStates) {
  var j, len, sharedStates, skipFns, stateChain;
  skipFns = this.options.styleAfterInsert && !this._inserted;

  if (this._styles[targetState]) {
    this._applyRegisteredStyle(this._styles[targetState], this._getSuperiorStates(targetState, activeStates), false, skipFns);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];

      if (!includes$1(this._stateShared, stateChain.string)) {
        this._stateShared.push(stateChain.string);
      }

      this._applyRegisteredStyle(this._styles[stateChain.string], null, null, skipFns);
    }
  }
};

var _turnStyleOFF = function _turnStyleOFF(targetState, activeStates) {
  var activeSharedStates, j, len, sharedStates, stateChain, targetStyle;

  if (this._styles[targetState]) {
    this._removeRegisteredStyle(this._styles[targetState], activeStates, true);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    if (sharedStates.length === 0) {
      return;
    }

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];
      removeItem(this._stateShared, stateChain.string);
      targetStyle = this._styles[stateChain.string];

      if (targetStyle.fns.length && this._stateShared.length && !activeSharedStates) {
        activeSharedStates = this._stateShared.filter(function (state) {
          return !includes$1(state, targetState);
        });
        activeStates = activeStates.concat(activeSharedStates);
      }

      this._removeRegisteredStyle(targetStyle, activeStates, true);
    }
  }
};

var _turnTextON = function _turnTextON(targetState, activeStates) {
  var superiorStates, targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    superiorStates = this._getSuperiorStates(targetState, activeStates);

    if (!superiorStates.length) {
      this.text = targetText;
    }
  }
};

var _turnTextOFF = function _turnTextOFF(targetState, activeStates) {
  var targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    activeStates = activeStates.filter(function (state) {
      return state !== targetState;
    });
    targetText = this._texts[activeStates[activeStates.length - 1]];

    if (targetText == null) {
      targetText = this._texts.base;
    }

    this.text = targetText;
  }
};

var _getActiveStates = function _getActiveStates(stateToExclude) {
  var includeSharedStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var activeStates, j, len, plainStates;

  if (!this._providedStates) {
    return DUMMY_ARRAY;
  }

  activeStates = plainStates = this._state;

  if (stateToExclude) {
    plainStates = [];

    for (j = 0, len = activeStates.length; j < len; j++) {
      state = activeStates[j];

      if (state !== stateToExclude) {
        plainStates.push(state);
      }
    }
  }

  if (!includeSharedStates || !this._providedStatesShared) {
    return plainStates;
  } else {
    return plainStates.concat(this._stateShared);
  }
};

var _getSuperiorStates = function _getSuperiorStates(targetState, activeStates) {
  var candidate, j, len, superior, targetStateIndex;
  targetStateIndex = this._providedStates.indexOf(targetState);

  if (targetStateIndex === this._providedStates.length - 1) {
    return DUMMY_ARRAY;
  }

  superior = [];

  for (j = 0, len = activeStates.length; j < len; j++) {
    candidate = activeStates[j];

    if (this._providedStates.indexOf(candidate) > targetStateIndex) {
      superior.push(candidate);
    }
  }

  return superior;
};

var _getSharedStates = function _getSharedStates(targetState) {
  var activeStates, j, len, ref, sharedStates, stateChain;
  activeStates = this._state;
  sharedStates = [];
  ref = this._providedStatesShared;

  for (j = 0, len = ref.length; j < len; j++) {
    stateChain = ref[j];

    if (stateChain.includes(targetState) && stateChain.isApplicable(targetState, activeStates)) {
      sharedStates.push(stateChain);
    }
  }

  return sharedStates;
};

var _resolveFnStyles = function _resolveFnStyles(states, includeBase) {
  var entry, j, k, len, len1, output, ref;

  if (includeBase) {
    states = ['base'].concat(states);
  }

  output = {};

  for (j = 0, len = states.length; j < len; j++) {
    state = states[j];

    if (this._styles[state] && this._styles[state].fns.length) {
      ref = this._styles[state].fns;

      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        output[entry[0]] = entry[1];
      }
    }
  }

  return output;
};

function state$1(QuickElement) {
  QuickElement.prototype.state = state;
  QuickElement.prototype.toggleState = toggleState;
  QuickElement.prototype.resetState = resetState;
  QuickElement.prototype.pipeState = pipeState;
  QuickElement.prototype._applyRegisteredStyle = _applyRegisteredStyle;
  QuickElement.prototype._removeRegisteredStyle = _removeRegisteredStyle;
  QuickElement.prototype._turnStyleON = _turnStyleON;
  QuickElement.prototype._turnStyleOFF = _turnStyleOFF;
  QuickElement.prototype._turnTextON = _turnTextON;
  QuickElement.prototype._turnTextOFF = _turnTextOFF;
  QuickElement.prototype._getActiveStates = _getActiveStates;
  QuickElement.prototype._getSuperiorStates = _getSuperiorStates;
  QuickElement.prototype._getSharedStates = _getSharedStates;
  return QuickElement.prototype._resolveFnStyles = _resolveFnStyles;
}

var toTemplate = function toTemplate() {
  return _quickdom.template(this);
};

var clone = function clone() {
  var activeState, callback, callbacks, child, elClone, eventName, i, j, k, len, len1, len2, newEl, options, ref, ref1, ref2;
  elClone = this.el.cloneNode(false);
  options = primaryBuilder$1.clone(this.options, {
    existing: elClone
  });
  newEl = new this.constructor(this.type, options);
  ref = this._state;

  for (i = 0, len = ref.length; i < len; i++) {
    activeState = ref[i];
    newEl.state(activeState, true);
  }

  ref1 = this.children;

  for (j = 0, len1 = ref1.length; j < len1; j++) {
    child = ref1[j];
    newEl.append(child.clone());
  }

  ref2 = this._eventCallbacks;

  for (eventName in ref2) {
    callbacks = ref2[eventName];

    for (k = 0, len2 = callbacks.length; k < len2; k++) {
      callback = callbacks[k];
      newEl.on(eventName, callback);
    }
  }

  return newEl;
};

var append = function append(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.push(targetEl);

      this.el.appendChild(targetEl.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var appendTo = function appendTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.append(this);
    }
  }

  return this;
};

var prepend = function prepend(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.unshift(targetEl);

      this.el.insertBefore(targetEl.el, this.el.firstChild);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var prependTo = function prependTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.prepend(this);
    }
  }

  return this;
};

var after = function after(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex + 1, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el.nextSibling);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertAfter = function insertAfter(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.after(this);
    }
  }

  return this;
};

var before = function before(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertBefore = function insertBefore(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.before(this);
    }
  }

  return this;
};

var detach = function detach() {
  var ref;

  if ((ref = this.parent) != null) {
    ref._removeChild(this);
  }

  return this;
};

var remove = function remove() {
  var eventName;
  this.detach();
  this.resetState();

  if (this._eventCallbacks) {
    for (eventName in this._eventCallbacks) {
      this._eventCallbacks[eventName].length = 0;
    }
  }

  return this;
};

var empty = function empty() {
  var child, i, len, ref;
  ref = this.children.slice();

  for (i = 0, len = ref.length; i < len; i++) {
    child = ref[i];

    this._removeChild(child);
  }

  return this;
};

var wrap = function wrap(targetEl) {
  var currentParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);
    currentParent = this.parent;

    if (IS$1.quickDomEl(targetEl) && targetEl !== this && targetEl !== this.parent) {
      if (currentParent) {
        currentParent._removeChild(this, !targetEl.parent ? targetEl : void 0);
      }

      targetEl.append(this);
    }
  }

  return this;
};

var unwrap = function unwrap() {
  var grandParent, parent, parentChildren, parentSibling;
  parent = this.parent;

  if (parent) {
    parentChildren = _quickdom.batch(parent.children);
    parentSibling = parent.next;
    grandParent = parent.parent;

    if (grandParent) {
      parent.detach();

      if (parentSibling) {
        parentChildren.insertBefore(parentSibling);
      } else {
        parentChildren.appendTo(grandParent);
      }
    }
  }

  return this;
};

var replace = function replace(targetEl) {
  var ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      targetEl.detach();

      if ((ref = this.parent) != null) {
        ref._removeChild(this, targetEl);
      }

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var hasClass = function hasClass(target) {
  return includes$1(this.classList, target);
};

var addClass = function addClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex === -1) {
    classList.push(target);
    this.className = classList.length > 1 ? classList.join(' ') : classList[0];
  }

  return this;
};

var removeClass = function removeClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex !== -1) {
    classList.splice(targetIndex, 1);
    this.className = classList.length ? classList.join(' ') : '';
  }

  return this;
};

var toggleClass = function toggleClass(target) {
  if (this.hasClass(target)) {
    this.removeClass(target);
  } else {
    this.addClass(target);
  }

  return this;
};

var setRef = function setRef(target) {
  this.ref = this.options.ref = target;
  this.attr('data-ref', target);
  return this;
};

var _refreshParent = function _refreshParent() {
  return this.parent;
};

var _removeChild = function _removeChild(targetChild, replacementChild) {
  var indexOfChild;
  indexOfChild = this.children.indexOf(targetChild);

  if (indexOfChild !== -1) {
    if (replacementChild) {
      this.el.replaceChild(replacementChild.el, targetChild.el);

      this._children.splice(indexOfChild, 1, replacementChild);
    } else {
      this.el.removeChild(targetChild.el);

      this._children.splice(indexOfChild, 1);
    }
  }

  return this;
};

function manipulation(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'html': {
      get: function get() {
        return this.el.innerHTML;
      },
      set: function set(newValue) {
        return this.el.innerHTML = newValue;
      }
    },
    'text': {
      get: function get() {
        return this.el.textContent;
      },
      set: function set(newValue) {
        return this.el.textContent = newValue;
      }
    },
    'className': {
      get: function get() {
        if (this.svg) {
          return this.attr('class') || '';
        } else {
          return this.raw.className;
        }
      },
      set: function set(newValue) {
        if (this.svg) {
          return this.attr('class', newValue);
        } else {
          return this.raw.className = newValue;
        }
      }
    },
    'classList': {
      get: function get() {
        var list;
        list = this.className.split(/\s+/);

        if (list[list.length - 1] === '') {
          list.pop();
        }

        if (list[0] === '') {
          list.shift();
        }

        return list;
      }
    }
  });
  QuickElement.prototype.toTemplate = toTemplate;
  QuickElement.prototype.clone = clone;
  QuickElement.prototype.append = append;
  QuickElement.prototype.appendTo = appendTo;
  QuickElement.prototype.prepend = prepend;
  QuickElement.prototype.prependTo = prependTo;
  QuickElement.prototype.after = after;
  QuickElement.prototype.insertAfter = insertAfter;
  QuickElement.prototype.before = before;
  QuickElement.prototype.insertBefore = insertBefore;
  QuickElement.prototype.detach = detach;
  QuickElement.prototype.remove = remove;
  QuickElement.prototype.empty = empty;
  QuickElement.prototype.wrap = wrap;
  QuickElement.prototype.unwrap = unwrap;
  QuickElement.prototype.replace = replace;
  QuickElement.prototype.hasClass = hasClass;
  QuickElement.prototype.addClass = addClass;
  QuickElement.prototype.removeClass = removeClass;
  QuickElement.prototype.toggleClass = toggleClass;
  QuickElement.prototype.setRef = setRef;
  QuickElement.prototype._refreshParent = _refreshParent;
  return QuickElement.prototype._removeChild = _removeChild;
}

var updateOptions = function updateOptions(options) {
  if (IS$1.object(options)) {
    this.options = options;

    this._normalizeOptions();

    this._applyOptions(this.options);
  }

  return this;
};

var updateStateStyles = function updateStateStyles(styles) {
  var i, len, parsed, state, updatedStates;

  if (IS$1.objectPlain(styles)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseStyles(styles));

    if (parsed._styles) {
      updatedStates = Object.keys(parsed._styles);

      for (i = 0, len = updatedStates.length; i < len; i++) {
        state = updatedStates[i];

        if (this.state(state) || state === 'base') {
          this._applyRegisteredStyle(this._styles[state], this._getActiveStates(state), false);
        }
      }
    }
  }

  return this;
};

var updateStateTexts = function updateStateTexts(texts) {
  var parsed;

  if (IS$1.objectPlain(texts)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseTexts(texts));
  }

  return this;
};

var applyData = function applyData(data, passThrough) {
  var child, computers, defaults, i, j, key, keys, len, len1, ref;

  if (this.options.passDataToChildren && this._children.length && (passThrough != null ? passThrough : passThrough = true)) {
    ref = this._children;

    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      child.applyData(data);
    }
  }

  if (computers = this.options.computers) {
    defaults = this.options.defaults;
    keys = Object.keys(computers);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];

      if (this.options.invokeComputersOnce) {
        if (this._invokedComputers[key]) {
          continue;
        }

        this._invokedComputers[key] = 1;
      }

      if (data && data.hasOwnProperty(key)) {
        this._runComputer(key, data[key], data);
      } else if (defaults && defaults.hasOwnProperty(key)) {
        this._runComputer(key, defaults[key], data);
      }
    }
  }

  return this;
};

var _runComputer = function _runComputer(computer, arg, data) {
  return this.options.computers[computer].call(this, arg, data);
};

function application(QuickElement) {
  QuickElement.prototype.updateOptions = updateOptions;
  QuickElement.prototype.updateStateStyles = updateStateStyles;
  QuickElement.prototype.updateStateTexts = updateStateTexts;
  QuickElement.prototype.applyData = applyData;
  return QuickElement.prototype._runComputer = _runComputer;
}

var attr = function attr(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el.getAttribute(target);
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.attr(key, target[key]);
      }
    }
  } else if (newValue === null) {
    return this.el.removeAttribute(target);
  } else {
    this.el.setAttribute(target, newValue);
  }

  return this;
};

var prop = function prop(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el[target];
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.prop(key, target[key]);
      }
    }
  } else {
    this.el[target] = newValue;
  }

  return this;
};

function attributesAndProperties(QuickElement) {
  QuickElement.prototype.attr = attr;
  return QuickElement.prototype.prop = prop;
}

var QuickElement$1, svgNamespace;
svgNamespace = 'http://www.w3.org/2000/svg';

var QuickElement$2 = QuickElement$1 = function () {
  var QuickElement = /*#__PURE__*/function () {
    function QuickElement(type, options) {
      _classCallCheck$1(this, QuickElement);

      this.type = type;
      this.options = options;
      QuickElement.count++;

      if (this.type[0] === '*') {
        this.svg = true;
      }

      this.el = this.options.existing || (this.type === 'text' ? document.createTextNode(typeof this.options.text === 'string' ? this.options.text : '') : this.svg ? document.createElementNS(svgNamespace, this.type.slice(1)) : document.createElement(this.type));

      if (this.type === 'text') {
        this.append = this.prepend = this.attr = function () {};
      } // @_texts = {} # defined conditionally


      this._parent = null;
      this._styles = {};
      this._state = [];
      this._children = []; // @_providedStates = []				# defined conditionally
      // @_providedStatesShared = []		# defined conditionally
      // @_eventCallbacks = {__refs:{}}	# defined conditionally

      this._normalizeOptions();

      this._applyOptions();

      this._attachStateEvents();

      this._proxyParent();

      if (this.options.existing) {
        this._refreshParent();
      }

      this.el._quickElement = this;
    }

    _createClass$1(QuickElement, [{
      key: "toJSON",
      value: function toJSON() {
        var child, children, i, len, output;
        output = [this.type, primaryBuilder$1.clone.keys(element)(this.options)];
        children = this.children;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          output.push(child.toJSON());
        }

        return output;
      }
    }]);

    return QuickElement;
  }();

  QuickElement.count = 0;
  return QuickElement;
}.call(undefined);
/* istanbul ignore next */


if (QuickElement$1.name == null) {
  QuickElement$1.name = 'QuickElement';
}

init$1(QuickElement$1);
aliases(QuickElement$1);
traversing(QuickElement$1);
events(QuickElement$1);
state$1(QuickElement$1);
style$1(QuickElement$1);
manipulation(QuickElement$1);
application(QuickElement$1);
attributesAndProperties(QuickElement$1);
var schema = {
  type: 'div',
  ref: void 0,
  options: {},
  children: []
};

var matchesSchema = function matchesSchema(object) {
  return typeof object.type !== 'undefined' || typeof object.ref !== 'undefined' || typeof object.options !== 'undefined' || typeof object.children !== 'undefined';
};

var PARSE_ERROR_PREFIX, parseTree;
PARSE_ERROR_PREFIX = 'Template Parse Error: expected';

var parseTree$1 = parseTree = function parseTree(tree, parseChildren) {
  var output;

  switch (false) {
    case !IS$1.array(tree):
      output = {};

      if (!IS$1.string(tree[0])) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " string for 'type', got '").concat(String(tree[0]), "'"));
      } else {
        output.type = tree[0];
      }

      if (tree.length > 1 && !IS$1.object(tree[1]) && tree[1] !== null) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " object for 'options', got '").concat(String(tree[1]), "'"));
      } else {
        output.options = tree[1] ? primaryBuilder$1.deep.clone(tree[1]) : schema.options;

        if (tree[1]) {
          output.ref = tree[1].id || tree[1].ref;
        }
      }

      output.children = tree.slice(2);

      if (parseChildren === false) {
        if (tree.length === 3 && IS$1.objectPlain(tree[2]) && !IS$1.template(tree[2])) {
          output.children = tree[2];
        }
      } else {
        output.children = output.children.map(quickdom.template);
      }

      return output;

    case !(IS$1.string(tree) || IS$1.domText(tree)):
      return {
        type: 'text',
        options: {
          text: tree.textContent || tree
        },
        children: schema.children
      };

    case !IS$1.domEl(tree):
      return {
        type: tree.nodeName.toLowerCase(),
        ref: tree.id,
        options: primaryBuilder$1.clone.keys(template)(tree),
        children: schema.children.map.call(tree.childNodes, quickdom.template)
      };

    case !IS$1.quickDomEl(tree):
      return {
        type: tree.type,
        ref: tree.ref,
        options: primaryBuilder$1.clone.deep.notKeys(['relatedInstance', 'related'])(tree.options),
        children: tree.children.map(quickdom.template)
      };

    case !IS$1.template(tree):
      return tree;

    default:
      throw new Error("".concat(PARSE_ERROR_PREFIX, " (array || string || domEl || quickDomEl || template), got ").concat(String(tree)));
  }
};

var NOT_DEEP_KEYS, NOT_KEYS, _extendByRef, extendTemplate;

NOT_DEEP_KEYS = ['relatedInstance', 'related', 'data'];
NOT_KEYS = ['children', '_childRefs'];

var extendTemplate$1 = extendTemplate = function extendTemplate(currentOpts, newOpts, globalOpts) {
  var currentChild, currentChildren, globalOptsTransform, index, maxLength, needsTemplateWrap, newChild, newChildProcessed, newChildren, noChanges, output, ref, remainingNewChildren;

  if (globalOpts) {
    globalOptsTransform = {
      options: function options(opts) {
        return primaryBuilder$1(opts, globalOpts);
      }
    };
  }

  if (IS$1.array(newOpts)) {
    newOpts = parseTree$1(newOpts, false);
  } else if (newOpts && !matchesSchema(newOpts)) {
    newOpts = {
      options: newOpts
    };
  }

  output = primaryBuilder$1.deep.nullDeletes.notKeys(NOT_KEYS).notDeep(NOT_DEEP_KEYS).transform(globalOptsTransform).clone(currentOpts, newOpts);
  currentChildren = currentOpts.children;
  newChildren = (newOpts != null ? newOpts.children : void 0) || [];
  output.children = [];
  /* istanbul ignore next */

  if (IS$1.array(newChildren)) {
    maxLength = Math.max(currentChildren.length, newChildren.length);
    index = -1;

    while (++index !== maxLength) {
      needsTemplateWrap = noChanges = false;
      currentChild = currentChildren[index];
      newChild = newChildren[index];

      newChildProcessed = function () {
        switch (false) {
          case !IS$1.template(newChild):
            return newChild;

          case !IS$1.array(newChild):
            return needsTemplateWrap = parseTree$1(newChild);

          case !IS$1.string(newChild):
            return needsTemplateWrap = {
              type: 'text',
              options: {
                text: newChild
              }
            };

          case !(!newChild && !globalOpts):
            return noChanges = true;

          default:
            return needsTemplateWrap = newChild || true;
        }
      }();

      if (noChanges) {
        newChildProcessed = currentChild;
      } else if (needsTemplateWrap) {
        newChildProcessed = currentChild ? currentChild.extend(newChildProcessed, globalOpts) : new QuickTemplate$1(primaryBuilder$1.clone(schema, newChildProcessed));
      }

      output.children.push(newChildProcessed);
    }
  } else if (IS$1.object(newChildren)) {
    newChildren = primaryBuilder$1.allowNull.clone(newChildren);
    output.children = _extendByRef(newChildren, currentChildren, globalOpts);
    remainingNewChildren = newChildren;

    for (ref in remainingNewChildren) {
      newChild = remainingNewChildren[ref];
      newChildProcessed = IS$1.objectPlain(newChild) && !IS$1.template(newChild) ? newChild : parseTree$1(newChild);
      output.children.push(new QuickTemplate$1(newChildProcessed));
      delete remainingNewChildren[ref];
    }
  }

  return output;
};

_extendByRef = function extendByRef(newChildrenRefs, currentChildren, globalOpts) {
  var currentChild, i, len, newChild, newChildProcessed, output;

  if (!currentChildren.length) {
    return currentChildren;
  } else {
    output = [];

    for (i = 0, len = currentChildren.length; i < len; i++) {
      currentChild = currentChildren[i];
      newChild = newChildrenRefs[currentChild.ref];

      if (newChild) {
        newChildProcessed = currentChild.extend(newChild, globalOpts);
        delete newChildrenRefs[currentChild.ref];
      } else if (newChild === null) {
        delete newChildrenRefs[currentChild.ref];
        continue;
      } else {
        newChildProcessed = function () {
          switch (false) {
            case !globalOpts:
              return currentChild.extend(null, globalOpts);

            case !Object.keys(newChildrenRefs).length:
              return currentChild.extend();

            default:
              return currentChild;
          }
        }();
      }

      newChildProcessed.children = _extendByRef(newChildrenRefs, newChildProcessed.children);
      output.push(newChildProcessed);
    }

    return output;
  }
};

var QuickTemplate;

var QuickTemplate$1 = QuickTemplate = /*#__PURE__*/function () {
  function QuickTemplate(config, isTree) {
    _classCallCheck$1(this, QuickTemplate);

    if (IS$1.template(config)) {
      return config;
    }

    config = isTree ? parseTree$1(config) : config;
    primaryBuilder$1(this, config);
  }

  _createClass$1(QuickTemplate, [{
    key: "extend",
    value: function extend(newValues, globalOpts) {
      return new QuickTemplate(extendTemplate$1(this, newValues, globalOpts));
    }
  }, {
    key: "spawn",
    value: function spawn(newValues, globalOpts, data) {
      var child, childData, children, element, i, len, options, type;

      if (newValues && newValues.data) {
        data = newValues.data;

        if (Object.keys(newValues).length === 1) {
          newValues = null;
        }
      }

      if (newValues || globalOpts) {
        var _extendTemplate = extendTemplate$1(this, newValues, globalOpts);

        options = _extendTemplate.options;
        children = _extendTemplate.children;
        type = _extendTemplate.type;
      } else {
        options = this.options;
        children = this.children;
        type = this.type;
        options = primaryBuilder$1.clone(options);
      }

      element = _quickdom.create([type, options]);

      if (children) {
        childData = options.passDataToChildren ? data || options.data : void 0;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          element.append(child.spawn(null, null, childData));
        }
      }

      element._postCreation(data);

      return element;
    }
  }]);

  return QuickTemplate;
}();
/* istanbul ignore next */


if (QuickTemplate.name == null) {
  QuickTemplate.name = 'QuickTemplate';
}

Object.defineProperty(QuickTemplate.prototype, 'child', {
  get: function get() {
    return this._childRefs || _getChildRefs(this);
  }
});

_quickdom.template = function (tree) {
  return new QuickTemplate(tree, true);
};

_quickdom.isTemplate = function (target) {
  return IS$1.template(target);
};

var QuickBatch;

var QuickBatch$1 = QuickBatch = /*#__PURE__*/function () {
  function QuickBatch(elements, returnResults1) {
    _classCallCheck$1(this, QuickBatch);

    this.returnResults = returnResults1;
    this.elements = elements.map(function (el) {
      return _quickdom(el);
    });
  }

  _createClass$1(QuickBatch, [{
    key: "reverse",
    value: function reverse() {
      this.elements = this.elements.reverse();
      return this;
    }
  }, {
    key: "return",
    value: function _return(returnNext) {
      if (returnNext) {
        this.returnResults = true;
        return this;
      } else {
        return this.lastResults;
      }
    }
  }]);

  return QuickBatch;
}();
/* istanbul ignore next */


if (QuickBatch.name == null) {
  QuickBatch.name = 'QuickBatch';
}

Object.keys(QuickElement$2.prototype).concat('css', 'replaceWith', 'html', 'text').forEach(function (method) {
  return QuickBatch.prototype[method] = function (newValue) {
    var element, results;

    results = this.lastResults = function () {
      var i, len, ref, results1;
      ref = this.elements;
      results1 = [];

      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];

        if (method === 'html' || method === 'text') {
          if (newValue) {
            results1.push(element[method] = newValue);
          } else {
            results1.push(element[method]);
          }
        } else {
          var _element;

          results1.push((_element = element)[method].apply(_element, arguments));
        }
      }

      return results1;
    }.apply(this, arguments);

    if (this.returnResults) {
      return results;
    } else {
      return this;
    }
  };
});

_quickdom.batch = function (elements, returnResults) {
  if (!IS$1.iterable(elements)) {
    throw new Error("Batch: expected an iterable, got ".concat(String(elements)));
  }

  return new QuickBatch(elements, returnResults);
};

var version$2 = "1.0.94";
var SHORTCUTS, i, len, shortcut;
SHORTCUTS = ['link:a', 'anchor:a', 'a', 'text', 'div', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'footer', 'section', 'button', 'br', 'ul', 'ol', 'li', 'fieldset', 'input', 'textarea', 'select', 'option', 'form', 'frame', 'hr', 'iframe', 'img', 'picture', 'main', 'nav', 'meta', 'object', 'pre', 'style', 'table', 'tbody', 'th', 'tr', 'td', 'tfoot', // 'template'
'video'];

for (i = 0, len = SHORTCUTS.length; i < len; i++) {
  shortcut = SHORTCUTS[i];

  (function (shortcut) {
    var prop, split, type;
    prop = type = shortcut;

    if (includes$1(shortcut, ':')) {
      split = shortcut.split(':');
      prop = split[0];
      type = split[1];
    }

    return _quickdom[prop] = function () {
      return _quickdom.apply(void 0, [type].concat(Array.prototype.slice.call(arguments)));
    };
  })(shortcut);
}

init(QuickElement$2, QuickWindow$2);
_quickdom.QuickElement = QuickElement$2;
_quickdom.QuickTemplate = QuickTemplate$1;
_quickdom.QuickWindow = QuickWindow$2;
_quickdom.QuickBatch = QuickBatch$1;
_quickdom.version = version$2;
_quickdom.CSS = index;
var quickdom = _quickdom; // export {quickdom as default, QuickElement, QuickTemplate, QuickWindow, QuickBatch}
var pFinally = (promise, onFinally) => {
  onFinally = onFinally || (() => {});

  return promise.then(val => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => val), err => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => {
    throw err;
  }));
};class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TimeoutError';
  }

}

var pTimeout = (promise, ms, fallback) => new Promise((resolve, reject) => {
  if (typeof ms !== 'number' && ms >= 0) {
    throw new TypeError('Expected `ms` to be a positive number');
  }

  const timer = setTimeout(() => {
    if (typeof fallback === 'function') {
      resolve(fallback());
      return;
    }

    const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${ms} milliseconds`;
    const err = fallback instanceof Error ? fallback : new TimeoutError(message);
    reject(err);
  }, ms);
  pFinally(promise.then(resolve, reject), () => {
    clearTimeout(timer);
  });
});

var TimeoutError_1 = TimeoutError;
pTimeout.TimeoutError = TimeoutError_1;var pEvent = (emitter, event, opts) => {
  let cancel;
  const ret = new Promise((resolve, reject) => {
    if (typeof opts === 'function') {
      opts = {
        filter: opts
      };
    }

    opts = Object.assign({
      rejectionEvents: ['error'],
      multiArgs: false
    }, opts);
    let addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    let removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;

    if (!addListener || !removeListener) {
      throw new TypeError('Emitter is not compatible');
    }

    addListener = addListener.bind(emitter);
    removeListener = removeListener.bind(emitter);

    const resolveHandler = function (value) {
      if (opts.multiArgs) {
        value = [].slice.apply(arguments);
      }

      if (opts.filter && !opts.filter(value)) {
        return;
      }

      cancel();
      resolve(value);
    };

    const rejectHandler = function (reason) {
      cancel();

      if (opts.multiArgs) {
        reject([].slice.apply(arguments));
      } else {
        reject(reason);
      }
    };

    cancel = () => {
      removeListener(event, resolveHandler);

      for (const rejectionEvent of opts.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };

    addListener(event, resolveHandler);

    for (const rejectionEvent of opts.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
  });
  ret.cancel = cancel;

  if (typeof opts.timeout === 'number') {
    return pTimeout(ret, opts.timeout);
  }

  return ret;
};function createEndBreak(value) {
  var instance = Object.create(Error.prototype);
  instance.value = value;
  instance.__isEndBreak = true;
  return instance;
}

var promiseBreak = function (val) {
  var err = createEndBreak(val);
  throw err;
};

var end = function (err) {
  if (err.__isEndBreak) {
    return err.value;
  }

  throw err;
};
promiseBreak.end = end;var detectAnimationEndHelper = function (type) {
  var types;

  if (type && ('transition' === type || 'trans' === type)) {
    types = {
      'OTransition': 'oTransitionEnd',
      'WebkitTransition': 'webkitTransitionEnd',
      'MozTransition': 'transitionend',
      'transition': 'transitionend'
    };
  } else {
    // animation is default
    types = {
      'OAnimation': 'oAnimationEnd',
      'WebkitAnimation': 'webkitAnimationEnd',
      'MozAnimation': 'animationend',
      'animation': 'animationend'
    };
  }

  var elem = document.createElement('fake');
  return Object.keys(types).reduce(function (prev, trans) {
    return undefined !== elem.style[trans] ? types[trans] : prev;
  }, '');
};var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}var eventLite = createCommonjsModule(function (module) {
  /**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   */
  function EventLite() {
    if (!(this instanceof EventLite)) return new EventLite();
  }

  (function (EventLite) {
    // export the class for node.js
    module.exports = EventLite; // property name to hold listeners

    var LISTENERS = "listeners"; // methods to export

    var methods = {
      on: on,
      once: once,
      off: off,
      emit: emit
    }; // mixin to self

    mixin(EventLite.prototype); // export mixin function

    EventLite.mixin = mixin;
    /**
     * Import on(), once(), off() and emit() methods into target object.
     *
     * @function EventLite.mixin
     * @param target {Prototype}
     */

    function mixin(target) {
      for (var key in methods) {
        target[key] = methods[key];
      }

      return target;
    }
    /**
     * Add an event listener.
     *
     * @function EventLite.prototype.on
     * @param type {string}
     * @param func {Function}
     * @returns {EventLite} Self for method chaining
     */


    function on(type, func) {
      getListeners(this, type).push(func);
      return this;
    }
    /**
     * Add one-time event listener.
     *
     * @function EventLite.prototype.once
     * @param type {string}
     * @param func {Function}
     * @returns {EventLite} Self for method chaining
     */


    function once(type, func) {
      var that = this;
      wrap.originalListener = func;
      getListeners(that, type).push(wrap);
      return that;

      function wrap() {
        off.call(that, type, wrap);
        func.apply(this, arguments);
      }
    }
    /**
     * Remove an event listener.
     *
     * @function EventLite.prototype.off
     * @param [type] {string}
     * @param [func] {Function}
     * @returns {EventLite} Self for method chaining
     */


    function off(type, func) {
      var that = this;
      var listners;

      if (!arguments.length) {
        delete that[LISTENERS];
      } else if (!func) {
        listners = that[LISTENERS];

        if (listners) {
          delete listners[type];
          if (!Object.keys(listners).length) return off.call(that);
        }
      } else {
        listners = getListeners(that, type, true);

        if (listners) {
          listners = listners.filter(ne);
          if (!listners.length) return off.call(that, type);
          that[LISTENERS][type] = listners;
        }
      }

      return that;

      function ne(test) {
        return test !== func && test.originalListener !== func;
      }
    }
    /**
     * Dispatch (trigger) an event.
     *
     * @function EventLite.prototype.emit
     * @param type {string}
     * @param [value] {*}
     * @returns {boolean} True when a listener received the event
     */


    function emit(type, value) {
      var that = this;
      var listeners = getListeners(that, type, true);
      if (!listeners) return false;
      var arglen = arguments.length;

      if (arglen === 1) {
        listeners.forEach(zeroarg);
      } else if (arglen === 2) {
        listeners.forEach(onearg);
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        listeners.forEach(moreargs);
      }

      return !!listeners.length;

      function zeroarg(func) {
        func.call(that);
      }

      function onearg(func) {
        func.call(that, value);
      }

      function moreargs(func) {
        func.apply(that, args);
      }
    }
    /**
     * @ignore
     */


    function getListeners(that, type, readonly) {
      if (readonly && !that[LISTENERS]) return;
      var listeners = that[LISTENERS] || (that[LISTENERS] = {});
      return listeners[type] || (listeners[type] = []);
    }
  })(EventLite);
});var IS$2;
IS$2 = index$1.create('natives');
IS$2.load({
  'domEl': quickdom.isEl,
  'quickEl': quickdom.isQuickEl,
  'template': quickdom.isTemplate
});
var IS$1$1 = IS$2;
var popup = quickdom.template(['div', {
  ref: 'popup',
  style: {
    position: 'absolute',
    zIndex: 1e4,
    top: 0,
    left: 0,
    width: '100vw',
    height: 0,
    minHeight: '100%',
    visibility: 'hidden',
    overflow: 'hidden',
    transition: function (popup) {
      return `all 0.001s linear ${popup.settings.animation + 1}ms`;
    },
    $open: {
      transition: function () {
        return 'all 0.001s linear 0s';
      },
      visibility: 'visible',
      overflow: 'visible',
      height: 'auto'
    }
  }
}]);
var overlay = quickdom.template(['div', {
  ref: 'overlay',
  style: {
    position: 'fixed',
    zIndex: 1,
    left: 0,
    top: 0,
    width: '100vw',
    minHeight: '100vh',
    opacity: 0,
    backgroundColor: function (popup) {
      return popup.settings.overlayColor;
    },
    transition: function (popup) {
      return `opacity ${popup.settings.animation}ms`;
    },
    $open: {
      opacity: 1
    }
  }
}]);
var content = quickdom.template(['div', {
  ref: 'content',
  style: {
    position: 'absolute',
    zIndex: 2,
    boxSizing: 'border-box',
    maxWidth: '100%',
    margin: '0 auto',
    padding: function (popup) {
      return popup.settings.contentPadding;
    },
    opacity: 0,
    transition: function (popup) {
      var duration;
      duration = popup.settings.animation;
      return `transform ${duration}ms, -webkit-transform ${duration}ms, opacity ${duration}ms`;
    },
    $open: {
      opacity: 1,
      _: 0
    },
    $centerPlacement: {
      left: '50%',
      transform: 'translateX(-50%)'
    },
    $topPlacement: {
      top: 0,
      left: '50%',
      transform: 'translateX(-50%) translateY(-100%)',
      $open: {
        transform: 'translateX(-50%) translateY(0)',
        _: 1
      }
    },
    $bottomPlacement: {
      bottom: 0,
      left: '50%',
      transform: 'translateX(-50%) translateY(100%)',
      $open: {
        transform: 'translateX(-50%) translateY(0)',
        _: 2
      }
    }
  },
  computers: {
    placement: function (placement) {
      return this.state(`${placement}Placement`, true);
    },
    content: function (content) {
      if (content) {
        return this.append(content);
      }
    }
  },
  events: {
    'stateChange:visible': function (visible) {
      if (visible && quickdom(this).related.settings.placement === 'center') {
        return quickdom(this).related.alignToCenter();
      }
    }
  }
}]);
var close = quickdom.template(['div', {
  ref: 'close',
  style: {
    position: 'absolute',
    display: function (popup) {
      if (popup.settings.close.show) {
        return 'block';
      } else {
        return 'none';
      }
    },
    top: function (popup) {
      if (popup.settings.close.inside) {
        return popup.settings.close.padding;
      } else {
        return popup.settings.close.size * 2.5 * -1;
      }
    },
    right: function (popup) {
      if (popup.settings.close.inside) {
        return popup.settings.close.padding;
      } else {
        return 0;
      }
    },
    width: function (popup) {
      return popup.settings.close.size;
    },
    height: function (popup) {
      return popup.settings.close.size;
    },
    color: function (popup) {
      return popup.settings.close.color;
    }
  }
}, ['*svg', {
  attrs: {
    viewBox: "0 0 492 492"
  },
  style: {
    width: '100%',
    height: '100%'
  }
}, ['*path', {
  attrs: {
    d: 'M300.2 246L484.1 62c5.1-5.1 7.9-11.8 7.9-19 0-7.2-2.8-14-7.9-19L468 7.9c-5.1-5.1-11.8-7.9-19-7.9 -7.2 0-14 2.8-19 7.9L246 191.8 62 7.9c-5.1-5.1-11.8-7.9-19-7.9 -7.2 0-14 2.8-19 7.9L7.9 24c-10.5 10.5-10.5 27.6 0 38.1L191.8 246 7.9 430c-5.1 5.1-7.9 11.8-7.9 19 0 7.2 2.8 14 7.9 19l16.1 16.1c5.1 5.1 11.8 7.9 19 7.9 7.2 0 14-2.8 19-7.9l184-184 184 184c5.1 5.1 11.8 7.9 19 7.9h0c7.2 0 14-2.8 19-7.9l16.1-16.1c5.1-5.1 7.9-11.8 7.9-19 0-7.2-2.8-14-7.9-19L300.2 246z'
  },
  style: {
    fill: function (popup) {
      return popup.settings.close.color;
    }
  }
}]]]);
var bodyWrapper = quickdom.template(['div', {
  id: 'bodyWrapper',
  passStateToChildren: false,
  style: {
    $open: {
      position: 'fixed',
      width: '100%',
      top: '0'
    }
  }
}]);
var html = quickdom.template(['div', {
  computers: {
    html: function (html) {
      return this.html = html;
    }
  }
}]);
var templates = /*#__PURE__*/Object.freeze({
  __proto__: null,
  popup: popup,
  overlay: overlay,
  content: content,
  close: close,
  bodyWrapper: bodyWrapper,
  html: html
});

var extendSettings = function (defaults, settings) {
  return primaryBuilder$1.filter({
    placement: IS$1$1.string,
    template: IS$1$1.objectPlain,
    condition: IS$1$1.function,
    animation: IS$1$1.number,
    overlayColor: IS$1$1.string,
    open: IS$1$1.objectPlain,
    close: IS$1$1.objectPlain,
    triggers: IS$1$1.objectPlain
  }).clone.deep.notDeep('content')(defaults, settings);
};

var scheduleScrollReset = function (scheduleNext) {
  return setTimeout(function () {
    window.scroll(0, 0);

    if (scheduleNext) {
      return setTimeout(function () {
        return scheduleScrollReset();
      }, scheduleNext);
    }
  });
};

var transitionEnd = function () {
  return detectAnimationEndHelper('transition');
};

var scrollOffset = function () {
  return window.scrollY - documentOffset();
};

var documentOffset = function () {
  var ref;
  return (((ref = document.body.getBoundingClientRect()) != null ? ref.top : void 0) || 0) + window.scrollY;
};

var visibilityApiKeys = function () {
  switch (false) {
    case !IS$1$1.defined(document.hidden):
      return {
        hidden: 'hidden',
        visibilitychange: 'visibilitychange'
      };

    case !IS$1$1.defined(document.msHidden):
      return {
        hidden: 'msHidden',
        visibilitychange: 'msvisibilitychange'
      };

    case !IS$1$1.defined(document.webkitHidden):
      return {
        hidden: 'webkitHidden',
        visibilitychange: 'webkitvisibilitychange'
      };

    default:
      return {};
  }
};

var ref;
var isIE = document.all && !window.atob;
var isIE11 = window.navigator.msPointerEnabled;
var isEdge = /Edge/.test(((ref = window.navigator) != null ? ref.userAgent : void 0) || '');
var Popup, body;
body = quickdom(document.body);

Popup = function () {
  class Popup extends eventLite {
    static wrapBody() {
      var bodyChildren, child, i, len, ref1;

      if (!((ref1 = this.bodyWrapper) != null ? ref1.parent : void 0)) {
        this.bodyWrapper = bodyWrapper.spawn();
        bodyChildren = body.children.slice();
        this.bodyWrapper.prependTo(body);

        for (i = 0, len = bodyChildren.length; i < len; i++) {
          child = bodyChildren[i];
          this.bodyWrapper.append(child);
        }
      }
    }

    static unwrapBody() {
      var bodyChildren, child, i, len;

      if (this.bodyWrapper) {
        bodyChildren = this.bodyWrapper.children.slice();

        for (i = 0, len = bodyChildren.length; i < len; i++) {
          child = bodyChildren[i];
          body.append(child);
        }

        this.bodyWrapper.remove();
        return this.bodyWrapper = null;
      }
    }

    static destroyAll() {
      var i, instance, instances, len;
      instances = this.instances.slice();

      for (i = 0, len = instances.length; i < len; i++) {
        instance = instances[i];
        instance.destroy();
      }

      return this.unwrapBody();
    }

    constructor(settings, defaults, template1) {
      super();
      this.template = template1;
      this.settings = extendSettings(defaults, settings);
      this.id = Math.round(Math.random() * 1e5).toString(16);
      this.state = {
        open: false,
        destroyed: false,
        offset: 0,
        count: 0
      };

      if (this.settings.content) {
        this.content = quickdom(this.settings.content);
      }

      Popup.instances.push(this);
      Popup.wrapBody();

      this._createElements();

      this._attachBindings();

      if (this.settings.template && typeof this.settings.template === 'object') {
        this._applyTemplate();
      }

      this.el.prependTo(body);

      if (this.settings.open) {
        this.open();
      }
    }

    _createElements() {
      var close, config, content, data, overlay;
      data = {
        data: {
          content: this.content,
          placement: this.settings.placement
        }
      };
      config = {
        relatedInstance: this
      };
      this.el = this.template.popup.spawn(data, config);
      overlay = this.template.overlay.spawn(data, config).appendTo(this.el);
      content = this.template.content.spawn(data, config).appendTo(this.el);

      if (this.settings.close.show) {
        return close = this.template.close.spawn(data, config).appendTo(content);
      }
    }

    _applyTemplate() {
      var custom, ref;
      custom = this.settings.template;

      for (ref in this.el.child) {
        if (custom[ref]) {
          this.el.child[ref].updateOptions(custom[ref]);
        }
      }
    }

    _attachBindings() {
      var close, hidden, ref1, ref2, visibilitychange;
      close = this.close.bind(this);
      this.el.child.overlay.on('mouseup touchend', close);

      if ((ref1 = this.el.child.close) != null) {
        ref1.on('mouseup touchend', close);
      }

      if (this.settings.placement === 'center') {
        quickdom(window).on(`resize.${this.id}`, () => {
          if (this.state.open) {
            return this.alignToCenter();
          }
        });
      }

      if (this.settings.triggers.close.esc) {
        quickdom(document).on(`keyup.${this.id}`, event => {
          if (event.keyCode === 27 && this.state.open) {
            event.stopPropagation();
            event.preventDefault();
            return this.close();
          }
        });
      }

      if (this.settings.triggers.open.visibility) {
        ({
          visibilitychange,
          hidden
        } = visibilityApiKeys());
        quickdom(document).on(`${visibilitychange}.${this.id}`, () => {
          if (document[hidden]) {
            return this.open('visibility');
          }
        });
      }

      if (this.settings.triggers.open.exitIntent) {
        quickdom(document).on(`mouseout.${this.id}`, event => {
          var base, threshold;
          base = isIE || isIE11 || isEdge ? 110 : 0;
          threshold = this.settings.yThreshold + base;

          if (event.clientY <= threshold) {
            return this.open('exitIntent');
          }
        });
      }

      if (this.settings.triggers.open.navigation && ((ref2 = window.history) != null ? ref2.pushState : void 0)) {
        window.history.replaceState({
          id: 'quickpopup-origin'
        }, '', '');
        window.history.pushState({
          id: 'quickpopup'
        }, '', '');
        return quickdom(window).on(`popstate.${this.id}`, event => {
          if (event.state.state.id === 'quickpopup-origin' && this.open('navigation')) ;else {
            return window.history.back();
          }
        });
      }
    }

    _detachBindings() {
      var hidden, ref1, visibilitychange;
      this.el.child.overlay.off();

      if ((ref1 = this.el.child.close) != null) {
        ref1.off();
      }

      ({
        visibilitychange,
        hidden
      } = visibilityApiKeys());

      if (this.settings.placement === 'center') {
        quickdom(window).off(`resize.${this.id}`);
      }

      if (this.settings.triggers.open.navigation) {
        quickdom(window).off(`popstate.${this.id}`);
      }

      if (this.settings.triggers.open.exitIntent) {
        quickdom(document).off(`mouseout.${this.id}`);
      }

      if (this.settings.triggers.open.visibility) {
        quickdom(document).off(`${visibilitychange}.${this.id}`);
      }

      if (this.settings.triggers.close.esc) {
        return quickdom(document).off(`keyup.${this.id}`);
      }
    }

    _throwDestroyed() {
      throw new Error("invalid attempt to operate a destroyed popup instance");
    }

    setContent(target) {
      this.content = function () {
        switch (false) {
          case !IS$1$1.quickEl(target):
            return target;

          case !IS$1$1.domEl(target):
            return quickdom(target);

          case !IS$1$1.template(target):
            return target.spawn();

          case !IS$1$1.string(target):
            return html.spawn({
              data: {
                html: target
              }
            });

          default:
            throw new Error('invalid target provided to Popup::setContent()');
        }
      }();

      if (this.el.child.content.children.length) {
        return this.el.child.content.children[1].replaceWith(this.content);
      } else {
        return this.el.child.content.append(this.content);
      }
    }

    alignToCenter() {
      var contentHeight, offset, windowHeight;
      contentHeight = this.el.child.content.raw.clientHeight;
      windowHeight = window.innerHeight;

      if (contentHeight >= windowHeight - 80) {
        offset = window.innerWidth > 736 ? 100 : 60;
      } else {
        offset = (windowHeight - contentHeight) / 2;
      }

      return this.el.child.content.style('margin', `${offset}px auto`);
    }

    open(triggerName) {
      return Promise.resolve().then(() => {
        if (this.state.destroyed) {
          this._throwDestroyed();
        }

        if (this.state.open || Popup.hasOpen && !this.settings.forceOpen || ++this.state.count >= this.settings.openLimit || window.innerWidth < this.settings.triggers.open.minWidth || this.settings.condition && !this.settings.condition()) {
          return promiseBreak();
        }
      }).then(() => {
        var openPopups;
        this.emit('beforeopen', triggerName);

        if (!Popup.hasOpen) {
          return this.state.offset = scrollOffset();
        } else {
          openPopups = Popup.instances.filter(popup => {
            return popup !== this && popup.state.open;
          });
          return Promise.all(openPopups.map(popup => {
            this.state.offset = popup.state.offset;
            return popup.close(true);
          }));
        }
      }).then(() => {
        var promise;
        scheduleScrollReset(5);
        Popup.bodyWrapper.state('open', true);
        Popup.bodyWrapper.style('top', this.state.offset * -1);
        this.el.state('open', true);
        this.state.open = Popup.hasOpen = true;

        if (this.settings.placement === 'center') {
          this.alignToCenter();
        }

        this.emit('open', triggerName);

        if (!this.settings.animation || !Popup.transitionEnd) {
          return this.emit('finishopen');
        } else {
          promise = pEvent(this, 'finishopen');
          this.el.child.content.on(Popup.transitionEnd, event => {
            if (event.target === this.el.child.content.raw) {
              this.emit('finishopen');
              return this.el.child.content.off(Popup.transitionEnd);
            }
          });
          return promise;
        }
      }).catch(promiseBreak.end).then(() => {
        return this;
      });
    }

    close(preventReset) {
      return Promise.resolve().then(() => {
        if (!this.state.open) {
          return promiseBreak();
        }
      }).then(() => {
        var promise;
        this.emit('beforeclose');

        if (preventReset !== true) {
          setTimeout(() => {
            var ref1, ref2;

            if (!Popup.hasOpen) {
              if ((ref1 = Popup.bodyWrapper) != null) {
                ref1.state('open', false);
              }

              if ((ref2 = Popup.bodyWrapper) != null) {
                ref2.style('top', null);
              }

              return window.scroll(0, this.state.offset + documentOffset());
            }
          });
          Popup.hasOpen = false;
        }

        this.el.state('open', false);
        this.state.open = false;
        this.emit('close');

        if (!this.settings.animation || !Popup.transitionEnd) {
          return this.emit('finishclose');
        } else {
          promise = pEvent(this, 'finishclose');
          this.el.child.content.on(Popup.transitionEnd, event => {
            if (event.target === this.el.child.content.raw) {
              this.emit('finishclose');
              return this.el.child.content.off(Popup.transitionEnd);
            }
          });
          return promise;
        }
      }).catch(promiseBreak.end).then(() => {
        return this;
      });
    }

    destroy() {
      if (this.settings.destroyed) {
        this._throwDestroyed();
      }

      this.close();

      this._detachBindings();

      this.el.remove();
      Popup.instances.splice(Popup.instances.indexOf(this), 1);
      return true;
    }

  }

  Popup.instances = [];
  Popup.hasOpen = false;
  Popup.bodyWrapper = null;
  Popup.transitionEnd = transitionEnd();
  return Popup;
}.call(undefined);

var Popup$1 = Popup;
var defaults = {
  placement: 'center',
  open: false,
  forceOpen: false,
  template: null,
  condition: null,
  animation: 300,
  contentPadding: 0,
  yThreshold: 15,
  openLimit: 2e308,
  overlayColor: 'rgba(0,0,0,0.88)',
  close: {
    show: false,
    padding: 20,
    inside: false,
    size: 22
  },
  triggers: {
    open: {
      navigation: false,
      visibility: false,
      exitIntent: false
    },
    close: {
      esc: true
    }
  }
};
var version$3 = "1.0.1";
var newBuilder$1, quickpopup;

newBuilder$1 = function (defaults, templates) {
  var builder;

  builder = function (arg) {
    switch (false) {
      case arguments.length !== 0:
        return new Popup$1(null, defaults, templates);

      case typeof arg !== 'string':
        return new Popup$1({
          content: html.spawn({
            data: {
              html: arg
            }
          })
        }, defaults, templates);

      case !quickdom.isEl(arg):
      case !quickdom.isQuickEl(arg):
        return new Popup$1({
          content: arg
        }, defaults, templates);

      case !quickdom.isTemplate(arg):
        return new Popup$1({
          content: arg.spawn()
        }, defaults, templates);

      case !(arg && typeof arg === 'object'):
        return new Popup$1(arg, defaults, templates);

      default:
        throw new Error('invalid argument provided to QuickPopup');
    }
  };

  builder.config = function (newSettings, newTemplates) {
    var name, outputSettings, outputTemplates, template;

    if (!IS$1$1.object(newSettings)) {
      throw new Error(`QuickPopup Config: invalid config object provided ${String(newSettings)}`);
    }

    outputSettings = primaryBuilder$1.clone.deep(defaults, newSettings);

    if (!IS$1$1.object(newTemplates)) {
      outputTemplates = templates;
    } else {
      outputTemplates = Object.create(null);

      for (name in templates) {
        template = templates[name];

        if (newTemplates[name]) {
          outputTemplates[name] = template.extend(newTemplates[name]);
        } else {
          outputTemplates[name] = template;
        }
      }
    }

    return newBuilder$1(outputSettings, outputTemplates);
  };

  builder.wrapBody = function () {
    return Popup$1.wrapBody();
  };

  builder.unwrapBody = function () {
    return Popup$1.unwrapBody();
  };

  builder.destroyAll = function () {
    return Popup$1.destroyAll();
  };

  builder.version = version$3;
  builder.defaults = defaults;
  builder.templates = templates;
  return builder;
};

quickpopup = newBuilder$1(defaults, templates);
var quickpopup$1 = quickpopup;var restartSandbox = function () {
  if (window.sandbox) {
    window.sandbox.remove();
  }

  window.sandbox = quickdom.div({
    id: 'sandbox',
    style: {
      border: '1px solid',
      padding: 20,
      boxSizing: 'border-box'
    }
  });
  return window.sandbox.appendTo(document.body);
};var version$4 = "1.0.1";/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function exclude() {
  var excludes = [].slice.call(arguments);

  function excludeProps(res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude() {
    var args = [].slice.call(arguments),
        i = 0,
        res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
}
/*!
 * Primary Exports
 */

var assertionError = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError(message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),
      props = extend(_props || {}); // default values

  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false; // copy from properties

  for (var key in props) {
    this[key] = props[key];
  } // capture stack trace


  ssf = ssf || AssertionError;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch (e) {
      this.stack = e.stack;
    }
  }
}
/*!
 * Inherit from Error.prototype
 */


AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack'),
      props = extend({
    name: this.name
  }, this); // include stack if exists and not turned off

  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  } // The `in` operator does not work with primitives.


  return name in Object(obj);
}
/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */


function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;

    if (mArr) {
      parsed = {
        i: parseFloat(mArr[1])
      };
    } else {
      parsed = {
        p: value.replace(/\\([.\[\]])/g, '$1')
      };
    }

    return parsed;
  });
}
/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */


function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];

    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }

  return res;
}
/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */


function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null; // Here we iterate through every part of the path

  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i]; // If it's the last part of the path, we set the 'propName' value with the property name

    if (i === pathDepth - 1) {
      propName = typeof part.p === 'undefined' ? part.i : part.p; // Now we set the property with the name held by 'propName' on object with the desired val

      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1]; // Here we set the name of the property which will be defined

      propName = typeof part.p === 'undefined' ? part.i : part.p; // Here we decide if this property will be an array or a new object

      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}
/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */


function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */


function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}
/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */


function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

var pathval = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue
};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */
var flag = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));

  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

var test$1 = function test(obj, args) {
  var negate = flag(obj, 'negate'),
      expr = args[0];
  return negate ? !expr : expr;
};var typeDetect = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
     module.exports = factory() ;
  })(commonjsGlobal, function () {
    /* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var promiseExists = typeof Promise === 'function';
    /* eslint-disable no-undef */

    var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

    var symbolExists = typeof Symbol !== 'undefined';
    var mapExists = typeof Map !== 'undefined';
    var setExists = typeof Set !== 'undefined';
    var weakMapExists = typeof WeakMap !== 'undefined';
    var weakSetExists = typeof WeakSet !== 'undefined';
    var dataViewExists = typeof DataView !== 'undefined';
    var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
    var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
    var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
    var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
    var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
    var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
    var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
    var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
    var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
    var toStringLeftSliceLength = 8;
    var toStringRightSliceLength = -1;
    /**
     * ### typeOf (obj)
     *
     * Uses `Object.prototype.toString` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */

    function typeDetect(obj) {
      /* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
       */
      var typeofObj = typeof obj;

      if (typeofObj !== 'object') {
        return typeofObj;
      }
      /* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
       */


      if (obj === null) {
        return 'null';
      }
      /* ! Spec Conformance
       * Test: `Object.prototype.toString.call(window)``
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: `Object.prototype.toString.call(this)``
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */


      if (obj === globalObject) {
        return 'global';
      }
      /* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
       */


      if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
        return 'Array';
      } // Not caching existence of `window` and related properties due to potential
      // for `window` to be unset before tests in quasi-browser environments.


      if (typeof window === 'object' && window !== null) {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The `Location` interface
         * Test: `Object.prototype.toString.call(window.location)``
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */
        if (typeof window.location === 'object' && obj === window.location) {
          return 'Location';
        }
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The `Document` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: `Object.prototype.toString.call(document)``
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */


        if (typeof window.document === 'object' && obj === window.document) {
          return 'Document';
        }

        if (typeof window.navigator === 'object') {
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */
          if (typeof window.navigator.mimeTypes === 'object' && obj === window.navigator.mimeTypes) {
            return 'MimeTypeArray';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: `Object.prototype.toString.call(navigator.plugins)``
           *  - IE <=10 === "[object MSPluginsCollection]"
           */


          if (typeof window.navigator.plugins === 'object' && obj === window.navigator.plugins) {
            return 'PluginArray';
          }
        }

        if ((typeof window.HTMLElement === 'function' || typeof window.HTMLElement === 'object') && obj instanceof window.HTMLElement) {
          /* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
          * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
          *  - IE <=10 === "[object HTMLBlockElement]"
          */
          if (obj.tagName === 'BLOCKQUOTE') {
            return 'HTMLQuoteElement';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */


          if (obj.tagName === 'TD') {
            return 'HTMLTableDataCellElement';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */


          if (obj.tagName === 'TH') {
            return 'HTMLTableHeaderCellElement';
          }
        }
      }
      /* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
      */


      var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

      if (typeof stringTag === 'string') {
        return stringTag;
      }

      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }

      return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
    }

    return typeDetect;
  });
});/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var expectTypes = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');
  flagMsg = flagMsg ? flagMsg + ': ' : '';
  obj = flag(obj, 'object');
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort(); // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'

  var str = types.map(function (t, index) {
    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');
  var objType = typeDetect(obj).toLowerCase();

  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new assertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi);
  }
};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */
var getActual = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;

function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';

  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);

    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

var getFuncName_1 = getFuncName;/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */
var getProperties = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);

  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */
var getEnumerableProperties = function getEnumerableProperties(object) {
  var result = [];

  for (var name in object) {
    result.push(name);
  }

  return result;
};var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
};var inspect_1 = createCommonjsModule(function (module, exports) {
  // This is (almost) directly from Node.js utils
  // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
  module.exports = inspect;
  /**
   * ### .inspect(obj, [showHidden], [depth], [colors])
   *
   * Echoes the value of a value. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
   *    properties of objects. Default is false.
   * @param {Number} depth Depth in which to descend in object. Default is 2.
   * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
   *    output. Default is false (no coloring).
   * @namespace Utils
   * @name inspect
   */

  function inspect(obj, showHidden, depth, colors) {
    var ctx = {
      showHidden: showHidden,
      seen: [],
      stylize: function (str) {
        return str;
      }
    };
    return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);
  } // Returns true if object is a DOM element.


  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object && typeof object === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string';
    }
  };

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (typeof ret !== 'string') {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // If this is a DOM element, try to get the outer HTML.


    if (isDOMElement(value)) {
      if ('outerHTML' in value) {
        return value.outerHTML; // This value does not have an outerHTML attribute,
        //   it could still be an XML element
      } else {
        // Attempt to serialize it
        try {
          if (document.xmlVersion) {
            var xmlSerializer = new XMLSerializer();
            return xmlSerializer.serializeToString(value);
          } else {
            // Firefox 11- do not support outerHTML
            //   It does, however, support innerHTML
            //   Use the following to render the element
            var ns = "http://www.w3.org/1999/xhtml";
            var container = document.createElementNS(ns, '_');
            container.appendChild(value.cloneNode(false));
            var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
            container.innerHTML = '';
            return html;
          }
        } catch (err) {// This could be a non-native DOM implementation,
          //   continue with the normal flow:
          //   printing the element as if it is an object.
        }
      }
    } // Look up the keys of the object.


    var visibleKeys = getEnumerableProperties(value);
    var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
    var name, nameSuffix; // Some type of object without properties can be shortcut.
    // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
    // a `stack` plus `description` property; ignore those for consistency.

    if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {
      if (typeof value === 'function') {
        name = getFuncName_1(value);
        nameSuffix = name ? ': ' + name : '';
        return ctx.stylize('[Function' + nameSuffix + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        typedArray = false,
        braces = ['{', '}'];

    if (isTypedArray(value)) {
      typedArray = true;
      braces = ['[', ']'];
    } // Make Array say that they are Array


    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (typeof value === 'function') {
      name = getFuncName_1(value);
      nameSuffix = name ? ': ' + name : '';
      base = ' [Function' + nameSuffix + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      return formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else if (typedArray) {
      return formatTypedArray(value);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');

      case 'number':
        if (value === 0 && 1 / value === -Infinity) {
          return ctx.stylize('-0', 'number');
        }

        return ctx.stylize('' + value, 'number');

      case 'boolean':
        return ctx.stylize('' + value, 'boolean');

      case 'symbol':
        return ctx.stylize(value.toString(), 'symbol');
    } // For some reason typeof null is "object", so special case here.


    if (value === null) {
      return ctx.stylize('null', 'null');
    }
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (Object.prototype.hasOwnProperty.call(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatTypedArray(value) {
    var str = '[ ';

    for (var i = 0; i < value.length; ++i) {
      if (str.length >= config.truncateThreshold - 7) {
        str += '...';
        break;
      }

      str += value[i] + ', ';
    }

    str += ' ]'; // Removing trailing `, ` if the array was not truncated

    if (str.indexOf(',  ]') !== -1) {
      str = str.replace(',  ]', ' ]');
    }

    return str;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name;
    var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
    var str;

    if (propDescriptor) {
      if (propDescriptor.get) {
        if (propDescriptor.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (propDescriptor.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
    }

    if (visibleKeys.indexOf(key) < 0) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(value[key]) < 0) {
        if (recurseTimes === null) {
          str = formatValue(ctx, value[key], null);
        } else {
          str = formatValue(ctx, value[key], recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (typeof name === 'undefined') {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      return prev + cur.length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }

  function isTypedArray(ar) {
    // Unfortunately there's no way to check if an object is a TypedArray
    // We have to check if it's one of these types
    return typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar));
  }

  function isArray(ar) {
    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
  }

  function isRegExp(re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  }

  function isDate(d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return typeof e === 'object' && objectToString(e) === '[object Error]';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

var objDisplay = function objDisplay(obj) {
  var str = inspect_1(obj),
      type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj),
          kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

var getMessage = function getMessage(obj, args) {
  var negate = flag(obj, 'negate'),
      val = flag(obj, 'object'),
      expected = args[3],
      actual = getActual(obj, args),
      msg = negate ? args[2] : args[1],
      flagMsg = flag(obj, 'message');
  if (typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg.replace(/#\{this\}/g, function () {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ': ' + msg : msg;
};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */
var transferFlags = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message') {
      object.__flags[flag] = flags[flag];
    }
  }
};/* globals Symbol: false, Uint8Array: false, WeakMap: false */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/

function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql = deepEqual;
var MemoizeMap_1 = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect(leftHandOperand);

  if (leftHandType !== typeDetect(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}
deepEql.MemoizeMap = MemoizeMap_1;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

var isProxyEnabled = function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined';
};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

var addProperty = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: function propertyGetter() {
      // Setting the `ssfi` flag to `propertyGetter` causes this function to
      // be the starting point for removing implementation frames from the
      // stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', propertyGetter);
      }

      var result = getter.call(this);
      if (result !== undefined) return result;
      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

var addLengthGuard = function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
};/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

var proxify = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        } // If the property is reasonably close to an existing Chai property,
        // suggest that property to the user. Only suggest properties with a
        // distance less than 4.


        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function (prop) {
          if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(property, prop, suggestionDistance);

            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });

        if (suggestion !== null) {
          throw Error('Invalid Chai property: ' + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      } // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.


      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};
/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */


function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }

  var memo = []; // `memo` is a two-dimensional array containing distances.
  // memo[i][j] is the distance between strA.slice(0, i) and
  // strB.slice(0, j).

  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }

  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }

  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);

    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }

      memo[i][j] = Math.min(memo[i - 1][j] + 1, memo[i][j - 1] + 1, memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1));
    }
  }

  return memo[strA.length][strB.length];
}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

var addMethod = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined) return result;
    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwrites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

var overwriteProperty = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
      _super = function () {};

  if (_get && 'function' === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: function overwritingPropertyGetter() {
      // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
      // function to be the starting point for removing implementation frames
      // from the stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', overwritingPropertyGetter);
      } // Setting the `lockSsfi` flag to `true` prevents the overwritten
      // assertion from changing the `ssfi` flag. By this point, the `ssfi`
      // flag is already set to the correct starting point for this assertion.


      var origLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      var result = getter(_super).call(this);
      flag(this, 'lockSsfi', origLockSsfi);

      if (result !== undefined) {
        return result;
      }

      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwrites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

var overwriteMethod = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
      _super = function () {
    throw new Error(name + ' is not a function');
  };

  if (_method && 'function' === typeof _method) _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    } // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.


    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/*!
 * Module variables
 */
// Check whether `Object.setPrototypeOf` is supported

var canSetPrototype = typeof Object.setPrototypeOf === 'function'; // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.

var testFn = function () {};

var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name); // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.

  if (typeof propDesc !== 'object') return true;
  return !propDesc.configurable;
}); // Cache `Function` properties

var call = Function.prototype.call,
    apply = Function.prototype.apply;
/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () {};
  }

  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  }; // save the methods so we can overwrite them later, if we need to.

  if (!ctx.__methods) {
    ctx.__methods = {};
  }

  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);

      var chainableMethodWrapper = function () {
        // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
        // function to be the starting point for removing implementation
        // frames from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then this assertion is being
        // invoked from inside of another assertion. In this case, the `ssfi`
        // flag has already been set by the outer assertion.
        //
        // Note that overwriting a chainable method merely replaces the saved
        // methods in `ctx.__methods` instead of completely replacing the
        // overwritten assertion. Therefore, an overwriting assertion won't
        // set the `ssfi` or `lockSsfi` flags.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', chainableMethodWrapper);
        }

        var result = chainableBehavior.method.apply(this, arguments);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai$1.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(chainableMethodWrapper, name, true); // Use `Object.setPrototypeOf` if available

      if (canSetPrototype) {
        // Inherit all properties from the object by replacing the `Function` prototype
        var prototype = Object.create(this); // Restore the `call` and `apply` methods from `Function`

        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } // Otherwise, redefine all properties (slow!)
      else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    },
    configurable: true
  });
};/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwrites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;

  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;

  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

var compareByInspect = function compareByInspect(a, b) {
  return inspect_1(a) < inspect_1(b) ? -1 : 1;
};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */
var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}
/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */


function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}
/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */


function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;

  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}
/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */


var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;

function getFunctionName(constructorFn) {
  var name = '';

  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch$1);

    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}
/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */


function getConstructorName(errorLike) {
  var constructorName = errorLike;

  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}
/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */


function getMessage$1(errorLike) {
  var msg = '';

  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

var checkError = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage$1,
  getConstructorName: getConstructorName
};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */
function isNaN$1(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
} // If ECMAScript 6's Number.isNaN is present, prefer that.


var _isNaN = Number.isNaN || isNaN$1;/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */

/*!
 * test utility
 */

var test$2 = test$1;
/*!
 * type utility
 */

var type = typeDetect;
/*!
 * expectTypes utility
 */

var expectTypes$1 = expectTypes;
/*!
 * message utility
 */

var getMessage$2 = getMessage;
/*!
 * actual utility
 */

var getActual$1 = getActual;
/*!
 * Inspect util
 */

var inspect = inspect_1;
/*!
 * Object Display util
 */

var objDisplay$1 = objDisplay;
/*!
 * Flag utility
 */

var flag$1 = flag;
/*!
 * Flag transferring utility
 */

var transferFlags$1 = transferFlags;
/*!
 * Deep equal utility
 */

var eql = deepEql;
/*!
 * Deep path info
 */

var getPathInfo$1 = pathval.getPathInfo;
/*!
 * Check if a property exists
 */

var hasProperty$1 = pathval.hasProperty;
/*!
 * Function name
 */

var getName = getFuncName_1;
/*!
 * add Property
 */

var addProperty$1 = addProperty;
/*!
 * add Method
 */

var addMethod$1 = addMethod;
/*!
 * overwrite Property
 */

var overwriteProperty$1 = overwriteProperty;
/*!
 * overwrite Method
 */

var overwriteMethod$1 = overwriteMethod;
/*!
 * Add a chainable method
 */

var addChainableMethod$1 = addChainableMethod;
/*!
 * Overwrite chainable method
 */

var overwriteChainableMethod$1 = overwriteChainableMethod;
/*!
 * Compare by inspect method
 */

var compareByInspect$1 = compareByInspect;
/*!
 * Get own enumerable property symbols method
 */

var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;
/*!
 * Get own enumerable properties method
 */

var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;
/*!
 * Checks error against a given set of criteria
 */

var checkError$1 = checkError;
/*!
 * Proxify util
 */

var proxify$1 = proxify;
/*!
 * addLengthGuard util
 */

var addLengthGuard$1 = addLengthGuard;
/*!
 * isProxyEnabled helper
 */

var isProxyEnabled$1 = isProxyEnabled;
/*!
 * isNaN method
 */

var isNaN$2 = _isNaN;
var utils = {
  test: test$2,
  type: type,
  expectTypes: expectTypes$1,
  getMessage: getMessage$2,
  getActual: getActual$1,
  inspect: inspect,
  objDisplay: objDisplay$1,
  flag: flag$1,
  transferFlags: transferFlags$1,
  eql: eql,
  getPathInfo: getPathInfo$1,
  hasProperty: hasProperty$1,
  getName: getName,
  addProperty: addProperty$1,
  addMethod: addMethod$1,
  overwriteProperty: overwriteProperty$1,
  overwriteMethod: overwriteMethod$1,
  addChainableMethod: addChainableMethod$1,
  overwriteChainableMethod: overwriteChainableMethod$1,
  compareByInspect: compareByInspect$1,
  getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
  getOwnEnumerableProperties: getOwnEnumerableProperties$1,
  checkError: checkError$1,
  proxify: proxify$1,
  addLengthGuard: addLengthGuard$1,
  isProxyEnabled: isProxyEnabled$1,
  isNaN: isNaN$2
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assertion = function (_chai, util) {
  /*!
   * Module dependencies.
   */
  var AssertionError = _chai.AssertionError,
      flag = util.flag;
  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion(obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function () {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function (value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });
  Object.defineProperty(Assertion, 'showDiff', {
    get: function () {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function (value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */


  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
        actual: actual,
        expected: expected,
        showDiff: showDiff
      }, config.includeStack ? this.assert : flag(this, 'ssfi'));
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */


  Object.defineProperty(Assertion.prototype, '_obj', {
    get: function () {
      return flag(this, 'object');
    },
    set: function (val) {
      flag(this, 'object', val);
    }
  });
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assertions = function (chai, _) {
  var Assertion = chai.Assertion,
      AssertionError = chai.AssertionError,
      flag = _.flag;
  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does', 'still'].forEach(function (chain) {
    Assertion.addProperty(chain);
  });
  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });
  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });
  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });
  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });
  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });
  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });
  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });
  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an(type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object'),
        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);
  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return _.isNaN(a) && _.isNaN(b) || a === b;
  }

  function includeChainingBehavior() {
    flag(this, 'contains', true);
  }

  function include(val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate'),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi);
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }

        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }

        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi);
        }

        var props = Object.keys(val),
            firstErr = null,
            numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);

          _.transferFlags(this, propAssertion, true);

          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }

            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this); // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.

        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }

        return;
    } // Assert inclusion in collection or substring in a string.


    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
  /**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered `true` in boolean context).
   * However, it's often best to assert that the target is strictly (`===`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
  });
  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? false : true);
  });
  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? true : false);
  });
  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');
  });
  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');
  });
  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN');
  });
  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist');
  });
  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        itemsCount;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;

      case 'map':
      case 'set':
        itemsCount = val.size;
        break;

      case 'weakmap':
      case 'weakset':
        throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);

      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);

        throw new AssertionError(msg.trim(), undefined, ssfi);

      default:
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi);
        }

        itemsCount = Object.keys(val).length;
    }

    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty');
  });
  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments() {
    var obj = flag(this, 'object'),
        type = _.type(obj);

    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);
  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual(val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (flag(this, 'deep')) {
      var prevLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      this.eql(val);
      flag(this, 'lockSsfi', prevLockSsfi);
    } else {
      this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);
  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);
  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount > n, 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n);
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);
  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= n, 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n);
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount < n, 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n);
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);
  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount <= n, 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n);
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `start`, and less
   * than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        startType = _.type(start).toLowerCase(),
        finishType = _.type(finish).toLowerCase(),
        errorMessage,
        shouldThrow = true,
        range = startType === 'date' && finishType === 'date' ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && (startType !== 'date' || finishType !== 'date')) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= start && itemsCount <= finish, 'expected #{this} to have a ' + descriptor + ' within ' + range, 'expected #{this} to not have a ' + descriptor + ' within ' + range);
    } else {
      this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);
    }
  });
  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf(constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi);
      }

      throw err;
    }

    var name = _.getName(constructor);

    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);
  }
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);
  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty(name, val, msg) {
    if (msg) flag(this, 'message', msg);
    var isNested = flag(this, 'nested'),
        isOwn = flag(this, 'own'),
        flagMsg = flag(this, 'message'),
        obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        nameType = typeof name;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    if (isNested) {
      if (nameType !== 'string') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string when using nested syntax', undefined, ssfi);
      }
    } else {
      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string, number, or symbol', undefined, ssfi);
      }
    }

    if (isNested && isOwn) {
      throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi);
    }

    if (obj === null || obj === undefined) {
      throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi);
    }

    var isDeep = flag(this, 'deep'),
        negate = flag(this, 'negate'),
        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
        value = isNested ? pathInfo.value : obj[name];
    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';
    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty = pathInfo.exists;else hasProperty = _.hasProperty(obj, name); // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.

    if (!negate || arguments.length === 1) {
      this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value);
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty(name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);

    if (actualDescriptor && descriptor) {
      this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, true);
    } else {
      this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name));
    }

    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` or `size` is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain() {
    flag(this, 'doLength', true);
  }

  function assertLength(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi'),
        descriptor = 'length',
        itemsCount;

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = obj.size;
        break;

      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        itemsCount = obj.length;
    }

    this.assert(itemsCount == n, 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' of #{act}', n, itemsCount);
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);
  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);
  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');
    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));
  });
  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys(keys) {
    var obj = flag(this, 'object'),
        objType = _.type(obj),
        keysType = _.type(keys),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        str,
        deepStr = '',
        actual,
        ok = true,
        flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = []; // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.

      obj.forEach(function (val, key) {
        actual.push(key);
      });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          break;

        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          keys = Object.keys(keys);
          break;

        default:
          keys = Array.prototype.slice.call(arguments);
      } // Only stringify non-Symbols because Symbols would become "Symbol()"


      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length,
        any = flag(this, 'any'),
        all = flag(this, 'all'),
        expected = keys;

    if (!any && !all) {
      all = true;
    } // Has any


    if (any) {
      ok = expected.some(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    } // Has all


    if (all) {
      ok = expected.every(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    } // Key string


    if (len > 1) {
      keys = keys.map(function (key) {
        return _.inspect(key);
      });
      var last = keys.pop();

      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }

      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    } // Form


    str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include

    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion

    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);
  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;

    try {
      obj();
    } catch (err) {
      caughtErr = err;
    } // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria


    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined; // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub

    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false; // Checking if error was thrown

    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';

      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString());
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);

      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';

      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);

      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr));
        }
      }
    } // If both assertions failed and both should've matched we throw an error


    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    flag(this, 'object', caughtErr);
  }
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);
  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo(method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        itself = flag(this, 'itself'),
        context = 'function' === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);
  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });
  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy(matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? false : true, result);
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);
  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('number');

    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi);
    }

    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo); // Note: Duplicates are ignored if testing for inclusion instead of sameness.

  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function (elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function (elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */


  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');
    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');
    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
  });
  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf(list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');
    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected);
  }

  Assertion.addMethod('oneOf', oneOf);
  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop; // This gets flagged because of the .by(delta) assertion

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);
    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change');
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);
  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);
    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase');
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);
  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);
    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease');
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);
  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);
    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');
    var expression;

    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta);
  }

  Assertion.addMethod('by', assertDelta);
  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
  });
  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
  });
  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
  });
  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function (msg) {
    var obj = flag(this, 'object');
    this.assert(typeof obj === 'number' && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number');
  });
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var expect = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */


  chai.expect.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = undefined;
    }

    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, chai.expect.fail);
  };
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var should = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould() {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }

      return new Assertion(this, null, shouldGetter);
    }

    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } // modify Object.prototype to have `should`


    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    var should = {};
    /**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      if (arguments.length < 2) {
        message = actual;
        actual = undefined;
      }

      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
        actual: actual,
        expected: expected,
        operator: operator
      }, should.fail);
    };
    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */


    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */


    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }; // negation


    should.not = {};
    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */


    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];
    return should;
  }
  chai.should = loadShould;
  chai.Should = loadShould;
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assert = function (chai, util) {
  /*!
   * Chai dependencies.
   */
  var Assertion = chai.Assertion,
      flag = util.flag;
  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(express, errmsg, '[ negation message unavailable ]');
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */


  assert.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      // Comply with Node's fail([message]) interface
      message = actual;
      actual = undefined;
    }

    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, assert.fail);
  };
  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);
    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, true);
  };
  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);
    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, true);
  };
  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */


  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  /**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  /**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  /**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  /**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };
  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };
  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };
  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };
  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };
  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };
  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };
  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };
  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };
  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };
  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };
  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };
  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };
  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };
  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };
  /**
  * ### .isFinite(value, [message])
  *
  * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };
  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };
  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };
  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };
  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };
  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
  };
  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  /**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  /**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
  };
  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
  };
  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
  };
  /**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.ownInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  /**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  /**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  *
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an
  * object while ignoring inherited properties and checking for deep equality.
  *
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.notDeepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
  };
  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
  };
  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
  };
  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
  };
  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
  };
  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
  };
  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
  };
  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
  };
  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
  };
  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
  };
  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
  };
  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
  };
  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
  };
  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
  };
  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
  };
  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` or `size` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
  };
  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
  };
  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
  };
  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
  };
  /**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has all and only all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
  };
  /**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` contains all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has none of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` does not have at least one of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
  };
  /**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
    * instance of `errorLike`.
    * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
    * instance as `errorLike`.
    * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
    * message matching `errMsgMatcher`.
    *
    *     assert.throws(fn, 'Error thrown must have this msg');
    *     assert.throws(fn, /Error thrown must have a msg that matches this/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */


  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };
  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */


  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
  };
  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.operator = function (val, operator, val2, msg) {
    var ok;

    switch (operator) {
      case '==':
        ok = val == val2;
        break;

      case '===':
        ok = val === val2;
        break;

      case '>':
        ok = val > val2;
        break;

      case '>=':
        ok = val >= val2;
        break;

      case '<':
        ok = val < val2;
        break;

      case '<=':
        ok = val <= val2;
        break;

      case '!=':
        ok = val != val2;
        break;

      case '!==':
        ok = val !== val2;
        break;

      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator);
    }

    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));
  };
  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
  };
  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
  };
  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
  };
  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
  };
  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
  };
  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
  };
  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
  };
  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
  };
  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
  };
  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
  };
  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
  };
  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
  };
  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
  };
  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
  };
  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  /**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  /**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
  };
  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
  };
  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
  };
  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */


  assert.ifError = function (val) {
    if (val) {
      throw val;
    }
  };
  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  /*!
   * Aliases.
   */


  (function alias(name, as) {
    assert[as] = assert[name];
    return alias;
  })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty');
};var chai$1 = createCommonjsModule(function (module, exports) {
  /*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var used = [];
  /*!
   * Chai version
   */

  exports.version = '4.2.0';
  /*!
   * Assertion Error
   */

  exports.AssertionError = assertionError;
  /*!
   * Utils for plugins (not exported)
   */

  /**
   * # .use(function)
   *
   * Provides a way to extend the internals of Chai.
   *
   * @param {Function}
   * @returns {this} for chaining
   * @api public
   */

  exports.use = function (fn) {
    if (!~used.indexOf(fn)) {
      fn(exports, utils);
      used.push(fn);
    }

    return exports;
  };
  /*!
   * Utility Functions
   */


  exports.util = utils;
  /*!
   * Configuration
   */

  exports.config = config;
  /*!
   * Primary `Assertion` prototype
   */

  exports.use(assertion);
  /*!
   * Core Assertions
   */

  exports.use(assertions);
  /*!
   * Expect interface
   */

  exports.use(expect);
  /*!
   * Should interface
   */

  exports.use(should);
  /*!
   * Assert interface
   */

  exports.use(assert);
});
var chai_1 = chai$1.version;
var chai_2 = chai$1.AssertionError;
var chai_3 = chai$1.use;
var chai_4 = chai$1.util;
var chai_5 = chai$1.config;var chai$2 = chai$1;var chaiDom = createCommonjsModule(function (module, exports) {
  (function (chaiDom) {
    if (typeof commonjsRequire === 'function' && 'object' === 'object' && 'object' === 'object') {
      module.exports = chaiDom;
    } else {
      chai.use(chaiDom);
    }
  })(function (chai, utils) {
    var flag = utils.flag,
        elToString = function (el) {
      var desc;

      if (isNodeList(el)) {
        if (el.length === 0) return 'empty NodeList';
        desc = Array.prototype.slice.call(el, 0, 5).map(elToString).join(', ');
        return el.length > 5 ? desc + '... (+' + (el.length - 5) + ' more)' : desc;
      }

      if (!isHTMLElement(el)) {
        return String(el);
      }

      desc = el.tagName.toLowerCase();

      if (el.id) {
        desc += '#' + el.id;
      }

      if (el.className) {
        desc += '.' + String(el.className).replace(/\s+/g, '.');
      }

      Array.prototype.forEach.call(el.attributes, function (attr) {
        if (attr.name !== 'class' && attr.name !== 'id') {
          desc += '[' + attr.name + (attr.value ? '="' + attr.value + '"]' : ']');
        }
      });
      return desc;
    },
        attrAssert = function (name, val) {
      var el = flag(this, 'object'),
          actual = el.getAttribute(name);

      if (!flag(this, 'negate') || undefined === val) {
        this.assert(!!el.attributes[name], 'expected ' + elToString(el) + ' to have an attribute #{exp}', 'expected ' + elToString(el) + ' not to have an attribute #{exp}', name);
      }

      if (undefined !== val) {
        this.assert(val === actual, 'expected ' + elToString(el) + ' to have an attribute ' + utils.inspect(name) + ' with the value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have an attribute ' + utils.inspect(name) + ' with the value #{act}', val, actual);
      }

      flag(this, 'object', actual);
    },
        isHTMLElement = function (el) {
      return el.nodeType === 1; // window.Node.ELEMENT_NODE
    },
        isNodeList = function (obj) {
      return Object.prototype.toString.call(obj) === '[object NodeList]';
    };

    utils.elToString = elToString;
    chai.Assertion.addMethod('attr', attrAssert);
    chai.Assertion.addMethod('attribute', attrAssert);
    chai.Assertion.addMethod('class', function (className) {
      var el = flag(this, 'object');
      this.assert(el.classList.contains(className), 'expected ' + elToString(el) + ' to have class #{exp}', 'expected ' + elToString(el) + ' not to have class #{exp}', className);
    });
    chai.Assertion.addMethod('id', function (id) {
      var el = flag(this, 'object');
      this.assert(el.id == id, 'expected ' + elToString(el) + ' to have id #{exp}', 'expected ' + elToString(el) + ' not to have id #{exp}', id);
    });
    chai.Assertion.addMethod('html', function (html) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').innerHTML;

      if (flag(this, 'contains')) {
        this.assert(actual.indexOf(html) >= 0, 'expected #{act} to contain HTML #{exp}', 'expected #{act} not to contain HTML #{exp}', html, actual);
      } else {
        this.assert(actual === html, 'expected ' + elToString(el) + ' to have HTML #{exp}, but the HTML was #{act}', 'expected ' + elToString(el) + ' not to have HTML #{exp}', html, actual);
      }
    });
    chai.Assertion.addChainableMethod('trimmed', null, function () {
      flag(this, 'trim-text', true);
    });
    chai.Assertion.addMethod('text', function (text) {
      var obj = flag(this, 'object'),
          contains = flag(this, 'contains'),
          trim = flag(this, 'trim-text'),
          actual,
          result;

      if (isNodeList(obj)) {
        actual = Array.prototype.map.call(obj, function (el) {
          return trim ? el.textContent.trim() : el.textContent;
        });

        if (Array.isArray(text)) {
          result = contains ? text[flag(this, 'negate') ? 'some' : 'every'](function (t) {
            return Array.prototype.some.call(obj, function (el) {
              return (trim ? el.textContent.trim() : el.textContent) === t;
            });
          }) : utils.eql(actual, text);
          actual = actual.join();
          text = text.join();
        } else {
          actual = actual.join('');
          result = contains ? actual.indexOf(text) >= 0 : actual === text;
        }
      } else {
        actual = trim ? obj.textContent.trim() : obj.textContent;
        result = contains ? actual.indexOf(text) >= 0 : actual === text;
      }

      var objDesc = elToString(obj),
          textMsg = trim ? 'trimmed text' : 'text';

      if (contains) {
        this.assert(result, 'expected ' + objDesc + ' to contain #{exp}, but the ' + textMsg + ' was #{act}', 'expected ' + objDesc + ' not to contain #{exp}, but the ' + textMsg + ' was #{act}', text, actual);
      } else {
        this.assert(result, 'expected ' + objDesc + ' to have ' + textMsg + ' #{exp}, but the ' + textMsg + ' was #{act}', 'expected ' + objDesc + ' not to have ' + textMsg + ' #{exp}', text, actual);
      }
    });
    chai.Assertion.addMethod('value', function (value) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').value;
      this.assert(flag(this, 'object').value === value, 'expected ' + elToString(el) + ' to have value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have value #{exp}', value, actual);
    });
    chai.Assertion.overwriteProperty('exist', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (isNodeList(obj)) {
          this.assert(obj.length > 0, 'expected an empty NodeList to have nodes', 'expected ' + elToString(obj) + ' to not exist');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteProperty('empty', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (isHTMLElement(obj)) {
          this.assert(obj.children.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else if (isNodeList(obj)) {
          this.assert(obj.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('length', function (_super) {
      return function (length) {
        var obj = flag(this, 'object');

        if (isNodeList(obj) || isHTMLElement(obj)) {
          var actualLength = obj.children ? obj.children.length : obj.length;
          this.assert(actualLength === length, 'expected ' + elToString(obj) + ' to have #{exp} children but it had #{act} children', 'expected ' + elToString(obj) + ' to not have #{exp} children', length, actualLength);
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.overwriteMethod('match', function (_super) {
      return function (selector) {
        var obj = flag(this, 'object');

        if (isHTMLElement(obj)) {
          this.assert(obj.matches(selector), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else if (isNodeList(obj)) {
          this.assert(!!obj.length && Array.prototype.every.call(obj, function (el) {
            return el.matches(selector);
          }), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('contain', function (_super) {
      return function (subitem) {
        var obj = flag(this, 'object');

        if (isHTMLElement(obj)) {
          if (typeof subitem === 'string') {
            this.assert(!!obj.querySelector(subitem), 'expected ' + elToString(obj) + ' to contain #{exp}', 'expected ' + elToString(obj) + ' to not contain #{exp}', subitem);
          } else {
            this.assert(obj.contains(subitem), 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem), 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
          }
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.addMethod('descendant', function (subitem) {
      var obj = flag(this, 'object'),
          actual = subitem;

      if (typeof subitem === 'string') {
        actual = obj.querySelector(subitem);
        this.assert(!!actual, 'expected ' + elToString(obj) + ' to have descendant #{exp}', 'expected ' + elToString(obj) + ' to not have descendant #{exp}', subitem);
      } else {
        this.assert(obj.contains(subitem), 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem), 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
      }

      flag(this, 'object', actual);
    });
    chai.Assertion.addMethod('descendants', function (selector) {
      var obj = flag(this, 'object'),
          actual = obj.querySelectorAll(selector);
      this.assert(!!actual.length, 'expected ' + elToString(obj) + ' to have descendants #{exp}', 'expected ' + elToString(obj) + ' to not have descendants #{exp}', selector);
      flag(this, 'object', actual);
    });
    chai.Assertion.addProperty('displayed', function () {
      var el = flag(this, 'object'),
          actual = document.body.contains(el) ? window.getComputedStyle(el).display : el.style.display;
      this.assert(actual !== 'none', 'expected ' + elToString(el) + ' to be displayed, but it was not', 'expected ' + elToString(el) + ' to not be displayed, but it was as ' + actual, actual);
    });
    chai.Assertion.addProperty('visible', function () {
      var el = flag(this, 'object'),
          actual = document.body.contains(el) ? window.getComputedStyle(el).visibility : el.style.visibility;
      this.assert(actual !== 'hidden' && actual !== 'collapse', 'expected ' + elToString(el) + ' to be visible, but it was ' + (actual === 'hidden' ? 'hidden' : 'collapsed'), 'expected ' + elToString(el) + ' to not be visible, but it was', actual);
    });
    chai.Assertion.addMethod('tagName', function (tagName) {
      var el = flag(this, 'object'),
          actual = el.tagName;
      this.assert(actual.toUpperCase() === tagName.toUpperCase(), 'expected ' + elToString(el) + ' to have tagName ' + tagName + ', but it was ' + actual, 'expected ' + elToString(el) + ' to not have tagName ' + tagName + ', but it was ' + actual, actual);
    });
  });
});var sources = chaiStyle;

function chaiStyle(chai, utils) {
  const {
    Assertion
  } = chai;
  const {
    flag
  } = utils;
  Assertion.addMethod('style', function (property, value = '') {
    const element = flag(this, 'object');
    const style = window.getComputedStyle(element);
    value = value.trim();
    const isNonColors = style[property] === 'rgba(0, 0, 0, 0)' // webkit
    || style[property] === 'transparent'; // firefox

    const propertyValue = isNonColors ? '' : style[property];
    const assertion = value ? compareCSSValue(propertyValue, value) : Boolean(propertyValue);
    const elementTag = element.tagName.toLowerCase();
    const throwMessage = `expect ${elementTag} to have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    const throwMessageNegative = `expect ${elementTag} to not have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    this.assert(assertion, throwMessage, throwMessageNegative, value);

    function compareCSSValue(computed, expected) {
      const propertyHifenCase = property.replace(/[A-Z]/g, match => '-' + match.toLowerCase());
      const fake = document.createElement('div');
      fake.style.fontSize = style.fontSize;
      fake.style.setProperty(propertyHifenCase, expected, 'important');
      const iframe = document.createElement('iframe');
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);
      iframe.appendChild(fake);
      const fakeStyle = window.getComputedStyle(fake);
      const value = fakeStyle[property];
      const hasAutoValue = value.includes('auto');
      const reg = new RegExp(escapeRegExp(value).replace(/auto/g, '(\\d+(.\\d+)?px|auto)'));
      const comparisonResult = hasAutoValue ? reg.test(computed) : computed === value;
      document.body.removeChild(iframe);
      return comparisonResult;
    }
  });
} // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js


function escapeRegExp(value) {
  return String(value).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
}var typeDetect$1 = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var getPrototypeOfExists = typeof Object.getPrototypeOf === 'function';
  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var htmlElementExists = typeof HTMLElement !== 'undefined';
  var isArrayExists = typeof Array.isArray === 'function';
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = getPrototypeOfExists && setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = getPrototypeOfExists && mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)
     */


    if (isArrayExists && Array.isArray(obj)) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    if (getPrototypeOfExists) {
      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1 = typeDetect$1.typeDetect;/* globals Symbol: true, Uint8Array: true, WeakMap: true */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */


function FakeMap$1() {
  this.clear();
}

FakeMap$1.prototype = {
  clear: function clearMap() {
    this.keys = [];
    this.values = [];
    return this;
  },
  set: function setMap(key, value) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values[index] = value;
    } else {
      this.keys.push(key);
      this.values.push(value);
    }

    return this;
  },
  get: function getMap(key) {
    return this.values[this.keys.indexOf(key)];
  },
  delete: function deleteMap(key) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values = this.values.slice(0, index).concat(this.values.slice(index + 1));
      this.keys = this.keys.slice(0, index).concat(this.keys.slice(index + 1));
    }

    return this;
  }
};
var MemoizeMap$1 = null;

if (typeof WeakMap === 'function') {
  MemoizeMap$1 = WeakMap;
} else {
  MemoizeMap$1 = FakeMap$1;
}
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/


function memoizeCompare$1(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet$1(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap$1();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql$1 = deepEqual$1;
var MemoizeMap_1$1 = MemoizeMap$1;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual$1(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual$1(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap$1();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare$1(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare$1(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect$1(leftHandOperand);

  if (leftHandType !== typeDetect$1(rightHandOperand)) {
    memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual$1(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual$1(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual$1(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual$1(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual$1(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual$1(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual$1(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual$1(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual$1(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual$1(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual$1(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual$1(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual$1(leftHandOperand, rightHandOperand, options) {
  return iterableEqual$1(getGeneratorEntries$1(leftHandOperand), getGeneratorEntries$1(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction$1(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries$1(target) {
  if (hasIteratorFunction$1(target)) {
    try {
      return getGeneratorEntries$1(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries$1(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys$1(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual$1(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual$1(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual$1(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys$1(leftHandOperand);
  var rightHandKeys = getEnumerableKeys$1(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual$1(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual$1(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries$1(leftHandOperand);
  var rightHandEntries = getIteratorEntries$1(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual$1(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive$1(value) {
  return value === null || typeof value !== 'object';
}
deepEql$1.MemoizeMap = MemoizeMap_1$1;var DEFAULT_TOLERANCE = 1e-6;
/**
 * small utility functions
 */

function isNumber(val) {
  return typeDetect(val) === 'number';
}

function bothNumbers(left, right) {
  return isNumber(right) && isNumber(left);
}

function almostEqual(left, right, tol) {
  return Math.abs(left - right) <= tol;
}
/**
 * Makes a comparator function to be passed to deepEqual.
 * The returned function will return null if both arguments are not numbers,
 * indicating that deepEqual should proceed with other equality checks
 */


function comparator(tolerance) {
  return function (left, right) {
    if (bothNumbers(left, right)) {
      return almostEqual(left, right, tolerance);
    }

    return null;
  };
}
/**
 * Sets global tolerance and returns a function to be passed to chai.use
 * @see http://chaijs.com/guide/plugins/
 */


function chaiAlmost(customTolerance) {
  var standardTolerance = customTolerance || DEFAULT_TOLERANCE;
  return function (chai, utils) {
    var Assertion = chai.Assertion;
    var flag = utils.flag;
    /**
     * Returns a new shallow equality function to override
     * .equal, .equals, .eq that tests 'almost' equality
     * if both values are numbers and a 'tolerance' flag is set.
     * Sends to deep equality check if deep flag is set
     */

    function overrideAssertEqual(_super) {
      return function assertEqual(val, msg) {
        if (msg) flag(this, 'message', msg);
        var deep = flag(this, 'deep');
        var tolerance = flag(this, 'tolerance');

        if (deep) {
          return this.eql(val);
        } else if (tolerance && bothNumbers(val, this._obj)) {
          this.assert(almostEqual(val, this._obj, tolerance), 'expected #{this} to almost equal #{exp}', 'expected #{this} to not almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * Returns a new deep equality function to override
     * .eql, .eqls that tests 'almost' equality if both corresponding
     * values are numbers and tolerance flag is set
     */


    function overrideAssertEql(_super) {
      return function assertEql(val, msg) {
        if (msg) flag(this, 'message', msg);
        var tolerance = flag(this, 'tolerance');

        if (tolerance) {
          this.assert(deepEql$1(val, this._obj, {
            comparator: comparator(tolerance)
          }), 'expected #{this} to deeply almost equal #{exp}', 'expected #{this} to not deeply almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * .almost() method. To be used at the end of the chain like:
     * expect(4).to.not.be.almost(5, 1.5). Simply adds tolerance flag then calls
     * .equal. This will redirect to .eql if deep flag set
     */


    function method(val, toleranceOverride) {
      var tolerance = toleranceOverride || standardTolerance;
      flag(this, 'tolerance', tolerance);
      return this.equal(val);
    }
    /**
     * .almost chainable property to be used like:
     * expect(3.99999999).to.almost.equal(4). Simply adds
     * tolerance flag to be read by equality checking methods
     */


    function chainingBehavior() {
      flag(this, 'tolerance', standardTolerance);
    }

    Assertion.addChainableMethod('almost', method, chainingBehavior);
    Assertion.overwriteMethod('equal', overrideAssertEqual);
    Assertion.overwriteMethod('equals', overrideAssertEqual);
    Assertion.overwriteMethod('eq', overrideAssertEqual);
    Assertion.overwriteMethod('eql', overrideAssertEql);
    Assertion.overwriteMethod('eqls', overrideAssertEql);
  };
}

var chaiAlmost_1 = chaiAlmost;var checkTypes = createCommonjsModule(function (module) {
  /*globals define, module, Symbol */

  /*jshint -W056 */
  (function (globals) {

    var strings, messages, predicates, functions, assert, not, maybe, collections, slice, neginf, posinf, isArray, haveSymbols;
    strings = {
      v: 'value',
      n: 'number',
      s: 'string',
      b: 'boolean',
      o: 'object',
      t: 'type',
      a: 'array',
      al: 'array-like',
      i: 'iterable',
      d: 'date',
      f: 'function',
      l: 'length'
    };
    messages = {};
    predicates = {};
    [{
      n: 'equal',
      f: equal,
      s: 'v'
    }, {
      n: 'undefined',
      f: isUndefined,
      s: 'v'
    }, {
      n: 'null',
      f: isNull,
      s: 'v'
    }, {
      n: 'assigned',
      f: assigned,
      s: 'v'
    }, {
      n: 'primitive',
      f: primitive,
      s: 'v'
    }, {
      n: 'includes',
      f: includes,
      s: 'v'
    }, {
      n: 'zero',
      f: zero
    }, {
      n: 'infinity',
      f: infinity
    }, {
      n: 'number',
      f: number
    }, {
      n: 'integer',
      f: integer
    }, {
      n: 'even',
      f: even
    }, {
      n: 'odd',
      f: odd
    }, {
      n: 'greater',
      f: greater
    }, {
      n: 'less',
      f: less
    }, {
      n: 'between',
      f: between
    }, {
      n: 'greaterOrEqual',
      f: greaterOrEqual
    }, {
      n: 'lessOrEqual',
      f: lessOrEqual
    }, {
      n: 'inRange',
      f: inRange
    }, {
      n: 'positive',
      f: positive
    }, {
      n: 'negative',
      f: negative
    }, {
      n: 'string',
      f: string,
      s: 's'
    }, {
      n: 'emptyString',
      f: emptyString,
      s: 's'
    }, {
      n: 'nonEmptyString',
      f: nonEmptyString,
      s: 's'
    }, {
      n: 'contains',
      f: contains,
      s: 's'
    }, {
      n: 'match',
      f: match,
      s: 's'
    }, {
      n: 'boolean',
      f: boolean,
      s: 'b'
    }, {
      n: 'object',
      f: object,
      s: 'o'
    }, {
      n: 'emptyObject',
      f: emptyObject,
      s: 'o'
    }, {
      n: 'nonEmptyObject',
      f: nonEmptyObject,
      s: 'o'
    }, {
      n: 'instanceStrict',
      f: instanceStrict,
      s: 't'
    }, {
      n: 'instance',
      f: instance,
      s: 't'
    }, {
      n: 'like',
      f: like,
      s: 't'
    }, {
      n: 'array',
      f: array,
      s: 'a'
    }, {
      n: 'emptyArray',
      f: emptyArray,
      s: 'a'
    }, {
      n: 'nonEmptyArray',
      f: nonEmptyArray,
      s: 'a'
    }, {
      n: 'arrayLike',
      f: arrayLike,
      s: 'al'
    }, {
      n: 'iterable',
      f: iterable,
      s: 'i'
    }, {
      n: 'date',
      f: date,
      s: 'd'
    }, {
      n: 'function',
      f: isFunction,
      s: 'f'
    }, {
      n: 'hasLength',
      f: hasLength,
      s: 'l'
    }].map(function (data) {
      var n = data.n;
      messages[n] = 'Invalid ' + strings[data.s || 'n'];
      predicates[n] = data.f;
    });
    functions = {
      apply: apply,
      map: map,
      all: all,
      any: any
    };
    collections = ['array', 'arrayLike', 'iterable', 'object'];
    slice = Array.prototype.slice;
    neginf = Number.NEGATIVE_INFINITY;
    posinf = Number.POSITIVE_INFINITY;
    isArray = Array.isArray;
    haveSymbols = typeof Symbol === 'function';
    functions = mixin(functions, predicates);
    assert = createModifiedPredicates(assertModifier, assertImpl);
    not = createModifiedPredicates(notModifier, notImpl);
    maybe = createModifiedPredicates(maybeModifier, maybeImpl);
    assert.not = createModifiedModifier(assertModifier, not);
    assert.maybe = createModifiedModifier(assertModifier, maybe);
    collections.forEach(createOfPredicates);
    createOfModifiers(assert, assertModifier);
    createOfModifiers(not, notModifier);
    collections.forEach(createMaybeOfModifiers);
    exportFunctions(mixin(functions, {
      assert: assert,
      not: not,
      maybe: maybe
    }));
    /**
     * Public function `equal`.
     *
     * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
     * Returns false otherwise.
     */

    function equal(lhs, rhs) {
      return lhs === rhs;
    }
    /**
     * Public function `undefined`.
     *
     * Returns true if `data` is undefined, false otherwise.
     */


    function isUndefined(data) {
      return data === undefined;
    }
    /**
     * Public function `null`.
     *
     * Returns true if `data` is null, false otherwise.
     */


    function isNull(data) {
      return data === null;
    }
    /**
     * Public function `assigned`.
     *
     * Returns true if `data` is not null or undefined, false otherwise.
     */


    function assigned(data) {
      return data !== undefined && data !== null;
    }
    /**
     * Public function `primitive`.
     *
     * Returns true if `data` is a primitive type, false otherwise.
     */


    function primitive(data) {
      var type;

      switch (data) {
        case null:
        case undefined:
        case false:
        case true:
          return true;
      }

      type = typeof data;
      return type === 'string' || type === 'number' || haveSymbols && type === 'symbol';
    }
    /**
     * Public function `zero`.
     *
     * Returns true if `data` is zero, false otherwise.
     */


    function zero(data) {
      return data === 0;
    }
    /**
     * Public function `infinity`.
     *
     * Returns true if `data` is positive or negative infinity, false otherwise.
     */


    function infinity(data) {
      return data === neginf || data === posinf;
    }
    /**
     * Public function `number`.
     *
     * Returns true if `data` is a number, false otherwise.
     */


    function number(data) {
      return typeof data === 'number' && data > neginf && data < posinf;
    }
    /**
     * Public function `integer`.
     *
     * Returns true if `data` is an integer, false otherwise.
     */


    function integer(data) {
      return typeof data === 'number' && data % 1 === 0;
    }
    /**
     * Public function `even`.
     *
     * Returns true if `data` is an even number, false otherwise.
     */


    function even(data) {
      return typeof data === 'number' && data % 2 === 0;
    }
    /**
     * Public function `odd`.
     *
     * Returns true if `data` is an odd number, false otherwise.
     */


    function odd(data) {
      return integer(data) && data % 2 !== 0;
    }
    /**
     * Public function `greater`.
     *
     * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
     */


    function greater(lhs, rhs) {
      return number(lhs) && lhs > rhs;
    }
    /**
     * Public function `less`.
     *
     * Returns true if `lhs` is a number less than `rhs`, false otherwise.
     */


    function less(lhs, rhs) {
      return number(lhs) && lhs < rhs;
    }
    /**
     * Public function `between`.
     *
     * Returns true if `data` is a number between `x` and `y`, false otherwise.
     */


    function between(data, x, y) {
      if (x < y) {
        return greater(data, x) && data < y;
      }

      return less(data, x) && data > y;
    }
    /**
     * Public function `greaterOrEqual`.
     *
     * Returns true if `lhs` is a number greater than or equal to `rhs`, false
     * otherwise.
     */


    function greaterOrEqual(lhs, rhs) {
      return number(lhs) && lhs >= rhs;
    }
    /**
     * Public function `lessOrEqual`.
     *
     * Returns true if `lhs` is a number less than or equal to `rhs`, false
     * otherwise.
     */


    function lessOrEqual(lhs, rhs) {
      return number(lhs) && lhs <= rhs;
    }
    /**
     * Public function `inRange`.
     *
     * Returns true if `data` is a number in the range `x..y`, false otherwise.
     */


    function inRange(data, x, y) {
      if (x < y) {
        return greaterOrEqual(data, x) && data <= y;
      }

      return lessOrEqual(data, x) && data >= y;
    }
    /**
     * Public function `positive`.
     *
     * Returns true if `data` is a positive number, false otherwise.
     */


    function positive(data) {
      return greater(data, 0);
    }
    /**
     * Public function `negative`.
     *
     * Returns true if `data` is a negative number, false otherwise.
     */


    function negative(data) {
      return less(data, 0);
    }
    /**
     * Public function `string`.
     *
     * Returns true if `data` is a string, false otherwise.
     */


    function string(data) {
      return typeof data === 'string';
    }
    /**
     * Public function `emptyString`.
     *
     * Returns true if `data` is the empty string, false otherwise.
     */


    function emptyString(data) {
      return data === '';
    }
    /**
     * Public function `nonEmptyString`.
     *
     * Returns true if `data` is a non-empty string, false otherwise.
     */


    function nonEmptyString(data) {
      return string(data) && data !== '';
    }
    /**
     * Public function `contains`.
     *
     * Returns true if `data` is a string that contains `substring`, false
     * otherwise.
     */


    function contains(data, substring) {
      return string(data) && data.indexOf(substring) !== -1;
    }
    /**
     * Public function `match`.
     *
     * Returns true if `data` is a string that matches `regex`, false otherwise.
     */


    function match(data, regex) {
      return string(data) && !!data.match(regex);
    }
    /**
     * Public function `boolean`.
     *
     * Returns true if `data` is a boolean value, false otherwise.
     */


    function boolean(data) {
      return data === false || data === true;
    }
    /**
     * Public function `object`.
     *
     * Returns true if `data` is a plain-old JS object, false otherwise.
     */


    function object(data) {
      return Object.prototype.toString.call(data) === '[object Object]';
    }
    /**
     * Public function `emptyObject`.
     *
     * Returns true if `data` is an empty object, false otherwise.
     */


    function emptyObject(data) {
      return object(data) && Object.keys(data).length === 0;
    }
    /**
     * Public function `nonEmptyObject`.
     *
     * Returns true if `data` is a non-empty object, false otherwise.
     */


    function nonEmptyObject(data) {
      return object(data) && Object.keys(data).length > 0;
    }
    /**
     * Public function `instanceStrict`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     */


    function instanceStrict(data, prototype) {
      try {
        return data instanceof prototype;
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `instance`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     * Falls back to testing constructor.name and Object.prototype.toString
     * if the initial instanceof test fails.
     */


    function instance(data, prototype) {
      try {
        return instanceStrict(data, prototype) || data.constructor.name === prototype.name || Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `like`.
     *
     * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
     * of the properties of `archetype` (the 'duck'), false otherwise.
     */


    function like(data, archetype) {
      var name;

      for (name in archetype) {
        if (archetype.hasOwnProperty(name)) {
          if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
            return false;
          }

          if (object(data[name]) && like(data[name], archetype[name]) === false) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * Public function `array`.
     *
     * Returns true if `data` is an array, false otherwise.
     */


    function array(data) {
      return isArray(data);
    }
    /**
     * Public function `emptyArray`.
     *
     * Returns true if `data` is an empty array, false otherwise.
     */


    function emptyArray(data) {
      return array(data) && data.length === 0;
    }
    /**
     * Public function `nonEmptyArray`.
     *
     * Returns true if `data` is a non-empty array, false otherwise.
     */


    function nonEmptyArray(data) {
      return array(data) && greater(data.length, 0);
    }
    /**
     * Public function `arrayLike`.
     *
     * Returns true if `data` is an array-like object, false otherwise.
     */


    function arrayLike(data) {
      return assigned(data) && greaterOrEqual(data.length, 0);
    }
    /**
     * Public function `iterable`.
     *
     * Returns true if `data` is an iterable, false otherwise.
     */


    function iterable(data) {
      if (!haveSymbols) {
        // Fall back to `arrayLike` predicate in pre-ES6 environments.
        return arrayLike(data);
      }

      return assigned(data) && isFunction(data[Symbol.iterator]);
    }
    /**
     * Public function `includes`.
     *
     * Returns true if `data` contains `value`, false otherwise.
     */


    function includes(data, value) {
      var iterator, iteration, keys, length, i;

      if (!assigned(data)) {
        return false;
      }

      if (haveSymbols && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (!iteration.done);

        return false;
      }

      keys = Object.keys(data);
      length = keys.length;

      for (i = 0; i < length; ++i) {
        if (data[keys[i]] === value) {
          return true;
        }
      }

      return false;
    }
    /**
     * Public function `hasLength`.
     *
     * Returns true if `data` has a length property that equals `length`, false
     * otherwise.
     */


    function hasLength(data, length) {
      return assigned(data) && data.length === length;
    }
    /**
     * Public function `date`.
     *
     * Returns true if `data` is a valid date, false otherwise.
     */


    function date(data) {
      return instanceStrict(data, Date) && integer(data.getTime());
    }
    /**
     * Public function `function`.
     *
     * Returns true if `data` is a function, false otherwise.
     */


    function isFunction(data) {
      return typeof data === 'function';
    }
    /**
     * Public function `apply`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result array. If the same function is to be applied across all of the
     * data, a single predicate function may be passed in.
     *
     */


    function apply(data, predicates) {
      assert.array(data);

      if (isFunction(predicates)) {
        return data.map(function (value) {
          return predicates(value);
        });
      }

      assert.array(predicates);
      assert.hasLength(data, predicates.length);
      return data.map(function (value, index) {
        return predicates[index](value);
      });
    }
    /**
     * Public function `map`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result object. Supports nested objects. If the `data` is not nested and
     * the same function is to be applied across all of it, a single predicate
     * function may be passed in.
     *
     */


    function map(data, predicates) {
      assert.object(data);

      if (isFunction(predicates)) {
        return mapSimple(data, predicates);
      }

      assert.object(predicates);
      return mapComplex(data, predicates);
    }

    function mapSimple(data, predicate) {
      var result = {};
      Object.keys(data).forEach(function (key) {
        result[key] = predicate(data[key]);
      });
      return result;
    }

    function mapComplex(data, predicates) {
      var result = {};
      Object.keys(predicates).forEach(function (key) {
        var predicate = predicates[key];

        if (isFunction(predicate)) {
          if (not.assigned(data)) {
            result[key] = !!predicate.m;
          } else {
            result[key] = predicate(data[key]);
          }
        } else if (object(predicate)) {
          result[key] = mapComplex(data[key], predicate);
        }
      });
      return result;
    }
    /**
     * Public function `all`
     *
     * Check that all boolean values are true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function all(data) {
      if (array(data)) {
        return testArray(data, false);
      }

      assert.object(data);
      return testObject(data, false);
    }

    function testArray(data, result) {
      var i;

      for (i = 0; i < data.length; i += 1) {
        if (data[i] === result) {
          return result;
        }
      }

      return !result;
    }

    function testObject(data, result) {
      var key, value;

      for (key in data) {
        if (data.hasOwnProperty(key)) {
          value = data[key];

          if (object(value) && testObject(value, result) === result) {
            return result;
          }

          if (value === result) {
            return result;
          }
        }
      }

      return !result;
    }
    /**
     * Public function `any`
     *
     * Check that at least one boolean value is true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function any(data) {
      if (array(data)) {
        return testArray(data, true);
      }

      assert.object(data);
      return testObject(data, true);
    }

    function mixin(target, source) {
      Object.keys(source).forEach(function (key) {
        target[key] = source[key];
      });
      return target;
    }
    /**
     * Public modifier `assert`.
     *
     * Throws if `predicate` returns false.
     */


    function assertModifier(predicate, defaultMessage) {
      return function () {
        return assertPredicate(predicate, arguments, defaultMessage);
      };
    }

    function assertPredicate(predicate, args, defaultMessage) {
      var argCount = predicate.l || predicate.length;
      var message = args[argCount];
      var ErrorType = args[argCount + 1];
      assertImpl(predicate.apply(null, args), nonEmptyString(message) ? message : defaultMessage, isFunction(ErrorType) ? ErrorType : TypeError);
      return args[0];
    }

    function assertImpl(value, message, ErrorType) {
      if (value) {
        return value;
      }

      throw new (ErrorType || Error)(message || 'Assertion failed');
    }
    /**
     * Public modifier `not`.
     *
     * Negates `predicate`.
     */


    function notModifier(predicate) {
      var modifiedPredicate = function () {
        return notImpl(predicate.apply(null, arguments));
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function notImpl(value) {
      return !value;
    }
    /**
     * Public modifier `maybe`.
     *
     * Returns true if predicate argument is  null or undefined,
     * otherwise propagates the return value from `predicate`.
     */


    function maybeModifier(predicate) {
      var modifiedPredicate = function () {
        if (not.assigned(arguments[0])) {
          return true;
        }

        return predicate.apply(null, arguments);
      };

      modifiedPredicate.l = predicate.length; // Hackishly indicate that this is a maybe.xxx predicate.
      // Without this flag, the alternative would be to iterate
      // through the maybe predicates or use indexOf to check,
      // which would be time-consuming.

      modifiedPredicate.m = true;
      return modifiedPredicate;
    }

    function maybeImpl(value) {
      if (assigned(value) === false) {
        return true;
      }

      return value;
    }
    /**
     * Public modifier `of`.
     *
     * Applies the chained predicate to members of the collection.
     */


    function ofModifier(target, type, predicate) {
      var modifiedPredicate = function () {
        var collection, args;
        collection = arguments[0];

        if (target === 'maybe' && not.assigned(collection)) {
          return true;
        }

        if (!type(collection)) {
          return false;
        }

        collection = coerceCollection(type, collection);
        args = slice.call(arguments, 1);

        try {
          collection.forEach(function (item) {
            if ((target !== 'maybe' || assigned(item)) && !predicate.apply(null, [item].concat(args))) {
              // TODO: Replace with for...of when ES6 is required.
              throw 0;
            }
          });
        } catch (ignore) {
          return false;
        }

        return true;
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function coerceCollection(type, collection) {
      switch (type) {
        case arrayLike:
          return slice.call(collection);

        case object:
          return Object.keys(collection).map(function (key) {
            return collection[key];
          });

        default:
          return collection;
      }
    }

    function createModifiedPredicates(modifier, object) {
      return createModifiedFunctions([modifier, predicates, object]);
    }

    function createModifiedFunctions(args) {
      var modifier, object, functions, result;
      modifier = args.shift();
      object = args.pop();
      functions = args.pop();
      result = object || {};
      Object.keys(functions).forEach(function (key) {
        Object.defineProperty(result, key, {
          configurable: false,
          enumerable: true,
          writable: false,
          value: modifier.apply(null, args.concat(functions[key], messages[key]))
        });
      });
      return result;
    }

    function createModifiedModifier(modifier, modified) {
      return createModifiedFunctions([modifier, modified, null]);
    }

    function createOfPredicates(key) {
      predicates[key].of = createModifiedFunctions([ofModifier.bind(null, null), predicates[key], predicates, null]);
    }

    function createOfModifiers(base, modifier) {
      collections.forEach(function (key) {
        base[key].of = createModifiedModifier(modifier, predicates[key].of);
      });
    }

    function createMaybeOfModifiers(key) {
      maybe[key].of = createModifiedFunctions([ofModifier.bind(null, 'maybe'), predicates[key], predicates, null]);
      assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
      assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
    }

    function exportFunctions(functions) {
      if ( module !== null && module.exports) {
        module.exports = functions;
      } else {
        globals.check = functions;
      }
    }
  })(commonjsGlobal);
});var asserttype = chai => {
  const types = ['number', 'string', 'boolean', 'object', 'array', 'date', 'function'];
  types.forEach(type => {
    chai.Assertion.addMethod(type, function () {
      this.assert(checkTypes[type](this._obj), `expected #{this} to be ${type}`, `expected #{this} not to be ${type}`);
    });
  });
};var chaiEvents = createCommonjsModule(function (module, exports) {
  function plugin(chai, utils) {
    var Assertion = chai.Assertion;
    /**
     * Checks if a given entry is an event emitter.
     * Uses EventEmitter or EventTarget if available to quickly check `instanceof`.  Otherwise, checks that common methods
     * to event emitters are available.
     *
     * Gracefully handles custom implementations of event emitters even if EventEmitter or EventTarget are available,
     * checking methods if the emitter doesn't inherit from the global emitter.
    */

    function isEmitter() {
      // Easy check: if Node's EventEmitter or window.EventEmitter exist, check if this is an instance of it.
      if (typeof EventEmitter !== "undefined" && EventEmitter !== null && this._obj instanceof EventEmitter) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Easy check: if the browser's EventTarget exists, check if this is an instance of it.


      if (typeof EventTarget !== "undefined" && EventTarget !== null && this._obj instanceof EventTarget) {
        return this.assert(true, "", "expected #{this} to not be an EventTarget");
      }

      var obj = this._obj; // Check for Node.js style event emitters with "on", "emit", etc.

      var node = ["on", "emit"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (node) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Check for Browser-based event emitters with "addEventListener", etc.


      var browser = ["addEventListener", "dispatchEvent", "removeEventListener"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (browser) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      }

      this.assert(false, "expected #{this} to be an EventEmitter", "");
    }
    Assertion.addProperty("emitter", isEmitter);
    Assertion.addProperty("target", isEmitter);
    Assertion.addMethod("emit", function (name, args) {
      const timeout = typeof args === "object" && typeof args.timeout === "number" ? args.timeout : 1500;
      const obj = utils.flag(this, "object");
      new Assertion(this._obj).to.be.an.emitter;
      new Assertion(name).to.satisfy(function (_name) {
        return typeof _name === 'string' || typeof _name === 'symbol';
      });

      const assertEmission = expr => this.assert(expr, `expected #{this} to emit message with key '${name.toString()}'`, `expected #{this} to not emit message with key '${name.toString()}'`);

      return new Promise((resolve, reject) => {
        let done = false;
        obj.once(name, (...args) => {
          if (done) {
            return;
          }

          done = true;

          try {
            assertEmission(true); // Will throw error if action is unexpected.

            resolve(args);
          } catch (err) {
            reject(err);
          }
        });
        setTimeout(() => {
          if (done) {
            return;
          }

          done = true;

          try {
            assertEmission(false); // Will throw error if action is unexpected.

            resolve();
          } catch (err) {
            reject(err);
          }
        }, timeout);
      });
    });
  }

  if (typeof commonjsRequire === "function" && 'object' === "object" && 'object' === "object") {
    module.exports = plugin;
  } else {
    // Other environment (usually <script> tag): plug in to global chai instance directly.
    chai.use(plugin);
  }
});// @Popup = window.quickpopup
var assert$1, expect$1;
chai$2.use(chaiDom);
chai$2.use(sources);
chai$2.use(chaiAlmost_1);
chai$2.use(asserttype);
chai$2.use(chaiEvents);
mocha.setup('tdd');
mocha.slow(400);
mocha.timeout(6000);

if (!window.__karma__) {
  mocha.bail();
}

expect$1 = chai$2.expect;
assert$1 = chai$2.assert;
window.sandbox = null;
suite("QuickPopup", function () {
  setup(restartSandbox);
  teardown(quickpopup$1.destroyAll);
  test("Version Property", function () {
    return expect$1(quickpopup$1.version).to.equal(version$4);
  });
  suite("instance", function () {
    test("should be an event emitter", function () {
      var popup;
      popup = quickpopup$1();
      assert$1.equal(typeof popup.on, 'function');
      assert$1.equal(typeof popup.off, 'function');
      assert$1.equal(typeof popup.emit, 'function');
      Promise.delay().then(function () {
        return popup.emit('someEvent');
      });
      return expect$1(popup).to.emit('someEvent');
    });
    return suite("args", function () {
      test("using no args", function () {
        var popup;
        popup = quickpopup$1();
        popup = new quickpopup$1();
        assert$1(!(popup instanceof quickpopup$1));
        assert$1.equal(typeof popup, 'object');
        assert$1.equal(typeof popup.open, 'function');
        return assert$1.equal(popup.el.text, '');
      });
      test("with string arg", function () {
        var popup;
        popup = quickpopup$1('provided string');
        return assert$1.equal(popup.el.text, 'provided string');
      });
      test("with html string arg", function () {
        var contents, popup;
        popup = quickpopup$1('<b class="theBoldOne">provided string</b><i class="theSlantedOne"> is slanted</b>');
        assert$1.equal(popup.el.text, 'provided string is slanted');
        contents = popup.el.child.content.lastChild.children;
        assert$1.equal(contents.length, 2);
        assert$1.equal(contents[0].type, 'b');
        assert$1.equal(contents[1].type, 'i');
        assert$1.equal(contents[0].raw.className, 'theBoldOne');
        return assert$1.equal(contents[1].raw.className, 'theSlantedOne');
      });
      test("with DOM element arg", function () {
        var contents, div, popup, span;
        span = quickdom.span({
          class: 'abc123-child'
        }, 'provided el');
        div = quickdom.div({
          class: 'abc123'
        }, span);
        popup = quickpopup$1(div.raw);
        assert$1.equal(popup.el.text, 'provided el');
        contents = popup.el.child.content.children;
        assert$1.equal(contents.length, 1);
        assert$1.equal(contents[0].type, 'div');
        assert$1.equal(contents[0].raw.className, 'abc123');
        assert$1.equal(contents[0], div);
        return assert$1.equal(contents[0].children[0], span);
      });
      test("with QuickDOM element arg", function () {
        var contents, div, popup, span;
        span = quickdom.span({
          class: 'abc123-child'
        }, 'provided el');
        div = quickdom.div({
          class: 'abc123'
        }, span);
        popup = quickpopup$1(div);
        assert$1.equal(popup.el.text, 'provided el');
        contents = popup.el.child.content.children;
        assert$1.equal(contents.length, 1);
        assert$1.equal(contents[0].type, 'div');
        assert$1.equal(contents[0].raw.className, 'abc123');
        assert$1.equal(contents[0], div);
        return assert$1.equal(contents[0].children[0], span);
      });
      return test("with settings arg", function () {
        var popupA, popupB;
        popupA = quickpopup$1({});
        popupB = quickpopup$1({
          placement: 'bottom'
        });
        assert$1.equal(popupA.settings.placement, 'center');
        return assert$1.equal(popupB.settings.placement, 'bottom');
      });
    });
  });
  suite("behavior", function () {
    test("should create a wrapper element around body contents", function () {
      var bodyChildren, popup;
      assert$1.equal(typeof quickdom.query('#bodyWrapper'), 'undefined');
      bodyChildren = quickdom(document.body).children.slice();
      popup = quickpopup$1();
      assert$1.equal(typeof quickdom.query('#bodyWrapper'), 'object');
      assert$1.equal(quickdom.query('#bodyWrapper').parent, quickdom(document.body));
      assert$1.equal(quickdom(document.body).children.length, 2);
      assert$1.equal(quickdom.query('#bodyWrapper').children.length, bodyChildren.length);
      quickpopup$1.unwrapBody();
      assert$1.equal(typeof quickdom.query('#bodyWrapper'), 'undefined');
      assert$1.equal(quickdom(document.body).children.length, bodyChildren.length + 1);
      popup.destroy();
      assert$1.equal(quickdom(document.body).children.length, bodyChildren.length);
      popup = quickpopup$1();
      assert$1.equal(quickdom(document.body).children.length, 2);
      return assert$1.equal(quickdom.query('#bodyWrapper').children.length, bodyChildren.length);
    });
    return test("Popup.config() will return a new constructor with customized setting defaults & templates", function () {
      var Popup2;
      Popup2 = quickpopup$1.config({
        animation: 100
      });
      assert$1.notEqual(Popup2, quickpopup$1);
      assert$1.equal(Popup2.defaults.animation, 100);
      assert$1.notEqual(quickpopup$1.defaults.animation, 100);
      quickpopup$1();
      return Popup2();
    });
  });
  return suite("open/close", function () {
    suiteSetup(function () {
      return this.Popup = quickpopup$1.config({
        animation: 50
      });
    });
    test("will return promises that resolve when animation ends", function () {
      var content, openPromise, openTime, popup, startTime;
      content = quickdom.div(null, 'abc123');
      popup = this.Popup(content);
      startTime = Date.now();
      openTime = null;
      assert$1.equal(popup.state.open, false);
      openPromise = popup.open();
      assert$1.ok(openPromise instanceof Promise);
      assert$1.ok(openPromise.isPending());
      return Promise.bind(this).then(function () {
        return openPromise;
      }).then(function () {
        openTime = Date.now();
        assert$1.isAtLeast(openTime - startTime, this.Popup.defaults.animation / 2);
        return assert$1.equal(popup.state.open, true);
      }).then(function () {
        return popup.close();
      }).then(function () {
        assert$1.isAtLeast(Date.now() - openTime, this.Popup.defaults.animation / 2);
        return assert$1.equal(popup.state.open, false);
      });
    });
    test("will emit events before/present/finish for open/close", function () {
      var count, events, popup;
      popup = this.Popup();
      events = ['beforeopen', 'open', 'finishopen', 'beforeclose', 'close', 'finishclose'];
      count = {};
      events.forEach(function (event) {
        count[event] = 0;
        return popup.on(event, function () {
          return count[event]++;
        });
      });
      return Promise.resolve().then(function () {
        return assert$1.deepEqual(count, {
          beforeopen: 0,
          open: 0,
          finishopen: 0,
          beforeclose: 0,
          close: 0,
          finishclose: 0
        });
      }).then(function () {
        return popup.open();
      }).then(function () {
        return assert$1.deepEqual(count, {
          beforeopen: 1,
          open: 1,
          finishopen: 1,
          beforeclose: 0,
          close: 0,
          finishclose: 0
        });
      }).then(function () {
        return popup.close();
      }).then(function () {
        return assert$1.deepEqual(count, {
          beforeopen: 1,
          open: 1,
          finishopen: 1,
          beforeclose: 1,
          close: 1,
          finishclose: 1
        });
      });
    });
    test("will fail to open if another popup is open", function () {
      var popupA, popupB;
      popupA = this.Popup();
      popupB = this.Popup();
      return Promise.resolve().then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupA.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, true);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupB.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, true);
        return assert$1.equal(popupB.state.open, false);
      });
    });
    return test("will close all other open popups and will force open when options.forceOpen", function () {
      var popupA, popupB;
      popupA = this.Popup();
      popupB = this.Popup({
        forceOpen: true
      });
      return Promise.resolve().then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupA.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, true);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupB.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, true);
      }).then(function () {
        return popupA.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, true);
      });
    });
  });
});})));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL3F1aWNrY3NzL2Rpc3QvcXVpY2tjc3MuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWV4dGVuZC9kaXN0L3NtYXJ0LWV4dGVuZC5lc20uanMiLCIuLi9ub2RlX21vZHVsZXMvQGRhbmllbGthbGVuL2lzL2Rpc3QvaXMuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3F1aWNrZG9tL2Rpc3QvcXVpY2tkb20uZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3AtZmluYWxseS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wLXRpbWVvdXQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcC1ldmVudC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcm9taXNlLWJyZWFrL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RldGVjdC1hbmltYXRpb24tZW5kLWhlbHBlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldmVudC1saXRlL2V2ZW50LWxpdGUuanMiLCIuLi9idWlsZC9xdWlja3BvcHVwLmVzbS5qcyIsImhlbHBlcnMuY29mZmVlIiwiLi4vbm9kZV9tb2R1bGVzL2Fzc2VydGlvbi1lcnJvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYXRodmFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Rlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvdHlwZS1kZXRlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZnVuYy1uYW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzUHJveHlFbmFibGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRMZW5ndGhHdWFyZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Byb3hpZnkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRNZXRob2QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2NvbXBhcmVCeUluc3BlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stZXJyb3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pc05hTi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2V4cGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWRvbS9jaGFpLWRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLXN0eWxlL3NvdXJjZXMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWFsbW9zdC9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stdHlwZXMvc3JjL2NoZWNrLXR5cGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktYXNzZXJ0dHlwZS9hc3NlcnR0eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktZXZlbnRzL2NoYWktZXZlbnRzLmpzIiwidGVzdC5jb2ZmZWUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn12YXIgUkVHRVhfTEVOX1ZBTCA9IC9eXFxkKyg/OlthLXpdfFxcJSkrJC9pO1xudmFyIFJFR0VYX0RJR0lUUyA9IC9cXGQrJC87XG52YXIgUkVHRVhfU1BBQ0UgPSAvXFxzLztcbnZhciBSRUdFWF9LRUJBQiA9IC8oW0EtWl0pKy9nO1xudmFyIElNUE9SVEFOVCA9ICdpbXBvcnRhbnQnO1xudmFyIFBPU1NJQkxFX1BSRUZJWEVTID0gWyd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nXTtcbnZhciBSRVFVSVJFU19VTklUX1ZBTFVFID0gWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ2Jsb2NrLXNpemUnLCAnYm9yZGVyLXdpZHRoJywgJ2NvbHVtblJ1bGUtd2lkdGgnLCAnY3gnLCAnY3knLCAnZm9udC1zaXplJywgJ2dyaWQtY29sdW1uLWdhcCcsICdncmlkLXJvdy1nYXAnLCAnaGVpZ2h0JywgJ2lubGluZS1zaXplJywgJ2xpbmUtaGVpZ2h0JywgJ21pbkJsb2NrLXNpemUnLCAnbWluLWhlaWdodCcsICdtaW4taW5saW5lLXNpemUnLCAnbWluLXdpZHRoJywgJ21heC1oZWlnaHQnLCAnbWF4LXdpZHRoJywgJ291dGxpbmUtb2Zmc2V0JywgJ291dGxpbmUtd2lkdGgnLCAncGVyc3BlY3RpdmUnLCAnc2hhcGUtbWFyZ2luJywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWluZGVudCcsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ3gnLCAneSddO1xudmFyIFFVQURfU0hPUlRIQU5EUyA9IFsnbWFyZ2luJywgJ3BhZGRpbmcnLCAnYm9yZGVyJywgJ2JvcmRlci1yYWRpdXMnXTtcbnZhciBESVJFQ1RJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXTtcblFVQURfU0hPUlRIQU5EUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICB2YXIgZGlyZWN0aW9uLCBpLCBsZW47XG4gIFJFUVVJUkVTX1VOSVRfVkFMVUUucHVzaChwcm9wZXJ0eSk7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gRElSRUNUSU9OUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTlNbaV07XG4gICAgUkVRVUlSRVNfVU5JVF9WQUxVRS5wdXNoKHByb3BlcnR5ICsgJy0nICsgZGlyZWN0aW9uKTtcbiAgfVxufSk7dmFyIFNBTVBMRV9TVFlMRSwgc3R5bGVDb25maWc7XG5TQU1QTEVfU1RZTEUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHRhcmdldCwgaXRlbSkge1xuICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG52YXIgaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIGlzSXRlcmFibGUodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgJiYgX3R5cGVvZih0YXJnZXQpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0Lmxlbmd0aCA9PT0gJ251bWJlcicgJiYgIXRhcmdldC5ub2RlVHlwZTtcbn07XG52YXIgdG9LZWJhYkNhc2UgPSBmdW5jdGlvbiB0b0tlYmFiQ2FzZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKFJFR0VYX0tFQkFCLCBmdW5jdGlvbiAoZSwgbGV0dGVyKSB7XG4gICAgcmV0dXJuIFwiLVwiLmNvbmNhdChsZXR0ZXIudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xufTtcbnZhciBpc1Byb3BTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1Byb3BTdXBwb3J0ZWQocHJvcGVydHkpIHtcbiAgcmV0dXJuIHR5cGVvZiBTQU1QTEVfU1RZTEVbcHJvcGVydHldICE9PSAndW5kZWZpbmVkJztcbn07XG52YXIgaXNWYWx1ZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzVmFsdWVTdXBwb3J0ZWQocHJvcGVydHksIHZhbHVlKSB7XG4gIGlmICh3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHMpIHtcbiAgICByZXR1cm4gd2luZG93LkNTUy5zdXBwb3J0cyhwcm9wZXJ0eSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFNBTVBMRV9TVFlMRVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gU0FNUExFX1NUWUxFW3Byb3BlcnR5XSA9PT0gJycgKyB2YWx1ZTtcbiAgfVxufTtcbnZhciBnZXRQcmVmaXggPSBmdW5jdGlvbiBnZXRQcmVmaXgocHJvcGVydHksIHNraXBJbml0aWFsQ2hlY2spIHtcbiAgdmFyIGosIGxlbjEsIHByZWZpeDtcblxuICBpZiAoc2tpcEluaXRpYWxDaGVjayB8fCAhaXNQcm9wU3VwcG9ydGVkKHByb3BlcnR5KSkge1xuICAgIGZvciAoaiA9IDAsIGxlbjEgPSBQT1NTSUJMRV9QUkVGSVhFUy5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgIHByZWZpeCA9IFBPU1NJQkxFX1BSRUZJWEVTW2pdO1xuXG4gICAgICBpZiAoaXNQcm9wU3VwcG9ydGVkKFwiLVwiLmNvbmNhdChwcmVmaXgsIFwiLVwiKS5jb25jYXQocHJvcGVydHkpKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gXCItXCIuY29uY2F0KHByZWZpeCwgXCItXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn07XG52YXIgbm9ybWFsaXplUHJvcGVydHkgPSBmdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICBwcm9wZXJ0eSA9IHRvS2ViYWJDYXNlKHByb3BlcnR5KTtcblxuICBpZiAoaXNQcm9wU3VwcG9ydGVkKHByb3BlcnR5KSkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoZ2V0UHJlZml4KHByb3BlcnR5LCB0cnVlKSkuY29uY2F0KHByb3BlcnR5KTtcbiAgfVxufTtcbnZhciBub3JtYWxpemVWYWx1ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAoaW5jbHVkZXMoUkVRVUlSRVNfVU5JVF9WQUxVRSwgcHJvcGVydHkpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgaWYgKFJFR0VYX0RJR0lUUy50ZXN0KHZhbHVlKSAmJiAhUkVHRVhfTEVOX1ZBTC50ZXN0KHZhbHVlKSAmJiAhUkVHRVhfU1BBQ0UudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlICs9IHByb3BlcnR5ID09PSAnbGluZS1oZWlnaHQnID8gJ2VtJyA6ICdweCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBzb3J0ID0gZnVuY3Rpb24gc29ydChhcnJheSkge1xuICB2YXIgZ3JlYXQsIGksIGxlbiwgbGVzcywgcGl2b3Q7XG5cbiAgaWYgKGFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgcGl2b3QgPSBhcnJheVswXTtcbiAgICBsZXNzID0gW107XG4gICAgZ3JlYXQgPSBbXTtcbiAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoKytpICE9PSBsZW4pIHtcbiAgICAgIGlmIChhcnJheVtpXSA8PSBwaXZvdCkge1xuICAgICAgICBsZXNzLnB1c2goYXJyYXlbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JlYXQucHVzaChhcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnQobGVzcykuY29uY2F0KHBpdm90LCBzb3J0KGdyZWF0KSk7XG4gIH1cbn07XG52YXIgaGFzaCA9IGZ1bmN0aW9uIGhhc2goc3RyaW5nKSB7XG4gIHZhciBoc2gsIGksIGxlbmd0aDtcbiAgaHNoID0gNTM4MTtcbiAgaSA9IC0xO1xuICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2kgIT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICBoc2ggPSAoaHNoIDw8IDUpIC0gaHNoICsgc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgaHNoIHw9IDA7XG4gIH1cblxuICByZXR1cm4gJ18nICsgKGhzaCA8IDAgPyBoc2ggKiAtMiA6IGhzaCk7XG59O1xudmFyIHJ1bGVUb1N0cmluZyA9IGZ1bmN0aW9uIHJ1bGVUb1N0cmluZyhydWxlLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGosIGxlbjEsIG91dHB1dCwgcHJvcCwgcHJvcGVydHksIHByb3BzLCB2YWx1ZTtcbiAgb3V0cHV0ID0gJyc7XG4gIHByb3BzID0gc29ydChPYmplY3Qua2V5cyhydWxlKSk7XG5cbiAgZm9yIChqID0gMCwgbGVuMSA9IHByb3BzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgIHByb3AgPSBwcm9wc1tqXTtcblxuICAgIGlmICh0eXBlb2YgcnVsZVtwcm9wXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJ1bGVbcHJvcF0gPT09ICdudW1iZXInKSB7XG4gICAgICBwcm9wZXJ0eSA9IG5vcm1hbGl6ZVByb3BlcnR5KHByb3ApO1xuICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgcnVsZVtwcm9wXSk7XG5cbiAgICAgIGlmIChpbXBvcnRhbnQpIHtcbiAgICAgICAgdmFsdWUgKz0gXCIgIWltcG9ydGFudFwiO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQgKz0gXCJcIi5jb25jYXQocHJvcGVydHksIFwiOlwiKS5jb25jYXQodmFsdWUsIFwiO1wiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcbnZhciBpbmxpbmVTdHlsZUNvbmZpZyA9IHN0eWxlQ29uZmlnID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBpbmxpbmVTdHlsZSA9IGZ1bmN0aW9uIGlubGluZVN0eWxlKHJ1bGUsIHZhbHVlVG9TdG9yZSwgbGV2ZWwpIHtcbiAgdmFyIGNvbmZpZywgc3R5bGVFbDtcblxuICBpZiAoIShjb25maWcgPSBzdHlsZUNvbmZpZ1tsZXZlbF0pKSB7XG4gICAgc3R5bGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGVFbC5pZCA9IFwicXVpY2tjc3NcIi5jb25jYXQobGV2ZWwgfHwgJycpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gICAgc3R5bGVDb25maWdbbGV2ZWxdID0gY29uZmlnID0ge1xuICAgICAgZWw6IHN0eWxlRWwsXG4gICAgICBjb250ZW50OiAnJyxcbiAgICAgIGNhY2hlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgfVxuXG4gIGlmICghY29uZmlnLmNhY2hlW3J1bGVdKSB7XG4gICAgY29uZmlnLmNhY2hlW3J1bGVdID0gdmFsdWVUb1N0b3JlIHx8IHRydWU7XG4gICAgY29uZmlnLmVsLnRleHRDb250ZW50ID0gY29uZmlnLmNvbnRlbnQgKz0gcnVsZTtcbiAgfVxufTtcbnZhciBjbGVhcklubGluZVN0eWxlID0gZnVuY3Rpb24gY2xlYXJJbmxpbmVTdHlsZShsZXZlbCkge1xuICB2YXIgY29uZmlnLCBqLCBrZXksIGtleXMsIGxlbjE7XG5cbiAgaWYgKGNvbmZpZyA9IHN0eWxlQ29uZmlnW2xldmVsXSkge1xuICAgIGlmICghY29uZmlnLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWcuZWwudGV4dENvbnRlbnQgPSBjb25maWcuY29udGVudCA9ICcnO1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcuY2FjaGUpO1xuXG4gICAgZm9yIChqID0gMCwgbGVuMSA9IGtleXMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgY29uZmlnLmNhY2hlW2tleV0gPSBudWxsO1xuICAgIH1cbiAgfVxufTt2YXIgdmVyc2lvbiA9IFwiMS40LjRcIjt2YXIgX3F1aWNrY3NzO1xudmFyIGluZGV4ID0gX3F1aWNrY3NzID0gZnVuY3Rpb24gcXVpY2tjc3ModGFyZ2V0RWwsIHByb3BlcnR5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gIHZhciBjb21wdXRlZFN0eWxlLCBpLCBsZW4sIHN1YkVsLCBzdWJQcm9wZXJ0eSwgc3ViVmFsdWU7XG5cbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIWlzSXRlcmFibGUodGFyZ2V0RWwpOlxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGFyZ2V0RWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ViRWwgPSB0YXJnZXRFbFtpXTtcblxuICAgICAgICBfcXVpY2tjc3Moc3ViRWwsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBfdHlwZW9mKHByb3BlcnR5KSAhPT0gJ29iamVjdCc6XG4gICAgICAvLyBQYXNzZWQgYSBzdHlsZSBtYXBcbiAgICAgIGZvciAoc3ViUHJvcGVydHkgaW4gcHJvcGVydHkpIHtcbiAgICAgICAgc3ViVmFsdWUgPSBwcm9wZXJ0eVtzdWJQcm9wZXJ0eV07XG5cbiAgICAgICAgX3F1aWNrY3NzKHRhcmdldEVsLCBzdWJQcm9wZXJ0eSwgc3ViVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wZXJ0eSA9IG5vcm1hbGl6ZVByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29tcHV0ZWRTdHlsZSA9IHRhcmdldEVsLl9jb21wdXRlZFN0eWxlIHx8ICh0YXJnZXRFbC5fY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWwpKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkU3R5bGVbcHJvcGVydHldO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eSkge1xuICAgICAgICB0YXJnZXRFbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgbm9ybWFsaXplVmFsdWUocHJvcGVydHksIHZhbHVlKSwgaW1wb3J0YW50ID8gSU1QT1JUQU5UIDogbnVsbCk7XG4gICAgICB9XG5cbiAgfVxufTtcblxuX3F1aWNrY3NzLmFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBmcmFtZXMpIHtcbiAgdmFyIGZyYW1lLCBnZW5lcmF0ZWQsIHByZWZpeCwgcnVsZXM7XG5cbiAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIGZyYW1lcyAmJiBfdHlwZW9mKGZyYW1lcykgPT09ICdvYmplY3QnKSB7XG4gICAgcHJlZml4ID0gZ2V0UHJlZml4KCdhbmltYXRpb24nKTtcbiAgICBnZW5lcmF0ZWQgPSAnJztcblxuICAgIGZvciAoZnJhbWUgaW4gZnJhbWVzKSB7XG4gICAgICBydWxlcyA9IGZyYW1lc1tmcmFtZV07XG4gICAgICBnZW5lcmF0ZWQgKz0gXCJcIi5jb25jYXQoZnJhbWUsIFwiIHtcIikuY29uY2F0KHJ1bGVUb1N0cmluZyhydWxlcyksIFwifVwiKTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZWQgPSBcIkBcIi5jb25jYXQocHJlZml4LCBcImtleWZyYW1lcyBcIikuY29uY2F0KG5hbWUsIFwiIHtcIikuY29uY2F0KGdlbmVyYXRlZCwgXCJ9XCIpO1xuICAgIHJldHVybiBpbmxpbmVTdHlsZShnZW5lcmF0ZWQsIHRydWUsIDApO1xuICB9XG59O1xuXG5fcXVpY2tjc3MucmVnaXN0ZXIgPSBmdW5jdGlvbiAocnVsZSwgbGV2ZWwsIGltcG9ydGFudCkge1xuICB2YXIgY2xhc3NOYW1lLCByZWYsIHN0eWxlO1xuXG4gIGlmIChydWxlICYmIF90eXBlb2YocnVsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgcnVsZSA9IHJ1bGVUb1N0cmluZyhydWxlLCBpbXBvcnRhbnQpO1xuXG4gICAgaWYgKCEoY2xhc3NOYW1lID0gKHJlZiA9IGlubGluZVN0eWxlQ29uZmlnW2xldmVsXSkgIT0gbnVsbCA/IHJlZltydWxlXSA6IHZvaWQgMCkpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGhhc2gocnVsZSk7XG4gICAgICBzdHlsZSA9IFwiLlwiLmNvbmNhdChjbGFzc05hbWUsIFwiIHtcIikuY29uY2F0KHJ1bGUsIFwifVwiKTtcbiAgICAgIGlubGluZVN0eWxlKHN0eWxlLCBjbGFzc05hbWUsIGxldmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59O1xuXG5fcXVpY2tjc3MuY2xlYXJSZWdpc3RlcmVkID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gIHJldHVybiBjbGVhcklubGluZVN0eWxlKGxldmVsIHx8IDApO1xufTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuX3F1aWNrY3NzLlVOU0VUID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICd1bnNldCcpOlxuICAgICAgcmV0dXJuICd1bnNldCc7XG5cbiAgICBjYXNlICFpc1ZhbHVlU3VwcG9ydGVkKCdkaXNwbGF5JywgJ2luaXRpYWwnKTpcbiAgICAgIHJldHVybiAnaW5pdGlhbCc7XG5cbiAgICBjYXNlICFpc1ZhbHVlU3VwcG9ydGVkKCdkaXNwbGF5JywgJ2luaGVyaXQnKTpcbiAgICAgIHJldHVybiAnaW5oZXJpdCc7XG4gIH1cbn0oKTtcblxuX3F1aWNrY3NzLnN1cHBvcnRzID0gaXNWYWx1ZVN1cHBvcnRlZDtcbl9xdWlja2Nzcy5zdXBwb3J0c1Byb3BlcnR5ID0gaXNQcm9wU3VwcG9ydGVkO1xuX3F1aWNrY3NzLm5vcm1hbGl6ZVByb3BlcnR5ID0gbm9ybWFsaXplUHJvcGVydHk7XG5fcXVpY2tjc3Mubm9ybWFsaXplVmFsdWUgPSBub3JtYWxpemVWYWx1ZTtcbl9xdWlja2Nzcy52ZXJzaW9uID0gdmVyc2lvbjtleHBvcnQgZGVmYXVsdCBpbmRleDsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59dmFyIF9leHRlbmQsIGlzQXJyYXksIGlzT2JqZWN0LCBfc2hvdWxkRGVlcEV4dGVuZDtcblxuaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkodGFyZ2V0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHRhcmdldCk7XG59O1xuXG5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0ICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0YXJnZXQpID09PSAnW29iamVjdCBPYmplY3RdJyB8fCBpc0FycmF5KHRhcmdldCk7XG59O1xuXG5fc2hvdWxkRGVlcEV4dGVuZCA9IGZ1bmN0aW9uIHNob3VsZERlZXBFeHRlbmQob3B0aW9ucywgdGFyZ2V0LCBwYXJlbnRLZXkpIHtcbiAgaWYgKG9wdGlvbnMuZGVlcCkge1xuICAgIGlmIChvcHRpb25zLm5vdERlZXApIHtcbiAgICAgIHJldHVybiAhb3B0aW9ucy5ub3REZWVwW3RhcmdldF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmRlZXBPbmx5KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGVlcE9ubHlbdGFyZ2V0XSB8fCBwYXJlbnRLZXkgJiYgX3Nob3VsZERlZXBFeHRlbmQob3B0aW9ucywgcGFyZW50S2V5KTtcbiAgfVxufTsgLy8gZWxzZSBmYWxzZVxuXG5cbnZhciBleHRlbmQgPSBfZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG9wdGlvbnMsIHRhcmdldCwgc291cmNlcywgcGFyZW50S2V5KSB7XG4gIHZhciBpLCBrZXksIGxlbiwgc291cmNlLCBzb3VyY2VWYWx1ZSwgc3ViVGFyZ2V0LCB0YXJnZXRWYWx1ZTtcblxuICBpZiAoIXRhcmdldCB8fCBfdHlwZW9mKHRhcmdldCkgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0YXJnZXQgPSB7fTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcblxuICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09IHRhcmdldCB8fCBzb3VyY2VWYWx1ZSA9PT0gdm9pZCAwIHx8IHNvdXJjZVZhbHVlID09PSBudWxsICYmICFvcHRpb25zLmFsbG93TnVsbCAmJiAhb3B0aW9ucy5udWxsRGVsZXRlcyB8fCBvcHRpb25zLmtleXMgJiYgIW9wdGlvbnMua2V5c1trZXldIHx8IG9wdGlvbnMubm90S2V5cyAmJiBvcHRpb25zLm5vdEtleXNba2V5XSB8fCBvcHRpb25zLm93biAmJiAhc291cmNlLmhhc093blByb3BlcnR5KGtleSkgfHwgb3B0aW9ucy5nbG9iYWxGaWx0ZXIgJiYgIW9wdGlvbnMuZ2xvYmFsRmlsdGVyKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSkgfHwgb3B0aW9ucy5maWx0ZXJzICYmIG9wdGlvbnMuZmlsdGVyc1trZXldICYmICFvcHRpb25zLmZpbHRlcnNba2V5XShzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09IG51bGwgJiYgb3B0aW9ucy5udWxsRGVsZXRlcykge1xuICAgICAgICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmdsb2JhbFRyYW5zZm9ybSkge1xuICAgICAgICAgIHNvdXJjZVZhbHVlID0gb3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0oc291cmNlVmFsdWUsIGtleSwgc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybXMgJiYgb3B0aW9ucy50cmFuc2Zvcm1zW2tleV0pIHtcbiAgICAgICAgICBzb3VyY2VWYWx1ZSA9IG9wdGlvbnMudHJhbnNmb3Jtc1trZXldKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhKG9wdGlvbnMuY29uY2F0ICYmIGlzQXJyYXkoc291cmNlVmFsdWUpICYmIGlzQXJyYXkodGFyZ2V0VmFsdWUpKTpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdGFyZ2V0VmFsdWUuY29uY2F0KHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAhKF9zaG91bGREZWVwRXh0ZW5kKG9wdGlvbnMsIGtleSwgcGFyZW50S2V5KSAmJiBpc09iamVjdChzb3VyY2VWYWx1ZSkpOlxuICAgICAgICAgICAgc3ViVGFyZ2V0ID0gaXNPYmplY3QodGFyZ2V0VmFsdWUpID8gdGFyZ2V0VmFsdWUgOiBpc0FycmF5KHNvdXJjZVZhbHVlKSA/IFtdIDoge307XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IF9leHRlbmQob3B0aW9ucywgc3ViVGFyZ2V0LCBbc291cmNlVmFsdWVdLCBrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O3ZhciB2ZXJzaW9uID0gXCIxLjcuNFwiO3ZhciBtb2RpZmllcnMsIG5ld0J1aWxkZXIsIG5vcm1hbGl6ZUtleXMsIHByaW1hcnlCdWlsZGVyO1xuXG5ub3JtYWxpemVLZXlzID0gZnVuY3Rpb24gbm9ybWFsaXplS2V5cyhrZXlzKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgb3V0cHV0O1xuXG4gIGlmIChrZXlzKSB7XG4gICAgb3V0cHV0ID0ge307XG5cbiAgICBpZiAoX3R5cGVvZihrZXlzKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG91dHB1dFtrZXlzXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgb3V0cHV0W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG5cbm5ld0J1aWxkZXIgPSBmdW5jdGlvbiBuZXdCdWlsZGVyKGlzQmFzZSkge1xuICB2YXIgX2J1aWxkZXI7XG5cbiAgX2J1aWxkZXIgPSBmdW5jdGlvbiBidWlsZGVyKHRhcmdldCkge1xuICAgIHZhciB0aGVUYXJnZXQ7XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgJF9pID0gLTEsIHNvdXJjZXMgPSBuZXcgQXJyYXkoJF9sZW4pOyB3aGlsZSAoKyskX2kgPCAkX2xlbikgc291cmNlc1skX2ldID0gYXJndW1lbnRzWyRfaV07XG5cbiAgICBpZiAoX2J1aWxkZXIub3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIHRoZVRhcmdldCA9IF9idWlsZGVyLm9wdGlvbnMudGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGVUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZChfYnVpbGRlci5vcHRpb25zLCB0aGVUYXJnZXQsIHNvdXJjZXMpO1xuICB9O1xuXG4gIGlmIChpc0Jhc2UpIHtcbiAgICBfYnVpbGRlci5pc0Jhc2UgPSB0cnVlO1xuICB9XG5cbiAgX2J1aWxkZXIub3B0aW9ucyA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfYnVpbGRlciwgbW9kaWZpZXJzKTtcbiAgcmV0dXJuIF9idWlsZGVyO1xufTtcblxubW9kaWZpZXJzID0ge1xuICAnZGVlcCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmRlZXAgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnb3duJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICBfLm9wdGlvbnMub3duID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ2FsbG93TnVsbCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmFsbG93TnVsbCA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdudWxsRGVsZXRlcyc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLm51bGxEZWxldGVzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ2NvbmNhdCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmNvbmNhdCA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdjbG9uZSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLnRhcmdldCA9IHt9O1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnbm90RGVlcCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5ub3REZWVwID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2RlZXBPbmx5Jzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLmRlZXBPbmx5ID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2tleXMnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBfLm9wdGlvbnMua2V5cyA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdub3RLZXlzJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLm5vdEtleXMgPSBub3JtYWxpemVLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAndHJhbnNmb3JtJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF8ub3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtICYmIF90eXBlb2YodHJhbnNmb3JtKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfLm9wdGlvbnMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdmaWx0ZXInOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgXy5vcHRpb25zLmdsb2JhbEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgJiYgX3R5cGVvZihmaWx0ZXIpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIF8ub3B0aW9ucy5maWx0ZXJzID0gZmlsdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnByaW1hcnlCdWlsZGVyID0gbmV3QnVpbGRlcih0cnVlKTtcbnByaW1hcnlCdWlsZGVyLnZlcnNpb24gPSB2ZXJzaW9uO1xudmFyIHByaW1hcnlCdWlsZGVyJDEgPSBwcmltYXJ5QnVpbGRlcjtleHBvcnQgZGVmYXVsdCBwcmltYXJ5QnVpbGRlciQxOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufXZhciBkZWZpbmVkID0gZnVuY3Rpb24gZGVmaW5lZChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICE9PSB2b2lkIDA7XG59O1xudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCBpbnN0YW5jZW9mIEFycmF5O1xufTtcbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gX3R5cGVvZihzdWJqZWN0KSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdDsgLy8gMm5kIGNoZWNrIGlzIHRvIHRlc3QgYWdhaW5zdCAnbnVsbCcgdmFsdWVzXG59O1xudmFyIG9iamVjdFBsYWluID0gZnVuY3Rpb24gb2JqZWN0UGxhaW4oc3ViamVjdCkge1xuICByZXR1cm4gb2JqZWN0KHN1YmplY3QpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgc3ViamVjdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnO1xufTtcbnZhciBudW1iZXIgPSBmdW5jdGlvbiBudW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInICYmICFpc05hTihzdWJqZWN0KTtcbn07XG52YXIgbnVtYmVyTG9vc2UgPSBmdW5jdGlvbiBudW1iZXJMb29zZShzdWJqZWN0KSB7XG4gIHJldHVybiBudW1iZXIoc3ViamVjdCkgfHwgc3RyaW5nKHN1YmplY3QpICYmIG51bWJlcihOdW1iZXIoc3ViamVjdCkpO1xufTtcbnZhciBpdGVyYWJsZSA9IGZ1bmN0aW9uIGl0ZXJhYmxlKHN1YmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdChzdWJqZWN0KSAmJiBudW1iZXIoc3ViamVjdC5sZW5ndGgpO1xufTtcbnZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbiBmdW5jdGlvbl8oc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdmdW5jdGlvbic7XG59O3ZhciBuYXRpdmVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RlZmluZWQ6IGRlZmluZWQsYXJyYXk6IGFycmF5LG9iamVjdDogb2JqZWN0LG9iamVjdFBsYWluOiBvYmplY3RQbGFpbixzdHJpbmc6IHN0cmluZyxudW1iZXI6IG51bWJlcixudW1iZXJMb29zZTogbnVtYmVyTG9vc2UsaXRlcmFibGU6IGl0ZXJhYmxlLGZ1bmN0aW9uXzogZnVuY3Rpb25ffSk7dmFyIGRvbURvYyA9IGZ1bmN0aW9uIGRvbURvYyhzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZVR5cGUgPT09IDk7XG59O1xudmFyIGRvbUVsID0gZnVuY3Rpb24gZG9tRWwoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVUeXBlID09PSAxO1xufTtcbnZhciBkb21UZXh0ID0gZnVuY3Rpb24gZG9tVGV4dChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZVR5cGUgPT09IDM7XG59O1xudmFyIGRvbU5vZGUgPSBmdW5jdGlvbiBkb21Ob2RlKHN1YmplY3QpIHtcbiAgcmV0dXJuIGRvbUVsKHN1YmplY3QpIHx8IGRvbVRleHQoc3ViamVjdCk7XG59O1xudmFyIGRvbVRleHRhcmVhID0gZnVuY3Rpb24gZG9tVGV4dGFyZWEoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVOYW1lID09PSAnVEVYVEFSRUEnO1xufTtcbnZhciBkb21JbnB1dCA9IGZ1bmN0aW9uIGRvbUlucHV0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlTmFtZSA9PT0gJ0lOUFVUJztcbn07XG52YXIgZG9tU2VsZWN0ID0gZnVuY3Rpb24gZG9tU2VsZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCc7XG59O1xudmFyIGRvbUZpZWxkID0gZnVuY3Rpb24gZG9tRmllbGQoc3ViamVjdCkge1xuICByZXR1cm4gZG9tSW5wdXQoc3ViamVjdCkgfHwgZG9tVGV4dGFyZWEoc3ViamVjdCkgfHwgZG9tU2VsZWN0KHN1YmplY3QpO1xufTt2YXIgZG9tID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe2RvbURvYzogZG9tRG9jLGRvbUVsOiBkb21FbCxkb21UZXh0OiBkb21UZXh0LGRvbU5vZGU6IGRvbU5vZGUsZG9tVGV4dGFyZWE6IGRvbVRleHRhcmVhLGRvbUlucHV0OiBkb21JbnB1dCxkb21TZWxlY3Q6IGRvbVNlbGVjdCxkb21GaWVsZDogZG9tRmllbGR9KTt2YXIgQVZBSUxfU0VUUywgQ2hlY2tzO1xuQVZBSUxfU0VUUyA9IHtcbiAgbmF0aXZlczogbmF0aXZlcyxcbiAgZG9tOiBkb21cbn07XG5cbkNoZWNrcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhDaGVja3MsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXJncztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2hlY2tzKGFyZ3MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIENoZWNrcyhzZXRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrcyk7XG5cbiAgICB2YXIgaSwgbGVuLCBzZXQ7XG5cbiAgICBpZiAoc2V0cyA9PSBudWxsKSB7XG4gICAgICBzZXRzID0gWyduYXRpdmVzJ107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0ID0gc2V0c1tpXTtcblxuICAgICAgaWYgKEFWQUlMX1NFVFNbc2V0XSkge1xuICAgICAgICB0aGlzLmxvYWQoQVZBSUxfU0VUU1tzZXRdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hlY2tzLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoc2V0KSB7XG4gICAgICB2YXIga2V5LCB2YWx1ZTtcblxuICAgICAgaWYgKEFWQUlMX1NFVFMubmF0aXZlcy5zdHJpbmcoc2V0KSkge1xuICAgICAgICBzZXQgPSBBVkFJTF9TRVRTW3NldF07XG4gICAgICB9XG5cbiAgICAgIGlmICghQVZBSUxfU0VUUy5uYXRpdmVzLm9iamVjdFBsYWluKHNldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGtleSBpbiBzZXQpIHtcbiAgICAgICAgdmFsdWUgPSBzZXRba2V5XTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnZnVuY3Rpb25fJykge1xuICAgICAgICAgIGtleSA9ICdmdW5jdGlvbic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2hlY2tzO1xufSgpO1xuXG52YXIgaW5kZXggPSBDaGVja3MucHJvdG90eXBlLmNyZWF0ZSgpO2V4cG9ydCBkZWZhdWx0IGluZGV4OyIsImltcG9ydCBDU1MgZnJvbSdxdWlja2Nzcyc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0IElTXyBmcm9tJ0BkYW5pZWxrYWxlbi9pcyc7ZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufXZhciB0ZW1wbGF0ZSA9IFsnaWQnLCAnbmFtZScsICd0eXBlJywgJ2hyZWYnLCAnc2VsZWN0ZWQnLCAnY2hlY2tlZCcsICdjbGFzc05hbWUnXTsgLy8gVG8gY29weSBmcm9tIERPTSBFbGVtZW50c1xuXG52YXIgZWxlbWVudCA9IFsnaWQnLCAncmVmJywgJ3R5cGUnLCAnbmFtZScsICd0ZXh0JywgJ3N0eWxlJywgJ2NsYXNzJywgJ2NsYXNzTmFtZScsICd1cmwnLCAnaHJlZicsICdzZWxlY3RlZCcsICdjaGVja2VkJywgJ3Byb3BzJywgJ2F0dHJzJywgJ3Bhc3NTdGF0ZVRvQ2hpbGRyZW4nLCAnc3RhdGVUcmlnZ2VycycsICd1bnBhc3NhYmxlU3RhdGVzJ107IC8vIFVzZWQgaW4gUXVpY2tFbGVtZW50Ojp0b0pTT05cbi8vICdyZWxhdGVkSW5zdGFuY2UnXG52YXIgSVM7XG5JUyA9IElTXy5jcmVhdGUoJ25hdGl2ZXMnLCAnZG9tJyk7XG5JUy5sb2FkKHtcbiAgcXVpY2tEb21FbDogZnVuY3Rpb24gcXVpY2tEb21FbChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUXVpY2tFbGVtZW50JztcbiAgfSxcbiAgdGVtcGxhdGU6IGZ1bmN0aW9uIHRlbXBsYXRlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdRdWlja1RlbXBsYXRlJztcbiAgfVxufSk7IC8vIGJhdGNoOiAoc3ViamVjdCktPiBzdWJqZWN0IGFuZCBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgaXMgJ1F1aWNrQmF0Y2gnXG5cbnZhciBJUyQxID0gSVM7dmFyIFF1aWNrRWxlbWVudCwgUXVpY2tXaW5kb3csIF9xdWlja2RvbTtcblF1aWNrRWxlbWVudCA9IG51bGw7XG5RdWlja1dpbmRvdyA9IG51bGw7XG5cbl9xdWlja2RvbSA9IGZ1bmN0aW9uIHF1aWNrZG9tKCkge1xuICB2YXIgYXJnLCBhcmdzLCBlbGVtZW50LCBpLCBqLCBsZW4sIHByZXZDb3VudDtcbiAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICBmb3IgKGkgPSBqID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICBhcmdzW2ldID0gYXJnO1xuICB9XG5cbiAgcHJldkNvdW50ID0gUXVpY2tFbGVtZW50LmNvdW50O1xuICBlbGVtZW50ID0gX3F1aWNrZG9tLmNyZWF0ZShhcmdzKTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9wb3N0Q3JlYXRpb24gJiYgUXVpY2tFbGVtZW50LmNvdW50ICE9PSBwcmV2Q291bnQpIHtcbiAgICBlbGVtZW50Ll9wb3N0Q3JlYXRpb24oKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuX3F1aWNrZG9tLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciBhcmdzTGVuZ3RoLCBjaGlsZCwgY2hpbGRyZW4sIGVsZW1lbnQsIGksIGosIGxlbiwgb3B0aW9ucywgdHlwZTtcblxuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhSVMkMS5hcnJheShhcmdzWzBdKTpcbiAgICAgIHJldHVybiBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJnc1swXSkpO1xuXG4gICAgY2FzZSAhSVMkMS50ZW1wbGF0ZShhcmdzWzBdKTpcbiAgICAgIHJldHVybiBhcmdzWzBdLnNwYXduKCk7XG5cbiAgICBjYXNlICFJUyQxLnF1aWNrRG9tRWwoYXJnc1swXSk6XG4gICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICByZXR1cm4gYXJnc1swXS51cGRhdGVPcHRpb25zKGFyZ3NbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICBjYXNlICEoSVMkMS5kb21Ob2RlKGFyZ3NbMF0pIHx8IElTJDEuZG9tRG9jKGFyZ3NbMF0pKTpcbiAgICAgIGlmIChhcmdzWzBdLl9xdWlja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF0uX3F1aWNrRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IGFyZ3NbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV0gfHwge307XG4gICAgICBvcHRpb25zLmV4aXN0aW5nID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBhcmdzWzBdICE9PSB3aW5kb3c6XG4gICAgICByZXR1cm4gUXVpY2tXaW5kb3c7XG5cbiAgICBjYXNlICFJUyQxLnN0cmluZyhhcmdzWzBdKTpcbiAgICAgIHR5cGUgPSBhcmdzWzBdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IElTJDEub2JqZWN0KGFyZ3NbMV0pID8gYXJnc1sxXSA6IHtcbiAgICAgICAgICB0ZXh0OiBhcmdzWzFdIHx8ICcnXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gSVMkMS5vYmplY3QoYXJnc1sxXSkgPyBhcmdzWzFdIDoge307XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBuZXcgUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGNoaWxkcmVuID0gbmV3IEFycmF5KGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCk7XG4gICAgICAgIGkgPSAxO1xuXG4gICAgICAgIHdoaWxlICgrK2kgPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gYXJnc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltqXTtcblxuICAgICAgICAgIGlmIChJUyQxLnN0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3F1aWNrZG9tLnRleHQoY2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJUyQxLmFycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgY2hpbGQgPSBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVMkMS5xdWlja0RvbUVsKGNoaWxkKSkge1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudDtcblxuICAgIGNhc2UgIShhcmdzWzBdICYmIChJUyQxLmRvbU5vZGUoYXJnc1swXVswXSkgfHwgSVMkMS5kb21Eb2MoYXJnc1swXVswXSkpKTpcbiAgICAgIHJldHVybiBfcXVpY2tkb20oYXJnc1swXVswXSk7XG4gIH1cbn07XG5cbl9xdWlja2RvbS5odG1sID0gZnVuY3Rpb24gKGlubmVySFRNTCkge1xuICB2YXIgY2hpbGRyZW4sIGNvbnRhaW5lcjtcbiAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICByZXR1cm4gX3F1aWNrZG9tLmJhdGNoKGNoaWxkcmVuKTtcbn07XG5cbl9xdWlja2RvbS5pc1F1aWNrRWwgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBJUyQxLnF1aWNrRG9tRWwodGFyZ2V0KTtcbn07XG5cbl9xdWlja2RvbS5pc0VsID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gSVMkMS5kb21FbCh0YXJnZXQpO1xufTtcbnZhciBpbml0ID0gZnVuY3Rpb24gaW5pdChRdWlja0VsZW1lbnRfLCBRdWlja1dpbmRvd18pIHtcbiAgUXVpY2tFbGVtZW50ID0gUXVpY2tFbGVtZW50XztcbiAgUXVpY2tXaW5kb3cgPSBRdWlja1dpbmRvd187XG4gIHJldHVybiBfcXVpY2tkb207XG59O3ZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHRhcmdldCwgaXRlbSkge1xuICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG52YXIgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0odGFyZ2V0LCBpdGVtKSB7XG4gIHZhciBpdGVtSW5kZXg7XG4gIGl0ZW1JbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pO1xuXG4gIGlmIChpdGVtSW5kZXggIT09IC0xKSB7XG4gICAgdGFyZ2V0LnNwbGljZShpdGVtSW5kZXgsIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgbm9ybWFsaXplRWxlbWVudEFyZyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIUlTJDEuc3RyaW5nKHRhcmdldEVsKTpcbiAgICAgIHJldHVybiBxdWlja2RvbS50ZXh0KHRhcmdldEVsKTtcblxuICAgIGNhc2UgIUlTJDEuZG9tTm9kZSh0YXJnZXRFbCk6XG4gICAgICByZXR1cm4gcXVpY2tkb20odGFyZ2V0RWwpO1xuXG4gICAgY2FzZSAhSVMkMS50ZW1wbGF0ZSh0YXJnZXRFbCk6XG4gICAgICByZXR1cm4gdGFyZ2V0RWwuc3Bhd24oKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGFyZ2V0RWw7XG4gIH1cbn07XG52YXIgaXNTdGF0ZVN0eWxlID0gZnVuY3Rpb24gaXNTdGF0ZVN0eWxlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nWzBdID09PSAnJCcgfHwgc3RyaW5nWzBdID09PSAnQCc7XG59O1xudmFyIHJlZ2lzdGVyU3R5bGUgPSBmdW5jdGlvbiByZWdpc3RlclN0eWxlKHJ1bGUsIGxldmVsLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGNhY2hlZCwgaSwgbGVuLCBvdXRwdXQsIHByb3AsIHByb3BzO1xuICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgY2FjaGVkID0gc3R5bGVDYWNoZS5nZXQocnVsZSwgbGV2ZWwpO1xuXG4gIGlmIChjYWNoZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkO1xuICB9XG5cbiAgb3V0cHV0ID0ge1xuICAgIGNsYXNzTmFtZTogW0NTUy5yZWdpc3RlcihydWxlLCBsZXZlbCwgaW1wb3J0YW50KV0sXG4gICAgZm5zOiBbXSxcbiAgICBydWxlOiBydWxlXG4gIH07XG4gIHByb3BzID0gT2JqZWN0LmtleXMocnVsZSk7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcHJvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwcm9wID0gcHJvcHNbaV07XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG91dHB1dC5mbnMucHVzaChbcHJvcCwgcnVsZVtwcm9wXV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZUNhY2hlLnNldChydWxlLCBvdXRwdXQsIGxldmVsKTtcbn07XG52YXIgc3R5bGVDYWNoZSA9IG5ldyAoXG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblxuICAgIHRoaXMua2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9jbGFzcywgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXksIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLmtleXNbbGV2ZWxdKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5rZXlzW2xldmVsXS5pbmRleE9mKGtleSk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tsZXZlbF1baW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSwgbGV2ZWwpIHtcbiAgICAgIGlmICghdGhpcy5rZXlzW2xldmVsXSkge1xuICAgICAgICB0aGlzLmtleXNbbGV2ZWxdID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzW2xldmVsXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmtleXNbbGV2ZWxdLnB1c2goa2V5KTtcbiAgICAgIHRoaXMudmFsdWVzW2xldmVsXS5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2NsYXNzO1xufSgpKSgpO3ZhciBSRUdFWF9XSElURVNQQUNFO1xuUkVHRVhfV0hJVEVTUEFDRSA9IC9cXHMrLztcbnZhciBvbl8gPSBmdW5jdGlvbiBvbl8oZXZlbnROYW1lcywgY2FsbGJhY2ssIHVzZUNhcHR1cmUsIGlzUHJpdmF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBjYWxsYmFja1JlZiwgc3BsaXQ7XG5cbiAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzID09IG51bGwpIHtcbiAgICB0aGlzLl9ldmVudENhbGxiYWNrcyA9IHtcbiAgICAgIF9fcmVmczoge31cbiAgICB9O1xuICB9XG5cbiAgaWYgKElTJDEuc3RyaW5nKGV2ZW50TmFtZXMpICYmIElTJDFbXCJmdW5jdGlvblwiXShjYWxsYmFjaykpIHtcbiAgICBzcGxpdCA9IGV2ZW50TmFtZXMuc3BsaXQoJy4nKTtcbiAgICBjYWxsYmFja1JlZiA9IHNwbGl0WzFdO1xuICAgIGV2ZW50TmFtZXMgPSBzcGxpdFswXTtcblxuICAgIGlmIChldmVudE5hbWVzID09PSAnaW5zZXJ0ZWQnICYmIHRoaXMuX2luc2VydGVkKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3BhcmVudCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBldmVudE5hbWVzLnNwbGl0KFJFR0VYX1dISVRFU1BBQ0UpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGJhc2U7XG5cbiAgICAgIGlmICghX3RoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgX3RoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0gPSBbXTtcblxuICAgICAgICBpZiAoIWlzUHJpdmF0ZSkge1xuICAgICAgICAgIF90aGlzLl9saXN0ZW5UbyhldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9pbnZva2VIYW5kbGVycyhldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tSZWYpIHtcbiAgICAgICAgaWYgKChiYXNlID0gX3RoaXMuX2V2ZW50Q2FsbGJhY2tzLl9fcmVmcylbZXZlbnROYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZVtldmVudE5hbWVdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fZXZlbnRDYWxsYmFja3MuX19yZWZzW2V2ZW50TmFtZV1bY2FsbGJhY2tSZWZdID0gY2FsbGJhY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBvbmNlID0gZnVuY3Rpb24gb25jZShldmVudE5hbWVzLCBjYWxsYmFjaykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICB2YXIgX29uY2VDYWxsYmFjaztcblxuICBpZiAoSVMkMS5zdHJpbmcoZXZlbnROYW1lcykgJiYgSVMkMVtcImZ1bmN0aW9uXCJdKGNhbGxiYWNrKSkge1xuICAgIHRoaXMub24oZXZlbnROYW1lcywgX29uY2VDYWxsYmFjayA9IGZ1bmN0aW9uIG9uY2VDYWxsYmFjayhldmVudCkge1xuICAgICAgX3RoaXMyLm9mZihldmVudE5hbWVzLCBfb25jZUNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMyLCBldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgb2ZmXyA9IGZ1bmN0aW9uIG9mZl8oZXZlbnROYW1lcywgY2FsbGJhY2spIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdmFyIGNhbGxiYWNrUmVmLCBldmVudE5hbWUsIHNwbGl0O1xuXG4gIGlmICh0aGlzLl9ldmVudENhbGxiYWNrcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fZXZlbnRDYWxsYmFja3MgPSB7XG4gICAgICBfX3JlZnM6IHt9XG4gICAgfTtcbiAgfVxuXG4gIGlmICghSVMkMS5zdHJpbmcoZXZlbnROYW1lcykpIHtcbiAgICBmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9ldmVudENhbGxiYWNrcykge1xuICAgICAgdGhpcy5vZmYoZXZlbnROYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3BsaXQgPSBldmVudE5hbWVzLnNwbGl0KCcuJyk7XG4gICAgY2FsbGJhY2tSZWYgPSBzcGxpdFsxXTtcbiAgICBldmVudE5hbWVzID0gc3BsaXRbMF07XG4gICAgZXZlbnROYW1lcy5zcGxpdChSRUdFWF9XSElURVNQQUNFKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHZhciByZWY7XG5cbiAgICAgIGlmIChfdGhpczMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IChyZWYgPSBfdGhpczMuX2V2ZW50Q2FsbGJhY2tzLl9fcmVmc1tldmVudE5hbWVdKSAhPSBudWxsID8gcmVmW2NhbGxiYWNrUmVmXSA6IHZvaWQgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChJUyQxW1wiZnVuY3Rpb25cIl0oY2FsbGJhY2spKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW0oX3RoaXMzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNhbGxiYWNrUmVmKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lKSB7XG4gIHZhciBidWJibGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgY2FuY2VsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGV2ZW50O1xuXG4gIGlmIChldmVudE5hbWUgJiYgSVMkMS5zdHJpbmcoZXZlbnROYW1lKSkge1xuICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG5cbiAgICBpZiAoZGF0YSAmJiBfdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgZXh0ZW5kKGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGVtaXRQcml2YXRlID0gZnVuY3Rpb24gZW1pdFByaXZhdGUoZXZlbnROYW1lLCBhcmcpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAoZXZlbnROYW1lICYmIElTJDEuc3RyaW5nKGV2ZW50TmFtZSkgJiYgKChyZWYgPSB0aGlzLl9ldmVudENhbGxiYWNrcykgIT0gbnVsbCA/IHJlZltldmVudE5hbWVdIDogdm9pZCAwKSkge1xuICAgIHRoaXMuX2ludm9rZUhhbmRsZXJzKGV2ZW50TmFtZSwgYXJnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBfaW52b2tlSGFuZGxlcnMgPSBmdW5jdGlvbiBfaW52b2tlSGFuZGxlcnMoZXZlbnROYW1lLCBhcmcpIHtcbiAgdmFyIGNhbGxiYWNrcywgY2IsIGksIGxlbjtcbiAgY2FsbGJhY2tzID0gdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXS5zbGljZSgpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGNiLmNhbGwodGhpcywgYXJnKTtcbiAgfVxufTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbnZhciBfbGlzdGVuVG8gPSBmdW5jdGlvbiBfbGlzdGVuVG8oZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICB2YXIgZXZlbnROYW1lVG9MaXN0ZW5Gb3IsIGxpc3Rlbk1ldGhvZDtcbiAgbGlzdGVuTWV0aG9kID0gdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50JztcbiAgZXZlbnROYW1lVG9MaXN0ZW5Gb3IgPSB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIgPyBldmVudE5hbWUgOiBcIm9uXCIuY29uY2F0KGV2ZW50TmFtZSk7XG4gIHRoaXMuZWxbbGlzdGVuTWV0aG9kXShldmVudE5hbWVUb0xpc3RlbkZvciwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5mdW5jdGlvbiBldmVudHMgKFF1aWNrRWxlbWVudCkge1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLm9uID0gb25fO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLm9uY2UgPSBvbmNlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLm9mZiA9IG9mZl87XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuZW1pdCA9IGVtaXQ7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuZW1pdFByaXZhdGUgPSBlbWl0UHJpdmF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5faW52b2tlSGFuZGxlcnMgPSBfaW52b2tlSGFuZGxlcnM7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9saXN0ZW5UbyA9IF9saXN0ZW5Ubztcbn0vKipcbiAqIFNldHMvZ2V0cyB0aGUgdmFsdWUgb2YgYSBzdHlsZSBwcm9wZXJ0eS4gSW4gZ2V0dGVyIG1vZGUgdGhlIGNvbXB1dGVkIHByb3BlcnR5IG9mXG4gKiB0aGUgc3R5bGUgd2lsbCBiZSByZXR1cm5lZCB1bmxlc3MgdGhlIGVsZW1lbnQgaXMgbm90IGluc2VydGVkIGludG8gdGhlIERPTS4gSW5cbiAqIHdlYmtpdCBicm93c2VycyBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBvZiBhIGRldGFjaGVkIG5vZGUgYXJlIGFsd2F5cyBhbiBlbXB0eVxuICogc3RyaW5nIGJ1dCBpbiBnZWNrbyB0aGV5IHJlZmxlY3Qgb24gdGhlIGFjdHVhbCBjb21wdXRlZCB2YWx1ZSwgaGVuY2Ugd2UgbmVlZFxuICogdG8gXCJub3JtYWxpemVcIiB0aGlzIGJlaGF2aW9yIGFuZCBtYWtlIHN1cmUgdGhhdCBldmVuIG9uIGdlY2tvIGFuIGVtcHR5IHN0cmluZ1xuICogaXMgcmV0dXJuZWRcbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5cbnZhciBzdHlsZSA9IGZ1bmN0aW9uIHN0eWxlKHByb3BlcnR5KSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGFyZ3MsIGksIGtleSwga2V5cywgcmVzdWx0LCB2YWx1ZTtcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGlmIChJUyQxLnN0cmluZyhwcm9wZXJ0eSkpIHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nID8gYXJnc1sxXS5jYWxsKHRoaXMsIHRoaXMucmVsYXRlZCkgOiBhcmdzWzFdO1xuXG4gICAgaWYgKGFyZ3NbMV0gPT09IG51bGwgJiYgSVMkMS5kZWZpbmVkKHRoaXMuY3VycmVudFN0YXRlU3R5bGUocHJvcGVydHkpKSAmJiAhSVMkMVtcImZ1bmN0aW9uXCJdKHRoaXMuY3VycmVudFN0YXRlU3R5bGUocHJvcGVydHkpKSkge1xuICAgICAgdmFsdWUgPSBDU1MuVU5TRVQ7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQ1NTKF90aGlzLmVsLCBwcm9wZXJ0eSwgdmFsdWUsIF90aGlzLm9wdGlvbnMuZm9yY2VTdHlsZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gQ1NTKHRoaXMuZWwsIHByb3BlcnR5LCB2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcmNlU3R5bGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmICh0aGlzLl9pbnNlcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KHByb3BlcnR5KSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0eSk7XG4gICAgaSA9IC0xO1xuXG4gICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgdGhpcy5zdHlsZShrZXksIHByb3BlcnR5W2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSB0aGUgdmFsdWUgZm9yIGEgZ2l2ZW4gcHJvcGVydHkgaW4gdGhlIGZvbGxvd2luZyBvcmRlciBpZiBlYWNoIG9uZSBpc24ndCBhIHZhbGlkIHZhbHVlOlxuICogMS4gZnJvbSBjb21wdXRlZCBzdHlsZSAoZm9yIGRvbS1pbnNlcnRlZCBlbHMpXG4gKiAyLiBmcm9tIERPTUVsZW1lbnQuc3R5bGUgb2JqZWN0IChmb3Igbm9uLWluc2VydGVkIGVsczsgaWYgb3B0aW9ucy5zdHlsZUFmdGVySW5zZXJ0LCB3aWxsIG9ubHkgaGF2ZSBzdGF0ZSBzdHlsZXMpXG4gKiAzLiBmcm9tIHByb3ZpZGVkIHN0eWxlIG9wdGlvbnNcbiAqIChmb3Igbm9uLWluc2VydGVkIGVsczsgY2hlY2tpbmcgb25seSAkYmFzZSBzaW5jZSBzdGF0ZSBzdHlsZXMgd2lsbCBhbHdheXMgYmUgYXBwbGllZCB0byB0aGUgc3R5bGUgb2JqZWN0IGV2ZW4gZm9yIG5vbi1pbnNlcnRlZClcbiAqL1xuXG52YXIgc3R5bGVTYWZlID0gZnVuY3Rpb24gc3R5bGVTYWZlKHByb3BlcnR5LCBza2lwQ29tcHV0ZWQpIHtcbiAgdmFyIGNvbXB1dGVkLCByZXN1bHQsIHNhbXBsZTtcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzYW1wbGUgPSB0aGlzLmVsLnN0eWxlW3Byb3BlcnR5XTtcblxuICBpZiAoSVMkMS5zdHJpbmcoc2FtcGxlKSB8fCBJUyQxLm51bWJlcihzYW1wbGUpKSB7XG4gICAgY29tcHV0ZWQgPSBza2lwQ29tcHV0ZWQgPyAwIDogdGhpcy5zdHlsZShwcm9wZXJ0eSk7XG4gICAgcmVzdWx0ID0gY29tcHV0ZWQgfHwgdGhpcy5lbC5zdHlsZVtwcm9wZXJ0eV0gfHwgdGhpcy5jdXJyZW50U3RhdGVTdHlsZShwcm9wZXJ0eSkgfHwgJyc7XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIHRoaXMucmVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHN0eWxlUGFyc2VkID0gZnVuY3Rpb24gc3R5bGVQYXJzZWQocHJvcGVydHksIHNraXBDb21wdXRlZCkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnN0eWxlU2FmZShwcm9wZXJ0eSwgc2tpcENvbXB1dGVkKSk7XG59O1xudmFyIHJlY2FsY1N0eWxlID0gZnVuY3Rpb24gcmVjYWxjU3R5bGUocmVjYWxjQ2hpbGRyZW4pIHtcbiAgdmFyIGNoaWxkLCBqLCBsZW4sIHJlZiwgdGFyZ2V0U3R5bGVzO1xuICB0YXJnZXRTdHlsZXMgPSB0aGlzLl9yZXNvbHZlRm5TdHlsZXModGhpcy5fZ2V0QWN0aXZlU3RhdGVzKCksIHRydWUpO1xuICB0aGlzLnN0eWxlKHRhcmdldFN0eWxlcyk7XG5cbiAgaWYgKHJlY2FsY0NoaWxkcmVuKSB7XG4gICAgcmVmID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgY2hpbGQucmVjYWxjU3R5bGUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgY3VycmVudFN0YXRlU3R5bGUgPSBmdW5jdGlvbiBjdXJyZW50U3RhdGVTdHlsZShwcm9wZXJ0eSkge1xuICB2YXIgaSwgc3RhdGUsIHN0YXRlcztcblxuICBpZiAocHJvcGVydHkpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUubGVuZ3RoKSB7XG4gICAgICBzdGF0ZXMgPSB0aGlzLl9zdGF0ZS5zbGljZSgpO1xuXG4gICAgICBpZiAodGhpcy5fc3RhdGVTaGFyZWQgJiYgdGhpcy5fc3RhdGVTaGFyZWQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfc3RhdGVzO1xuXG4gICAgICAgIChfc3RhdGVzID0gc3RhdGVzKS5wdXNoLmFwcGx5KF9zdGF0ZXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdGF0ZVNoYXJlZCkpO1xuICAgICAgfVxuXG4gICAgICBpID0gc3RhdGVzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHN0YXRlID0gc3RhdGVzWy0taV0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlc1tzdGF0ZV0gJiYgSVMkMS5kZWZpbmVkKHRoaXMuX3N0eWxlc1tzdGF0ZV0ucnVsZVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlc1tzdGF0ZV0ucnVsZVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3R5bGVzLmJhc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZXMuYmFzZS5ydWxlW3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbn07XG52YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcbn07XG52YXIgc2hvdyA9IGZ1bmN0aW9uIHNob3coZGlzcGxheSkge1xuICB2YXIgcmVmO1xuXG4gIGlmICghZGlzcGxheSkge1xuICAgIGRpc3BsYXkgPSB0aGlzLmN1cnJlbnRTdGF0ZVN0eWxlKCdkaXNwbGF5Jyk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gJ25vbmUnIHx8ICFkaXNwbGF5KSB7XG4gICAgICBkaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG4gIH1cblxuICBpZiAoZGlzcGxheSA9PSBudWxsKSB7XG4gICAgZGlzcGxheSA9ICgocmVmID0gdGhpcy5fc3R5bGVzLmJhc2UpICE9IG51bGwgPyByZWYuZGlzcGxheSA6IHZvaWQgMCkgfHwgJ2Jsb2NrJztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgZGlzcGxheSk7XG59O1xudmFyIG9yaWVudGF0aW9uR2V0dGVyID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gJ2xhbmRzY2FwZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncG9ydHJhaXQnO1xuICAgIH1cbiAgfVxufTtcbnZhciBhc3BlY3RSYXRpb0dldHRlciA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0eWxlJDEgKFF1aWNrRWxlbWVudCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja0VsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgJ29yaWVudGF0aW9uJzogb3JpZW50YXRpb25HZXR0ZXIsXG4gICAgJ2FzcGVjdFJhdGlvJzogYXNwZWN0UmF0aW9HZXR0ZXIsXG4gICAgJ3JlY3QnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnd2lkdGgnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5zdHlsZSgnd2lkdGgnKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ3dpZHRoJywgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2hlaWdodCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnN0eWxlKCdoZWlnaHQnKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2hlaWdodCcsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnN0eWxlID0gc3R5bGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc3R5bGVTYWZlID0gc3R5bGVTYWZlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnN0eWxlUGFyc2VkID0gc3R5bGVQYXJzZWQ7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVjYWxjU3R5bGUgPSByZWNhbGNTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5jdXJyZW50U3RhdGVTdHlsZSA9IGN1cnJlbnRTdGF0ZVN0eWxlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBoaWRlO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zaG93ID0gc2hvdztcbn12YXIgUXVpY2tXaW5kb3ckMTtcbnZhciBRdWlja1dpbmRvdyQyID0gUXVpY2tXaW5kb3ckMSA9IHtcbiAgdHlwZTogJ3dpbmRvdycsXG4gIGVsOiB3aW5kb3csXG4gIHJhdzogd2luZG93LFxuICBfZXZlbnRDYWxsYmFja3M6IHtcbiAgICBfX3JlZnM6IHt9XG4gIH1cbn07XG5RdWlja1dpbmRvdyQxLm9uID0gb25fO1xuUXVpY2tXaW5kb3ckMS5vZmYgPSBvZmZfO1xuUXVpY2tXaW5kb3ckMS5lbWl0ID0gZW1pdDtcblF1aWNrV2luZG93JDEuZW1pdFByaXZhdGUgPSBlbWl0UHJpdmF0ZTtcblF1aWNrV2luZG93JDEuX2xpc3RlblRvID0gX2xpc3RlblRvO1xuUXVpY2tXaW5kb3ckMS5faW52b2tlSGFuZGxlcnMgPSBfaW52b2tlSGFuZGxlcnM7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja1dpbmRvdyQxLCB7XG4gICd3aWR0aCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG4gIH0sXG4gICdoZWlnaHQnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgfSxcbiAgJ29yaWVudGF0aW9uJzogb3JpZW50YXRpb25HZXR0ZXIsXG4gICdhc3BlY3RSYXRpbyc6IGFzcGVjdFJhdGlvR2V0dGVyXG59KTt2YXIgTWVkaWFRdWVyeSwgUlVMRV9ERUlMSU1JVEVSO1xuUlVMRV9ERUlMSU1JVEVSID0gLyxcXHMqLztcbnZhciBNZWRpYVF1ZXJ5JDEgPSBNZWRpYVF1ZXJ5ID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcywgdGVzdFJ1bGU7XG4gIGNhbGxiYWNrcyA9IFtdO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFjaywgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnBhcnNlUXVlcnkgPSBmdW5jdGlvbiAodGFyZ2V0LCBxdWVyeVN0cmluZykge1xuICAgIHZhciBxdWVyeVNwbGl0LCBydWxlcywgc291cmNlO1xuICAgIHF1ZXJ5U3BsaXQgPSBxdWVyeVN0cmluZy5zcGxpdCgnKCcpO1xuICAgIHNvdXJjZSA9IHF1ZXJ5U3BsaXRbMF07XG5cbiAgICBzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICAgIHJldHVybiBRdWlja1dpbmRvdyQyO1xuXG4gICAgICAgIGNhc2UgJ3BhcmVudCc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5wYXJlbnQ7XG5cbiAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0YXJnZXQucGFyZW50TWF0Y2hpbmcoZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5yZWYgPT09IHNvdXJjZS5zbGljZSgxKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KCk7XG5cbiAgICBydWxlcyA9IHF1ZXJ5U3BsaXRbMV0uc2xpY2UoMCwgLTEpLnNwbGl0KFJVTEVfREVJTElNSVRFUikubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICB2YXIgZ2V0dGVyLCBrZXksIGtleVByZWZpeCwgbWF4LCBtaW4sIHNwbGl0LCB2YWx1ZTtcbiAgICAgIHNwbGl0ID0gcnVsZS5zcGxpdCgnOicpO1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHNwbGl0WzFdKTtcblxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBzcGxpdFswXTtcbiAgICAgIGtleVByZWZpeCA9IGtleS5zbGljZSgwLCA0KTtcbiAgICAgIG1heCA9IGtleVByZWZpeCA9PT0gJ21heC0nO1xuICAgICAgbWluID0gIW1heCAmJiBrZXlQcmVmaXggPT09ICdtaW4tJztcblxuICAgICAgaWYgKG1heCB8fCBtaW4pIHtcbiAgICAgICAga2V5ID0ga2V5LnNsaWNlKDQpO1xuICAgICAgfVxuXG4gICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnb3JpZW50YXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICdhc3BlY3QtcmF0aW8nOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5hc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlZFZhbHVlLCBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzb3VyY2Uuc3R5bGUoa2V5KTtcbiAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHN0cmluZ1ZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgIGdldHRlcjogZ2V0dGVyXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHJ1bGVzOiBydWxlc1xuICAgIH07XG4gIH07XG5cbiAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIGNhbGxiYWNrLCBxdWVyeTtcbiAgICBxdWVyeSA9IHRoaXMucGFyc2VRdWVyeSh0YXJnZXQsIHF1ZXJ5U3RyaW5nKTtcblxuICAgIGlmIChxdWVyeS5zb3VyY2UpIHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0ZXN0UnVsZSh0YXJnZXQsIHF1ZXJ5LCBxdWVyeVN0cmluZyk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9O1xuXG4gIHRlc3RSdWxlID0gZnVuY3Rpb24gdGVzdFJ1bGUodGFyZ2V0LCBxdWVyeSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlLCBpLCBsZW4sIHBhc3NlZCwgcmVmLCBydWxlO1xuICAgIHBhc3NlZCA9IHRydWU7XG4gICAgcmVmID0gcXVlcnkucnVsZXM7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJ1bGUgPSByZWZbaV07XG4gICAgICBjdXJyZW50VmFsdWUgPSBydWxlLmdldHRlcigpO1xuXG4gICAgICBwYXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICBjYXNlICFydWxlLm1pbjpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPj0gcnVsZS52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgIXJ1bGUubWF4OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA8PSBydWxlLnZhbHVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHJ1bGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCFwYXNzZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zdGF0ZShxdWVyeVN0cmluZywgcGFzc2VkKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn0oKTt2YXIgU3RhdGVDaGFpbjtcbnZhciBTdGF0ZUNoYWluJDEgPSBTdGF0ZUNoYWluID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGVDaGFpbihzdGF0ZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGVDaGFpbik7XG5cbiAgICB0aGlzLnN0cmluZyA9IHN0YXRlcy5qb2luKCcrJyk7XG4gICAgdGhpcy5hcnJheSA9IHN0YXRlcy5zbGljZSgpO1xuICAgIHRoaXMubGVuZ3RoID0gc3RhdGVzLmxlbmd0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGF0ZUNoYWluLCBbe1xuICAgIGtleTogXCJpbmNsdWRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlcyh0YXJnZXQpIHtcbiAgICAgIHZhciBpLCBsZW4sIHJlZiwgc3RhdGU7XG4gICAgICByZWYgPSB0aGlzLmFycmF5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSByZWZbaV07XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aG91dCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5LmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlICE9PSB0YXJnZXQ7XG4gICAgICB9KS5qb2luKCcrJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQXBwbGljYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FwcGxpY2FibGUodGFyZ2V0LCBvdGhlckFjdGl2ZSkge1xuICAgICAgdmFyIGFjdGl2ZTtcbiAgICAgIGFjdGl2ZSA9IHRoaXMuYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IHRhcmdldCB8fCBvdGhlckFjdGl2ZS5pbmRleE9mKHN0YXRlKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RpdmUubGVuZ3RoID09PSB0aGlzLmFycmF5Lmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RhdGVDaGFpbjtcbn0oKTt2YXIgQkFTRV9TVEFURV9UUklHR0VSUywgQ0FDSEVEX0ZOX0lOU0VSVEVEO1xuQkFTRV9TVEFURV9UUklHR0VSUyA9IHtcbiAgJ2hvdmVyJzoge1xuICAgIG9uOiAnbW91c2VlbnRlcicsXG4gICAgb2ZmOiAnbW91c2VsZWF2ZScsXG4gICAgYnViYmxlczogdHJ1ZVxuICB9LFxuICAnZm9jdXMnOiB7XG4gICAgb246ICdmb2N1cycsXG4gICAgb2ZmOiAnYmx1cicsXG4gICAgYnViYmxlczogdHJ1ZVxuICB9XG59O1xudmFyIF9ub3JtYWxpemVPcHRpb25zID0gZnVuY3Rpb24gX25vcm1hbGl6ZU9wdGlvbnMoKSB7XG4gIHZhciBiYXNlMSwgYmFzZTIsIGJhc2UzLCBiYXNlNCwgYmFzZTU7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5yZWxhdGVkSW5zdGFuY2UpIHtcbiAgICAoYmFzZTEgPSB0aGlzLm9wdGlvbnMpLnJlbGF0ZWQgfHwgKGJhc2UxLnJlbGF0ZWQgPSB0aGlzLm9wdGlvbnMucmVsYXRlZEluc3RhbmNlKTtcbiAgICB0aGlzLm9wdGlvbnMucmVsYXRlZEluc3RhbmNlID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMucmVsYXRlZCA9IChiYXNlMiA9IHRoaXMub3B0aW9ucykucmVsYXRlZCAhPSBudWxsID8gYmFzZTIucmVsYXRlZCA6IGJhc2UyLnJlbGF0ZWQgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9wdGlvbnNbXCJjbGFzc1wiXSkge1xuICAgIHRoaXMub3B0aW9ucy5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnNbXCJjbGFzc1wiXTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMudXJsKSB7XG4gICAgdGhpcy5vcHRpb25zLmhyZWYgPSB0aGlzLm9wdGlvbnMudXJsO1xuICB9XG5cbiAgaWYgKChiYXNlMyA9IHRoaXMub3B0aW9ucykudW5wYXNzYWJsZVN0YXRlcyA9PSBudWxsKSB7XG4gICAgYmFzZTMudW5wYXNzYWJsZVN0YXRlcyA9IFtdO1xuICB9XG5cbiAgaWYgKChiYXNlNCA9IHRoaXMub3B0aW9ucykucGFzc1N0YXRlVG9DaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgYmFzZTQucGFzc1N0YXRlVG9DaGlsZHJlbiA9IHRydWU7XG4gIH1cblxuICBpZiAoKGJhc2U1ID0gdGhpcy5vcHRpb25zKS5wYXNzRGF0YVRvQ2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIGJhc2U1LnBhc3NEYXRhVG9DaGlsZHJlbiA9IHRydWU7XG4gIH1cblxuICB0aGlzLm9wdGlvbnMuc3RhdGVUcmlnZ2VycyA9IHRoaXMub3B0aW9ucy5zdGF0ZVRyaWdnZXJzID8gZXh0ZW5kLmNsb25lLmRlZXAoQkFTRV9TVEFURV9UUklHR0VSUywgdGhpcy5vcHRpb25zLnN0YXRlVHJpZ2dlcnMpIDogQkFTRV9TVEFURV9UUklHR0VSUztcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICBleHRlbmQodGhpcywgdGhpcy5fcGFyc2VUZXh0cyh0aGlzLm9wdGlvbnMudGV4dCwgdGhpcy5fdGV4dHMpKTtcbiAgfSBlbHNlIHtcbiAgICBleHRlbmQodGhpcywgdGhpcy5fcGFyc2VTdHlsZXModGhpcy5vcHRpb25zLnN0eWxlLCB0aGlzLl9zdHlsZXMpKTtcbiAgfVxufTtcbnZhciBfcGFyc2VTdHlsZXMgPSBmdW5jdGlvbiBfcGFyc2VTdHlsZXMoc3R5bGVzLCBzdG9yZSkge1xuICB2YXIgX21lZGlhU3RhdGVzLCBfcHJvdmlkZWRTdGF0ZXMsIF9wcm92aWRlZFN0YXRlc1NoYXJlZCwgX3N0YXRlU2hhcmVkLCBfc3R5bGVzLCBiYXNlLCBfZmxhdHRlbk5lc3RlZFN0YXRlcywgZm9yY2VTdHlsZSwgaSwga2V5cywgbGVuLCBzcGVjaWFsU3RhdGVzLCBzdGF0ZSwgc3RhdGVTdHlsZXMsIHN0YXRlXywgc3RhdGVzO1xuXG4gIGlmICghSVMkMS5vYmplY3RQbGFpbihzdHlsZXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyk7XG4gIHN0YXRlcyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaXNTdGF0ZVN0eWxlKGtleSk7XG4gIH0pO1xuICBzcGVjaWFsU3RhdGVzID0gcmVtb3ZlSXRlbShzdGF0ZXMuc2xpY2UoKSwgJyRiYXNlJyk7XG4gIF9tZWRpYVN0YXRlcyA9IHN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXlbMF0gPT09ICdAJztcbiAgfSkubWFwKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zbGljZSgxKTtcbiAgfSk7XG4gIF9wcm92aWRlZFN0YXRlcyA9IHN0YXRlcy5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnNsaWNlKDEpOyAvLyBSZW1vdmUgJyQnIHByZWZpeFxuICB9KTtcbiAgX3N0eWxlcyA9IHN0b3JlIHx8IHt9O1xuICBfc3RhdGVTaGFyZWQgPSBfcHJvdmlkZWRTdGF0ZXNTaGFyZWQgPSB2b2lkIDA7XG4gIGJhc2UgPSAhaW5jbHVkZXMoc3RhdGVzLCAnJGJhc2UnKSA/IHN0eWxlcyA6IHN0eWxlcy4kYmFzZTtcbiAgX3N0eWxlcy5iYXNlID0gcmVnaXN0ZXJTdHlsZShiYXNlLCAwLCBmb3JjZVN0eWxlID0gdGhpcy5vcHRpb25zLmZvcmNlU3R5bGUpO1xuXG4gIGlmIChzcGVjaWFsU3RhdGVzLmxlbmd0aCkge1xuICAgIF9mbGF0dGVuTmVzdGVkU3RhdGVzID0gZnVuY3Rpb24gZmxhdHRlbk5lc3RlZFN0YXRlcyhzdHlsZU9iamVjdCwgY2hhaW4sIGxldmVsKSB7XG4gICAgICB2YXIgaGFzTm9uU3RhdGVQcm9wcywgaSwgbGVuLCBvdXRwdXQsIHN0YXRlLCBzdGF0ZUNoYWluLCBzdGF0ZV8sIHN0eWxlS2V5cztcbiAgICAgIHN0eWxlS2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlT2JqZWN0KTtcbiAgICAgIG91dHB1dCA9IHt9O1xuICAgICAgaGFzTm9uU3RhdGVQcm9wcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHlsZUtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSBzdHlsZUtleXNbaV07XG5cbiAgICAgICAgaWYgKCFpc1N0YXRlU3R5bGUoc3RhdGUpKSB7XG4gICAgICAgICAgaGFzTm9uU3RhdGVQcm9wcyA9IHRydWU7XG4gICAgICAgICAgb3V0cHV0W3N0YXRlXSA9IHN0eWxlT2JqZWN0W3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFpbi5wdXNoKHN0YXRlXyA9IHN0YXRlLnNsaWNlKDEpKTtcbiAgICAgICAgICBzdGF0ZUNoYWluID0gbmV3IFN0YXRlQ2hhaW4kMShjaGFpbik7XG5cbiAgICAgICAgICBpZiAoX3N0YXRlU2hhcmVkID09IG51bGwpIHtcbiAgICAgICAgICAgIF9zdGF0ZVNoYXJlZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfcHJvdmlkZWRTdGF0ZXNTaGFyZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3Byb3ZpZGVkU3RhdGVzU2hhcmVkLnB1c2goc3RhdGVDaGFpbik7XG5cbiAgICAgICAgICBpZiAoc3RhdGVbMF0gPT09ICdAJykge1xuICAgICAgICAgICAgX21lZGlhU3RhdGVzLnB1c2goc3RhdGVfKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfc3R5bGVzW3N0YXRlQ2hhaW4uc3RyaW5nXSA9IHJlZ2lzdGVyU3R5bGUoX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMoc3R5bGVPYmplY3Rbc3RhdGVdLCBjaGFpbiwgbGV2ZWwgKyAxKSwgbGV2ZWwgKyAxLCBmb3JjZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTm9uU3RhdGVQcm9wcykge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzcGVjaWFsU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdGF0ZSA9IHNwZWNpYWxTdGF0ZXNbaV07XG4gICAgICBzdGF0ZV8gPSBzdGF0ZS5zbGljZSgxKTtcbiAgICAgIHN0YXRlU3R5bGVzID0gX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMoc3R5bGVzW3N0YXRlXSwgW3N0YXRlX10sIDEpO1xuXG4gICAgICBpZiAoc3RhdGVTdHlsZXMpIHtcbiAgICAgICAgX3N0eWxlc1tzdGF0ZV9dID0gcmVnaXN0ZXJTdHlsZShzdGF0ZVN0eWxlcywgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfc3R5bGVzOiBfc3R5bGVzLFxuICAgIF9tZWRpYVN0YXRlczogX21lZGlhU3RhdGVzLFxuICAgIF9zdGF0ZVNoYXJlZDogX3N0YXRlU2hhcmVkLFxuICAgIF9wcm92aWRlZFN0YXRlczogX3Byb3ZpZGVkU3RhdGVzLFxuICAgIF9wcm92aWRlZFN0YXRlc1NoYXJlZDogX3Byb3ZpZGVkU3RhdGVzU2hhcmVkXG4gIH07XG59O1xudmFyIF9wYXJzZVRleHRzID0gZnVuY3Rpb24gX3BhcnNlVGV4dHModGV4dHMsIHN0b3JlKSB7XG4gIHZhciBfcHJvdmlkZWRTdGF0ZXMsIF90ZXh0cywgaSwgbGVuLCBzdGF0ZSwgc3RhdGVzO1xuXG4gIGlmICghSVMkMS5vYmplY3RQbGFpbih0ZXh0cykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZXMgPSBPYmplY3Qua2V5cyh0ZXh0cykubWFwKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5zbGljZSgxKTtcbiAgfSk7XG4gIF9wcm92aWRlZFN0YXRlcyA9IHN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlICE9PSAnYmFzZSc7XG4gIH0pO1xuICBfdGV4dHMgPSBzdG9yZSB8fCB7fTtcbiAgX3RleHRzID0ge1xuICAgIGJhc2U6ICcnXG4gIH07XG5cbiAgZm9yIChpID0gMCwgbGVuID0gc3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgX3RleHRzW3N0YXRlXSA9IHRleHRzWyckJyArIHN0YXRlXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX3RleHRzOiBfdGV4dHMsXG4gICAgX3Byb3ZpZGVkU3RhdGVzOiBfcHJvdmlkZWRTdGF0ZXNcbiAgfTtcbn07XG52YXIgX2FwcGx5T3B0aW9ucyA9IGZ1bmN0aW9uIF9hcHBseU9wdGlvbnMoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGV2ZW50LCBoYW5kbGVyLCBtZXRob2QsIHJlZiwgcmVmMSwgcmVmMiwgdmFsdWU7XG5cbiAgaWYgKHJlZiA9IHRoaXMub3B0aW9ucy5pZCB8fCB0aGlzLm9wdGlvbnMucmVmKSB7XG4gICAgdGhpcy5hdHRyKCdkYXRhLXJlZicsIHRoaXMucmVmID0gcmVmKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuaWQpIHtcbiAgICB0aGlzLmVsLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHtcbiAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5jbGFzc05hbWU7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnNyYykge1xuICAgIHRoaXMuZWwuc3JjID0gdGhpcy5vcHRpb25zLnNyYztcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuaHJlZikge1xuICAgIHRoaXMuZWwuaHJlZiA9IHRoaXMub3B0aW9ucy5ocmVmO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgdGhpcy5lbC50eXBlID0gdGhpcy5vcHRpb25zLnR5cGU7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLm5hbWUpIHtcbiAgICB0aGlzLmVsLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMudmFsdWUpIHtcbiAgICB0aGlzLmVsLnZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RlZCkge1xuICAgIHRoaXMuZWwuc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWQ7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmNoZWNrZWQpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSB0aGlzLm9wdGlvbnMuY2hlY2tlZDtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucHJvcHMpIHtcbiAgICB0aGlzLnByb3AodGhpcy5vcHRpb25zLnByb3BzKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuYXR0cnMpIHtcbiAgICB0aGlzLmF0dHIodGhpcy5vcHRpb25zLmF0dHJzKTtcbiAgfVxuXG4gIHRoaXMuX2FwcGx5UmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlcy5iYXNlLCBudWxsLCBudWxsLCB0aGlzLm9wdGlvbnMuc3R5bGVBZnRlckluc2VydCk7XG5cbiAgaWYgKHRoaXMuX3RleHRzKSB7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dHMuYmFzZTtcbiAgfVxuXG4gIHRoaXMub24oJ2luc2VydGVkJywgQ0FDSEVEX0ZOX0lOU0VSVEVELCBmYWxzZSwgdHJ1ZSk7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5pbnZva2VDb21wdXRlcnNPbmNlKSB7XG4gICAgdGhpcy5faW52b2tlZENvbXB1dGVycyA9IHt9O1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5yZWNhbGNPblJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVjYWxjU3R5bGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZXZlbnRzKSB7XG4gICAgcmVmMSA9IHRoaXMub3B0aW9ucy5ldmVudHM7XG5cbiAgICBmb3IgKGV2ZW50IGluIHJlZjEpIHtcbiAgICAgIGhhbmRsZXIgPSByZWYxW2V2ZW50XTtcbiAgICAgIHRoaXMub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMubWV0aG9kcykge1xuICAgIHJlZjIgPSB0aGlzLm9wdGlvbnMubWV0aG9kcztcblxuICAgIGZvciAobWV0aG9kIGluIHJlZjIpIHtcbiAgICAgIHZhbHVlID0gcmVmMlttZXRob2RdO1xuXG4gICAgICBpZiAoIXRoaXNbbWV0aG9kXSkge1xuICAgICAgICBpZiAoSVMkMVtcImZ1bmN0aW9uXCJdKHZhbHVlKSkge1xuICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBtZXRob2QsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogdmFsdWUuZ2V0LFxuICAgICAgICAgICAgc2V0OiB2YWx1ZS5zZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0JyAmJiBJUyQxLm9iamVjdCh0aGlzLm9wdGlvbnMudGV4dCkpIHtcbiAgICB0aGlzLmFwcGVuZChfcXVpY2tkb20oJ3RleHQnLCB7XG4gICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMudGV4dFxuICAgIH0pKTtcbiAgfVxufTtcbnZhciBfcG9zdENyZWF0aW9uID0gZnVuY3Rpb24gX3Bvc3RDcmVhdGlvbihkYXRhKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuY29tcHV0ZXJzKSB7XG4gICAgaWYgKGRhdGEgJiYgdGhpcy5vcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBleHRlbmQuY2xvbmUodGhpcy5vcHRpb25zLmRhdGEsIGRhdGEpO1xuICAgIH1cblxuICAgIGRhdGEgfHwgKGRhdGEgPSB0aGlzLm9wdGlvbnMuZGF0YSk7XG4gICAgdGhpcy5hcHBseURhdGEoZGF0YSwgZmFsc2UpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wdXRlcnMuX2luaXQpIHtcbiAgICAgIHRoaXMuX3J1bkNvbXB1dGVyKCdfaW5pdCcsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlKHRoaXMub3B0aW9ucy5zdGF0ZSk7XG4gIH1cbn07XG52YXIgX2F0dGFjaFN0YXRlRXZlbnRzID0gZnVuY3Rpb24gX2F0dGFjaFN0YXRlRXZlbnRzKGZvcmNlKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZXM7XG4gIHN0YXRlcyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zdGF0ZVRyaWdnZXJzKTtcbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGRpc2FibGVyLCBlbmFibGVyLCB0cmlnZ2VyO1xuICAgIHRyaWdnZXIgPSBfdGhpczIub3B0aW9ucy5zdGF0ZVRyaWdnZXJzW3N0YXRlXTtcblxuICAgIGlmICghaW5jbHVkZXMoX3RoaXMyLl9wcm92aWRlZFN0YXRlcywgc3RhdGUpICYmICFmb3JjZSAmJiAhdHJpZ2dlci5mb3JjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVuYWJsZXIgPSBJUyQxLnN0cmluZyh0cmlnZ2VyKSA/IHRyaWdnZXIgOiB0cmlnZ2VyLm9uO1xuXG4gICAgaWYgKElTJDEub2JqZWN0KHRyaWdnZXIpKSB7XG4gICAgICBkaXNhYmxlciA9IHRyaWdnZXIub2ZmO1xuICAgIH1cblxuICAgIF90aGlzMi5fbGlzdGVuVG8oZW5hYmxlciwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5zdGF0ZShzdGF0ZSwgdHJ1ZSwgdHJpZ2dlci5idWJibGVzKTtcbiAgICB9KTtcblxuICAgIGlmIChkaXNhYmxlcikge1xuICAgICAgcmV0dXJuIF90aGlzMi5fbGlzdGVuVG8oZGlzYWJsZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5zdGF0ZShzdGF0ZSwgZmFsc2UsIHRyaWdnZXIuYnViYmxlcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBfcHJveHlQYXJlbnQgPSBmdW5jdGlvbiBfcHJveHlQYXJlbnQoKSB7XG4gIHZhciBwYXJlbnQ7XG4gIHBhcmVudCA9IHZvaWQgMDtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3BhcmVudCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdQYXJlbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgbGFzdFBhcmVudDtcblxuICAgICAgaWYgKHBhcmVudCA9IG5ld1BhcmVudCkge1xuICAgICAgICBsYXN0UGFyZW50ID0gdGhpcy5wYXJlbnRzLnNsaWNlKC0xKVswXTtcblxuICAgICAgICBpZiAobGFzdFBhcmVudC5yYXcgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX3VucHJveHlQYXJlbnQobmV3UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnQub24oJ2luc2VydGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbmV3UGFyZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3VucHJveHlQYXJlbnQobmV3UGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xudmFyIF91bnByb3h5UGFyZW50ID0gZnVuY3Rpb24gX3VucHJveHlQYXJlbnQobmV3UGFyZW50KSB7XG4gIGRlbGV0ZSB0aGlzLl9wYXJlbnQ7XG4gIHRoaXMuX3BhcmVudCA9IG5ld1BhcmVudDtcbiAgdGhpcy5lbWl0UHJpdmF0ZSgnaW5zZXJ0ZWQnLCBuZXdQYXJlbnQpO1xufTtcblxuQ0FDSEVEX0ZOX0lOU0VSVEVEID0gZnVuY3Rpb24gQ0FDSEVEX0ZOX0lOU0VSVEVEKCkge1xuICB2YXIgaSwgbGVuLCBtZWRpYVN0YXRlcywgcXVlcnlTdHJpbmcsIHJlc3VsdHM7XG4gIHRoaXMuX2luc2VydGVkID0gdGhpcztcblxuICBpZiAodGhpcy5vcHRpb25zLnN0eWxlQWZ0ZXJJbnNlcnQpIHtcbiAgICB0aGlzLnJlY2FsY1N0eWxlKCk7XG4gIH1cblxuICBpZiAoKG1lZGlhU3RhdGVzID0gdGhpcy5fbWVkaWFTdGF0ZXMpICYmIHRoaXMuX21lZGlhU3RhdGVzLmxlbmd0aCkge1xuICAgIHRoaXMuX21lZGlhU3RhdGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBtZWRpYVN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcXVlcnlTdHJpbmcgPSBtZWRpYVN0YXRlc1tpXTtcbiAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9tZWRpYVN0YXRlc1txdWVyeVN0cmluZ10gPSBNZWRpYVF1ZXJ5JDEucmVnaXN0ZXIodGhpcywgcXVlcnlTdHJpbmcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5pdCQxIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fbm9ybWFsaXplT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRpb25zO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9wYXJzZVN0eWxlcyA9IF9wYXJzZVN0eWxlcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcGFyc2VUZXh0cyA9IF9wYXJzZVRleHRzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9hcHBseU9wdGlvbnMgPSBfYXBwbHlPcHRpb25zO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9wb3N0Q3JlYXRpb24gPSBfcG9zdENyZWF0aW9uO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9hdHRhY2hTdGF0ZUV2ZW50cyA9IF9hdHRhY2hTdGF0ZUV2ZW50cztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcHJveHlQYXJlbnQgPSBfcHJveHlQYXJlbnQ7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl91bnByb3h5UGFyZW50ID0gX3VucHJveHlQYXJlbnQ7XG59ZnVuY3Rpb24gYWxpYXNlcyAoUXVpY2tFbGVtZW50KSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja0VsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgJ3Jhdyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICcwJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2Nzcyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdyZXBsYWNlV2l0aCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3JlbW92ZUxpc3RlbmVyJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufXZhciBwYXJlbnRzVW50aWwgPSBmdW5jdGlvbiBwYXJlbnRzVW50aWwoZmlsdGVyKSB7XG4gIHJldHVybiBfZ2V0UGFyZW50cyh0aGlzLCBmaWx0ZXIpO1xufTtcbnZhciBwYXJlbnRNYXRjaGluZyA9IGZ1bmN0aW9uIHBhcmVudE1hdGNoaW5nKGZpbHRlcikge1xuICB2YXIgaXNSZWYsIG5leHRQYXJlbnQ7XG5cbiAgaWYgKElTJDFbXCJmdW5jdGlvblwiXShmaWx0ZXIpIHx8IChpc1JlZiA9IElTJDEuc3RyaW5nKGZpbHRlcikpKSB7XG4gICAgbmV4dFBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKG5leHRQYXJlbnQpIHtcbiAgICAgIGlmIChpc1JlZikge1xuICAgICAgICBpZiAobmV4dFBhcmVudC5yZWYgPT09IGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBuZXh0UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsdGVyKG5leHRQYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFBhcmVudCA9IG5leHRQYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufTtcbnZhciBxdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yKSB7XG4gIHJldHVybiBfcXVpY2tkb20odGhpcy5yYXcucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpO1xufTtcbnZhciBxdWVyeUFsbCA9IGZ1bmN0aW9uIHF1ZXJ5QWxsKHNlbGVjdG9yKSB7XG4gIHZhciBpLCBpdGVtLCBsZW4sIG91dHB1dCwgcmVzdWx0O1xuICByZXN1bHQgPSB0aGlzLnJhdy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgb3V0cHV0ID0gW107XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaXRlbSA9IHJlc3VsdFtpXTtcbiAgICBvdXRwdXQucHVzaChpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBfcXVpY2tkb20uYmF0Y2gob3V0cHV0KTtcbn07XG52YXIgX2dldFBhcmVudHMgPSBmdW5jdGlvbiBfZ2V0UGFyZW50cyh0YXJnZXRFbCwgZmlsdGVyKSB7XG4gIHZhciBpc1JlZiwgbmV4dFBhcmVudCwgcGFyZW50cztcblxuICBpZiAoIUlTJDFbXCJmdW5jdGlvblwiXShmaWx0ZXIpICYmICEoaXNSZWYgPSBJUyQxLnN0cmluZyhmaWx0ZXIpKSkge1xuICAgIGZpbHRlciA9IHZvaWQgMDtcbiAgfVxuXG4gIHBhcmVudHMgPSBbXTtcbiAgbmV4dFBhcmVudCA9IHRhcmdldEVsLnBhcmVudDtcblxuICB3aGlsZSAobmV4dFBhcmVudCkge1xuICAgIHBhcmVudHMucHVzaChuZXh0UGFyZW50KTtcbiAgICBuZXh0UGFyZW50ID0gbmV4dFBhcmVudC5wYXJlbnQ7XG5cbiAgICBpZiAoaXNSZWYpIHtcbiAgICAgIGlmIChuZXh0UGFyZW50ICYmIG5leHRQYXJlbnQucmVmID09PSBmaWx0ZXIpIHtcbiAgICAgICAgbmV4dFBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIGlmIChmaWx0ZXIobmV4dFBhcmVudCkpIHtcbiAgICAgICAgbmV4dFBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59O1xudmFyIF9nZXRDaGlsZFJlZnMgPSBmdW5jdGlvbiBfZ2V0Q2hpbGRSZWZzKHRhcmdldCwgZnJlc2hDb3B5KSB7XG4gIHZhciBjaGlsZCwgY2hpbGRSZWZzLCBjaGlsZHJlbiwgZWwsIGksIGxlbiwgcmVmLCByZWZzO1xuXG4gIGlmIChmcmVzaENvcHkgfHwgIXRhcmdldC5fY2hpbGRSZWZzKSB7XG4gICAgdGFyZ2V0Ll9jaGlsZFJlZnMgPSB7fTtcbiAgfVxuXG4gIHJlZnMgPSB0YXJnZXQuX2NoaWxkUmVmcztcblxuICBpZiAodGFyZ2V0LnJlZikge1xuICAgIHJlZnNbdGFyZ2V0LnJlZl0gPSB0YXJnZXQ7XG4gIH1cblxuICBjaGlsZHJlbiA9IHRhcmdldC5jaGlsZHJlbjtcblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjaGlsZFJlZnMgPSBfZ2V0Q2hpbGRSZWZzKGNoaWxkLCBmcmVzaENvcHkpO1xuXG4gICAgICBmb3IgKHJlZiBpbiBjaGlsZFJlZnMpIHtcbiAgICAgICAgZWwgPSBjaGlsZFJlZnNbcmVmXTtcbiAgICAgICAgcmVmc1tyZWZdIHx8IChyZWZzW3JlZl0gPSBlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZnM7XG59O1xudmFyIF9nZXRJbmRleEJ5UHJvcCA9IGZ1bmN0aW9uIF9nZXRJbmRleEJ5UHJvcChtYWluLCBwcm9wKSB7XG4gIHZhciBwYXJlbnQ7XG5cbiAgaWYgKCEocGFyZW50ID0gbWFpbi5wYXJlbnQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGRbcHJvcF0gPT09IG1haW5bcHJvcF07XG4gICAgfSkuaW5kZXhPZihtYWluKTtcbiAgfVxufTtcbnZhciBfZmlsdGVyRWxlbWVudHMgPSBmdW5jdGlvbiBfZmlsdGVyRWxlbWVudHMoYXJyYXkpIHtcbiAgdmFyIGksIGl0ZW0sIGxlbiwgb3V0cHV0O1xuXG4gIGlmICghYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmF2ZXJzaW5nIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5wYXJlbnRzVW50aWwgPSBwYXJlbnRzVW50aWw7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGFyZW50TWF0Y2hpbmcgPSBwYXJlbnRNYXRjaGluZztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5xdWVyeSA9IHF1ZXJ5O1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsID0gcXVlcnlBbGw7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja0VsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgJ2NoaWxkcmVuJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWYxO1xuXG4gICAgICAgIGlmICh0aGlzLmVsLmNoaWxkTm9kZXMubGVuZ3RoICE9PSB0aGlzLl9jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBSZS1jb2xsZWN0IGNoaWxkcmVuXHRcbiAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPSAwOyAvLyBFbXB0eSBvdXQgY2hpbGRyZW4gYXJyYXlcblxuICAgICAgICAgIHJlZjEgPSB0aGlzLmVsLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZjFbaV07XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA8IDQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChfcXVpY2tkb20oY2hpbGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICB9XG4gICAgfSxcbiAgICAnZWxlbWVudENoaWxkcmVuJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcbiAgICAncGFyZW50Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICgoIXRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnQuZWwgIT09IHRoaXMuZWwucGFyZW50Tm9kZSkgJiYgIUlTJDEuZG9tRG9jKHRoaXMuZWwucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcXVpY2tkb20odGhpcy5lbC5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAncGFyZW50cyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2dldFBhcmVudHModGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbmV4dCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3F1aWNrZG9tKHRoaXMuZWwubmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ25leHRFbCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3F1aWNrZG9tKHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICduZXh0RWxBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJFbGVtZW50cyh0aGlzLm5leHRBbGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ25leHRBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nLCBzaWJsaW5ncztcbiAgICAgICAgc2libGluZ3MgPSBbXTtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSBfcXVpY2tkb20odGhpcy5lbC5uZXh0U2libGluZyk7XG5cbiAgICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgc2libGluZ3MucHVzaChuZXh0U2libGluZyk7XG4gICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXYnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLmVsLnByZXZpb3VzU2libGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAncHJldkVsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcXVpY2tkb20odGhpcy5lbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdwcmV2RWxBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJFbGVtZW50cyh0aGlzLnByZXZBbGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXZBbGwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHByZXZTaWJsaW5nLCBzaWJsaW5ncztcbiAgICAgICAgc2libGluZ3MgPSBbXTtcbiAgICAgICAgcHJldlNpYmxpbmcgPSBfcXVpY2tkb20odGhpcy5lbC5wcmV2aW91c1NpYmxpbmcpO1xuXG4gICAgICAgIHdoaWxlIChwcmV2U2libGluZykge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2gocHJldlNpYmxpbmcpO1xuICAgICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcucHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICAgIH1cbiAgICB9LFxuICAgICdzaWJsaW5ncyc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2QWxsLnJldmVyc2UoKS5jb25jYXQodGhpcy5uZXh0QWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdlbGVtZW50U2libGluZ3MnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9maWx0ZXJFbGVtZW50cyh0aGlzLnNpYmxpbmdzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdjaGlsZCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRSZWZzIHx8IF9nZXRDaGlsZFJlZnModGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2hpbGRmJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0Q2hpbGRSZWZzKHRoaXMsIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2ZpcnN0Q2hpbGQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gICAgICB9XG4gICAgfSxcbiAgICAnbGFzdENoaWxkJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5kZXgnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIHBhcmVudDtcblxuICAgICAgICBpZiAoIShwYXJlbnQgPSB0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRleFR5cGUnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbmRleEJ5UHJvcCh0aGlzLCAndHlwZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2luZGV4UmVmJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5kZXhCeVByb3AodGhpcywgJ3JlZicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbl9xdWlja2RvbS5xdWVyeSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIF9xdWlja2RvbShkb2N1bWVudCkucXVlcnkodGFyZ2V0KTtcbn07XG5cbl9xdWlja2RvbS5xdWVyeUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIF9xdWlja2RvbShkb2N1bWVudCkucXVlcnlBbGwodGFyZ2V0KTtcbn07dmFyIERVTU1ZX0FSUkFZO1xuRFVNTVlfQVJSQVkgPSBbXTtcbnZhciBzdGF0ZSA9IGZ1bmN0aW9uIHN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgYnViYmxlcywgc291cmNlKSB7XG4gIHZhciBhY3RpdmVTdGF0ZXMsIGNoaWxkLCBkZXNpcmVkVmFsdWUsIGksIGosIGtleSwga2V5cywgbGVuLCBwcm9wLCByZWYsIHRvZ2dsZTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5zbGljZSgpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoSVMkMS5zdHJpbmcodGFyZ2V0U3RhdGUpKSB7XG4gICAgICByZXR1cm4gaW5jbHVkZXModGhpcy5fc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KHRhcmdldFN0YXRlKSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFN0YXRlKTtcbiAgICAgIGkgPSAtMTtcblxuICAgICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgICB0aGlzLnN0YXRlKGtleSwgdGFyZ2V0U3RhdGVba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZVBpcGVUYXJnZXQgJiYgc291cmNlICE9PSB0aGlzKSB7XG4gICAgdGhpcy5fc3RhdGVQaXBlVGFyZ2V0LnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgYnViYmxlcywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChJUyQxLnN0cmluZyh0YXJnZXRTdGF0ZSkpIHtcbiAgICBpZiAodGFyZ2V0U3RhdGVbMF0gPT09ICckJykge1xuICAgICAgdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZS5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0U3RhdGUgPT09ICdiYXNlJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGVzaXJlZFZhbHVlID0gISF2YWx1ZTsgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBib29sZWFuXG5cbiAgICBhY3RpdmVTdGF0ZXMgPSB0aGlzLl9nZXRBY3RpdmVTdGF0ZXModGFyZ2V0U3RhdGUsIGZhbHNlKTsgLy8gPT09PSBUb2dnbGUgc3R5bGVzIGZvciB0aGlzIHN0YXRlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgaWYgKHRoaXMuc3RhdGUodGFyZ2V0U3RhdGUpICE9PSBkZXNpcmVkVmFsdWUpIHtcbiAgICAgIHByb3AgPSB0aGlzLnR5cGUgPT09ICd0ZXh0JyA/ICdUZXh0JyA6ICdTdHlsZSc7XG5cbiAgICAgIGlmIChkZXNpcmVkVmFsdWUpIHtcbiAgICAgICAgLy9pcyBvblxuICAgICAgICB0aGlzLl9zdGF0ZS5wdXNoKHRhcmdldFN0YXRlKTtcblxuICAgICAgICB0b2dnbGUgPSAnT04nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlSXRlbSh0aGlzLl9zdGF0ZSwgdGFyZ2V0U3RhdGUpO1xuICAgICAgICB0b2dnbGUgPSAnT0ZGJztcbiAgICAgIH1cblxuICAgICAgdGhpc1snX3R1cm4nICsgcHJvcCArIHRvZ2dsZV0odGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyk7XG4gICAgICB0aGlzLmVtaXRQcml2YXRlKFwic3RhdGVDaGFuZ2U6XCIuY29uY2F0KHRhcmdldFN0YXRlKSwgZGVzaXJlZFZhbHVlKTtcbiAgICB9IC8vID09PT0gUGFzcyBzdGF0ZSB0byBwYXJlbnQvY2hpbGRyZW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIGlmICghaW5jbHVkZXModGhpcy5vcHRpb25zLnVucGFzc2FibGVTdGF0ZXMsIHRhcmdldFN0YXRlKSkge1xuICAgICAgaWYgKGJ1YmJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50LnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgdHJ1ZSwgc291cmNlIHx8IHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5wYXNzU3RhdGVUb0NoaWxkcmVuKSB7XG4gICAgICAgIHJlZiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgICAgIGNoaWxkLnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgZmFsc2UsIHNvdXJjZSB8fCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIHRvZ2dsZVN0YXRlID0gZnVuY3Rpb24gdG9nZ2xlU3RhdGUodGFyZ2V0U3RhdGUpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGUodGFyZ2V0U3RhdGUsICF0aGlzLnN0YXRlKHRhcmdldFN0YXRlKSk7XG59O1xudmFyIHJlc2V0U3RhdGUgPSBmdW5jdGlvbiByZXNldFN0YXRlKCkge1xuICB2YXIgYWN0aXZlU3RhdGUsIGosIGxlbiwgcmVmO1xuICByZWYgPSB0aGlzLl9zdGF0ZS5zbGljZSgpO1xuXG4gIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgIGFjdGl2ZVN0YXRlID0gcmVmW2pdO1xuICAgIHRoaXMuc3RhdGUoYWN0aXZlU3RhdGUsIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwaXBlU3RhdGUgPSBmdW5jdGlvbiBwaXBlU3RhdGUodGFyZ2V0RWwpIHtcbiAgdmFyIGFjdGl2ZVN0YXRlLCBqLCBsZW4sIHJlZjtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3N0YXRlUGlwZVRhcmdldCA9IHRhcmdldEVsO1xuICAgICAgcmVmID0gdGhpcy5fc3RhdGU7XG5cbiAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBhY3RpdmVTdGF0ZSA9IHJlZltqXTtcbiAgICAgICAgdGFyZ2V0RWwuc3RhdGUoYWN0aXZlU3RhdGUsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0YXJnZXRFbCA9PT0gZmFsc2UpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVQaXBlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIF9hcHBseVJlZ2lzdGVyZWRTdHlsZSA9IGZ1bmN0aW9uIF9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0YXJnZXRTdHlsZSwgc3VwZXJpb3JTdGF0ZXMsIGluY2x1ZGVCYXNlLCBza2lwRm5zKSB7XG4gIHZhciBjbGFzc05hbWUsIGVudHJ5LCBqLCBrLCBsZW4sIGxlbjEsIHJlZiwgcmVmMSwgc3VwZXJpb3JTdHlsZXM7XG5cbiAgaWYgKHRhcmdldFN0eWxlKSB7XG4gICAgcmVmID0gdGFyZ2V0U3R5bGUuY2xhc3NOYW1lO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBjbGFzc05hbWUgPSByZWZbal07XG4gICAgICB0aGlzLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldFN0eWxlLmZucy5sZW5ndGggJiYgIXNraXBGbnMpIHtcbiAgICAgIGlmIChzdXBlcmlvclN0YXRlcykge1xuICAgICAgICBzdXBlcmlvclN0eWxlcyA9IHRoaXMuX3Jlc29sdmVGblN0eWxlcyhzdXBlcmlvclN0YXRlcywgaW5jbHVkZUJhc2UpO1xuICAgICAgfVxuXG4gICAgICByZWYxID0gdGFyZ2V0U3R5bGUuZm5zO1xuXG4gICAgICBmb3IgKGsgPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgZW50cnkgPSByZWYxW2tdO1xuXG4gICAgICAgIGlmICghKHN1cGVyaW9yU3R5bGVzICYmIHN1cGVyaW9yU3R5bGVzW2VudHJ5WzBdXSkpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlKGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSA9IGZ1bmN0aW9uIF9yZW1vdmVSZWdpc3RlcmVkU3R5bGUodGFyZ2V0U3R5bGUsIHN1cGVyaW9yU3RhdGVzLCBpbmNsdWRlQmFzZSkge1xuICB2YXIgY2xhc3NOYW1lLCBlbnRyeSwgaiwgaywgbGVuLCBsZW4xLCByZWYsIHJlZjEsIHJlc2V0VmFsdWUsIHN1cGVyaW9yU3R5bGVzO1xuICByZWYgPSB0YXJnZXRTdHlsZS5jbGFzc05hbWU7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgY2xhc3NOYW1lID0gcmVmW2pdO1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIGlmICh0YXJnZXRTdHlsZS5mbnMubGVuZ3RoKSB7XG4gICAgaWYgKHN1cGVyaW9yU3RhdGVzKSB7XG4gICAgICBzdXBlcmlvclN0eWxlcyA9IHRoaXMuX3Jlc29sdmVGblN0eWxlcyhzdXBlcmlvclN0YXRlcywgaW5jbHVkZUJhc2UpO1xuICAgIH1cblxuICAgIHJlZjEgPSB0YXJnZXRTdHlsZS5mbnM7XG5cbiAgICBmb3IgKGsgPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgIGVudHJ5ID0gcmVmMVtrXTtcbiAgICAgIHJlc2V0VmFsdWUgPSBzdXBlcmlvclN0eWxlcyAmJiBzdXBlcmlvclN0eWxlc1tlbnRyeVswXV0gfHwgbnVsbDtcbiAgICAgIHRoaXMuc3R5bGUoZW50cnlbMF0sIHJlc2V0VmFsdWUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfdHVyblN0eWxlT04gPSBmdW5jdGlvbiBfdHVyblN0eWxlT04odGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcykge1xuICB2YXIgaiwgbGVuLCBzaGFyZWRTdGF0ZXMsIHNraXBGbnMsIHN0YXRlQ2hhaW47XG4gIHNraXBGbnMgPSB0aGlzLm9wdGlvbnMuc3R5bGVBZnRlckluc2VydCAmJiAhdGhpcy5faW5zZXJ0ZWQ7XG5cbiAgaWYgKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0pIHtcbiAgICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXNbdGFyZ2V0U3RhdGVdLCB0aGlzLl9nZXRTdXBlcmlvclN0YXRlcyh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSwgZmFsc2UsIHNraXBGbnMpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Byb3ZpZGVkU3RhdGVzU2hhcmVkKSB7XG4gICAgc2hhcmVkU3RhdGVzID0gdGhpcy5fZ2V0U2hhcmVkU3RhdGVzKHRhcmdldFN0YXRlKTtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHNoYXJlZFN0YXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgc3RhdGVDaGFpbiA9IHNoYXJlZFN0YXRlc1tqXTtcblxuICAgICAgaWYgKCFpbmNsdWRlcyh0aGlzLl9zdGF0ZVNoYXJlZCwgc3RhdGVDaGFpbi5zdHJpbmcpKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlU2hhcmVkLnB1c2goc3RhdGVDaGFpbi5zdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXNbc3RhdGVDaGFpbi5zdHJpbmddLCBudWxsLCBudWxsLCBza2lwRm5zKTtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5TdHlsZU9GRiA9IGZ1bmN0aW9uIF90dXJuU3R5bGVPRkYodGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcykge1xuICB2YXIgYWN0aXZlU2hhcmVkU3RhdGVzLCBqLCBsZW4sIHNoYXJlZFN0YXRlcywgc3RhdGVDaGFpbiwgdGFyZ2V0U3R5bGU7XG5cbiAgaWYgKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0pIHtcbiAgICB0aGlzLl9yZW1vdmVSZWdpc3RlcmVkU3R5bGUodGhpcy5fc3R5bGVzW3RhcmdldFN0YXRlXSwgYWN0aXZlU3RhdGVzLCB0cnVlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9wcm92aWRlZFN0YXRlc1NoYXJlZCkge1xuICAgIHNoYXJlZFN0YXRlcyA9IHRoaXMuX2dldFNoYXJlZFN0YXRlcyh0YXJnZXRTdGF0ZSk7XG5cbiAgICBpZiAoc2hhcmVkU3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IHNoYXJlZFN0YXRlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgc3RhdGVDaGFpbiA9IHNoYXJlZFN0YXRlc1tqXTtcbiAgICAgIHJlbW92ZUl0ZW0odGhpcy5fc3RhdGVTaGFyZWQsIHN0YXRlQ2hhaW4uc3RyaW5nKTtcbiAgICAgIHRhcmdldFN0eWxlID0gdGhpcy5fc3R5bGVzW3N0YXRlQ2hhaW4uc3RyaW5nXTtcblxuICAgICAgaWYgKHRhcmdldFN0eWxlLmZucy5sZW5ndGggJiYgdGhpcy5fc3RhdGVTaGFyZWQubGVuZ3RoICYmICFhY3RpdmVTaGFyZWRTdGF0ZXMpIHtcbiAgICAgICAgYWN0aXZlU2hhcmVkU3RhdGVzID0gdGhpcy5fc3RhdGVTaGFyZWQuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiAhaW5jbHVkZXMoc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZVN0YXRlcyA9IGFjdGl2ZVN0YXRlcy5jb25jYXQoYWN0aXZlU2hhcmVkU3RhdGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlKHRhcmdldFN0eWxlLCBhY3RpdmVTdGF0ZXMsIHRydWUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfdHVyblRleHRPTiA9IGZ1bmN0aW9uIF90dXJuVGV4dE9OKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIHN1cGVyaW9yU3RhdGVzLCB0YXJnZXRUZXh0O1xuXG4gIGlmICh0aGlzLl90ZXh0cyAmJiBJUyQxLnN0cmluZyh0YXJnZXRUZXh0ID0gdGhpcy5fdGV4dHNbdGFyZ2V0U3RhdGVdKSkge1xuICAgIHN1cGVyaW9yU3RhdGVzID0gdGhpcy5fZ2V0U3VwZXJpb3JTdGF0ZXModGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyk7XG5cbiAgICBpZiAoIXN1cGVyaW9yU3RhdGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy50ZXh0ID0gdGFyZ2V0VGV4dDtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5UZXh0T0ZGID0gZnVuY3Rpb24gX3R1cm5UZXh0T0ZGKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIHRhcmdldFRleHQ7XG5cbiAgaWYgKHRoaXMuX3RleHRzICYmIElTJDEuc3RyaW5nKHRhcmdldFRleHQgPSB0aGlzLl90ZXh0c1t0YXJnZXRTdGF0ZV0pKSB7XG4gICAgYWN0aXZlU3RhdGVzID0gYWN0aXZlU3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZSAhPT0gdGFyZ2V0U3RhdGU7XG4gICAgfSk7XG4gICAgdGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzW2FjdGl2ZVN0YXRlc1thY3RpdmVTdGF0ZXMubGVuZ3RoIC0gMV1dO1xuXG4gICAgaWYgKHRhcmdldFRleHQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzLmJhc2U7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gdGFyZ2V0VGV4dDtcbiAgfVxufTtcbnZhciBfZ2V0QWN0aXZlU3RhdGVzID0gZnVuY3Rpb24gX2dldEFjdGl2ZVN0YXRlcyhzdGF0ZVRvRXhjbHVkZSkge1xuICB2YXIgaW5jbHVkZVNoYXJlZFN0YXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIGFjdGl2ZVN0YXRlcywgaiwgbGVuLCBwbGFpblN0YXRlcztcblxuICBpZiAoIXRoaXMuX3Byb3ZpZGVkU3RhdGVzKSB7XG4gICAgcmV0dXJuIERVTU1ZX0FSUkFZO1xuICB9XG5cbiAgYWN0aXZlU3RhdGVzID0gcGxhaW5TdGF0ZXMgPSB0aGlzLl9zdGF0ZTtcblxuICBpZiAoc3RhdGVUb0V4Y2x1ZGUpIHtcbiAgICBwbGFpblN0YXRlcyA9IFtdO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gYWN0aXZlU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzdGF0ZSA9IGFjdGl2ZVN0YXRlc1tqXTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBzdGF0ZVRvRXhjbHVkZSkge1xuICAgICAgICBwbGFpblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWluY2x1ZGVTaGFyZWRTdGF0ZXMgfHwgIXRoaXMuX3Byb3ZpZGVkU3RhdGVzU2hhcmVkKSB7XG4gICAgcmV0dXJuIHBsYWluU3RhdGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwbGFpblN0YXRlcy5jb25jYXQodGhpcy5fc3RhdGVTaGFyZWQpO1xuICB9XG59O1xudmFyIF9nZXRTdXBlcmlvclN0YXRlcyA9IGZ1bmN0aW9uIF9nZXRTdXBlcmlvclN0YXRlcyh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSB7XG4gIHZhciBjYW5kaWRhdGUsIGosIGxlbiwgc3VwZXJpb3IsIHRhcmdldFN0YXRlSW5kZXg7XG4gIHRhcmdldFN0YXRlSW5kZXggPSB0aGlzLl9wcm92aWRlZFN0YXRlcy5pbmRleE9mKHRhcmdldFN0YXRlKTtcblxuICBpZiAodGFyZ2V0U3RhdGVJbmRleCA9PT0gdGhpcy5fcHJvdmlkZWRTdGF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBEVU1NWV9BUlJBWTtcbiAgfVxuXG4gIHN1cGVyaW9yID0gW107XG5cbiAgZm9yIChqID0gMCwgbGVuID0gYWN0aXZlU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgY2FuZGlkYXRlID0gYWN0aXZlU3RhdGVzW2pdO1xuXG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVkU3RhdGVzLmluZGV4T2YoY2FuZGlkYXRlKSA+IHRhcmdldFN0YXRlSW5kZXgpIHtcbiAgICAgIHN1cGVyaW9yLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VwZXJpb3I7XG59O1xudmFyIF9nZXRTaGFyZWRTdGF0ZXMgPSBmdW5jdGlvbiBfZ2V0U2hhcmVkU3RhdGVzKHRhcmdldFN0YXRlKSB7XG4gIHZhciBhY3RpdmVTdGF0ZXMsIGosIGxlbiwgcmVmLCBzaGFyZWRTdGF0ZXMsIHN0YXRlQ2hhaW47XG4gIGFjdGl2ZVN0YXRlcyA9IHRoaXMuX3N0YXRlO1xuICBzaGFyZWRTdGF0ZXMgPSBbXTtcbiAgcmVmID0gdGhpcy5fcHJvdmlkZWRTdGF0ZXNTaGFyZWQ7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgc3RhdGVDaGFpbiA9IHJlZltqXTtcblxuICAgIGlmIChzdGF0ZUNoYWluLmluY2x1ZGVzKHRhcmdldFN0YXRlKSAmJiBzdGF0ZUNoYWluLmlzQXBwbGljYWJsZSh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSkge1xuICAgICAgc2hhcmVkU3RhdGVzLnB1c2goc3RhdGVDaGFpbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNoYXJlZFN0YXRlcztcbn07XG52YXIgX3Jlc29sdmVGblN0eWxlcyA9IGZ1bmN0aW9uIF9yZXNvbHZlRm5TdHlsZXMoc3RhdGVzLCBpbmNsdWRlQmFzZSkge1xuICB2YXIgZW50cnksIGosIGssIGxlbiwgbGVuMSwgb3V0cHV0LCByZWY7XG5cbiAgaWYgKGluY2x1ZGVCYXNlKSB7XG4gICAgc3RhdGVzID0gWydiYXNlJ10uY29uY2F0KHN0YXRlcyk7XG4gIH1cblxuICBvdXRwdXQgPSB7fTtcblxuICBmb3IgKGogPSAwLCBsZW4gPSBzdGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICBzdGF0ZSA9IHN0YXRlc1tqXTtcblxuICAgIGlmICh0aGlzLl9zdHlsZXNbc3RhdGVdICYmIHRoaXMuX3N0eWxlc1tzdGF0ZV0uZm5zLmxlbmd0aCkge1xuICAgICAgcmVmID0gdGhpcy5fc3R5bGVzW3N0YXRlXS5mbnM7XG5cbiAgICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgIGVudHJ5ID0gcmVmW2tdO1xuICAgICAgICBvdXRwdXRbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5mdW5jdGlvbiBzdGF0ZSQxIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zdGF0ZSA9IHN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnRvZ2dsZVN0YXRlID0gdG9nZ2xlU3RhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVzZXRTdGF0ZSA9IHJlc2V0U3RhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGlwZVN0YXRlID0gcGlwZVN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSA9IF9hcHBseVJlZ2lzdGVyZWRTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlID0gX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdHVyblN0eWxlT04gPSBfdHVyblN0eWxlT047XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5TdHlsZU9GRiA9IF90dXJuU3R5bGVPRkY7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5UZXh0T04gPSBfdHVyblRleHRPTjtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdHVyblRleHRPRkYgPSBfdHVyblRleHRPRkY7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2dldEFjdGl2ZVN0YXRlcyA9IF9nZXRBY3RpdmVTdGF0ZXM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2dldFN1cGVyaW9yU3RhdGVzID0gX2dldFN1cGVyaW9yU3RhdGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9nZXRTaGFyZWRTdGF0ZXMgPSBfZ2V0U2hhcmVkU3RhdGVzO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVzb2x2ZUZuU3R5bGVzID0gX3Jlc29sdmVGblN0eWxlcztcbn12YXIgdG9UZW1wbGF0ZSA9IGZ1bmN0aW9uIHRvVGVtcGxhdGUoKSB7XG4gIHJldHVybiBfcXVpY2tkb20udGVtcGxhdGUodGhpcyk7XG59O1xudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBhY3RpdmVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxiYWNrcywgY2hpbGQsIGVsQ2xvbmUsIGV2ZW50TmFtZSwgaSwgaiwgaywgbGVuLCBsZW4xLCBsZW4yLCBuZXdFbCwgb3B0aW9ucywgcmVmLCByZWYxLCByZWYyO1xuICBlbENsb25lID0gdGhpcy5lbC5jbG9uZU5vZGUoZmFsc2UpO1xuICBvcHRpb25zID0gZXh0ZW5kLmNsb25lKHRoaXMub3B0aW9ucywge1xuICAgIGV4aXN0aW5nOiBlbENsb25lXG4gIH0pO1xuICBuZXdFbCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudHlwZSwgb3B0aW9ucyk7XG4gIHJlZiA9IHRoaXMuX3N0YXRlO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFjdGl2ZVN0YXRlID0gcmVmW2ldO1xuICAgIG5ld0VsLnN0YXRlKGFjdGl2ZVN0YXRlLCB0cnVlKTtcbiAgfVxuXG4gIHJlZjEgPSB0aGlzLmNoaWxkcmVuO1xuXG4gIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgIGNoaWxkID0gcmVmMVtqXTtcbiAgICBuZXdFbC5hcHBlbmQoY2hpbGQuY2xvbmUoKSk7XG4gIH1cblxuICByZWYyID0gdGhpcy5fZXZlbnRDYWxsYmFja3M7XG5cbiAgZm9yIChldmVudE5hbWUgaW4gcmVmMikge1xuICAgIGNhbGxiYWNrcyA9IHJlZjJbZXZlbnROYW1lXTtcblxuICAgIGZvciAoayA9IDAsIGxlbjIgPSBjYWxsYmFja3MubGVuZ3RoOyBrIDwgbGVuMjsgaysrKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1trXTtcbiAgICAgIG5ld0VsLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdFbDtcbn07XG52YXIgYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHRhcmdldEVsKSB7XG4gIHZhciBwcmV2UGFyZW50O1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgcHJldlBhcmVudCA9IHRhcmdldEVsLnBhcmVudDtcblxuICAgICAgaWYgKHByZXZQYXJlbnQpIHtcbiAgICAgICAgcHJldlBhcmVudC5fcmVtb3ZlQ2hpbGQodGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0YXJnZXRFbC5lbCk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGFwcGVuZFRvID0gZnVuY3Rpb24gYXBwZW5kVG8odGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5hcHBlbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKHRhcmdldEVsKSB7XG4gIHZhciBwcmV2UGFyZW50O1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgcHJldlBhcmVudCA9IHRhcmdldEVsLnBhcmVudDtcblxuICAgICAgaWYgKHByZXZQYXJlbnQpIHtcbiAgICAgICAgcHJldlBhcmVudC5fcmVtb3ZlQ2hpbGQodGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGlsZHJlbi51bnNoaWZ0KHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUodGFyZ2V0RWwuZWwsIHRoaXMuZWwuZmlyc3RDaGlsZCk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHByZXBlbmRUbyA9IGZ1bmN0aW9uIHByZXBlbmRUbyh0YXJnZXRFbCkge1xuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHRhcmdldEVsLnByZXBlbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIodGFyZ2V0RWwpIHtcbiAgdmFyIG15SW5kZXg7XG5cbiAgaWYgKHRhcmdldEVsICYmIHRoaXMucGFyZW50KSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICBteUluZGV4ID0gdGhpcy5wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2YodGhpcyk7XG5cbiAgICAgIHRoaXMucGFyZW50Ll9jaGlsZHJlbi5zcGxpY2UobXlJbmRleCArIDEsIDAsIHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRFbC5lbCwgdGhpcy5lbC5uZXh0U2libGluZyk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIodGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5hZnRlcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKHRhcmdldEVsKSB7XG4gIHZhciBteUluZGV4O1xuXG4gIGlmICh0YXJnZXRFbCAmJiB0aGlzLnBhcmVudCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgbXlJbmRleCA9IHRoaXMucGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuXG4gICAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4uc3BsaWNlKG15SW5kZXgsIDAsIHRhcmdldEVsKTtcblxuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRFbC5lbCwgdGhpcy5lbCk7XG5cbiAgICAgIHRhcmdldEVsLl9yZWZyZXNoUGFyZW50KCk7IC8vIEZvcmNlIHJlLWZyZXNoIHRhcmdldEVsLl9wYXJlbnQgdmFsdWUgdG8gdHJpZ2dlciBpbnNlcnRlZCBjYWxsYmFja1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZSh0YXJnZXRFbCkge1xuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHRhcmdldEVsLmJlZm9yZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZGV0YWNoID0gZnVuY3Rpb24gZGV0YWNoKCkge1xuICB2YXIgcmVmO1xuXG4gIGlmICgocmVmID0gdGhpcy5wYXJlbnQpICE9IG51bGwpIHtcbiAgICByZWYuX3JlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIGV2ZW50TmFtZTtcbiAgdGhpcy5kZXRhY2goKTtcbiAgdGhpcy5yZXNldFN0YXRlKCk7XG5cbiAgaWYgKHRoaXMuX2V2ZW50Q2FsbGJhY2tzKSB7XG4gICAgZm9yIChldmVudE5hbWUgaW4gdGhpcy5fZXZlbnRDYWxsYmFja3MpIHtcbiAgICAgIHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgdmFyIGNoaWxkLCBpLCBsZW4sIHJlZjtcbiAgcmVmID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNoaWxkID0gcmVmW2ldO1xuXG4gICAgdGhpcy5fcmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKHRhcmdldEVsKSB7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG4gICAgY3VycmVudFBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMgJiYgdGFyZ2V0RWwgIT09IHRoaXMucGFyZW50KSB7XG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBjdXJyZW50UGFyZW50Ll9yZW1vdmVDaGlsZCh0aGlzLCAhdGFyZ2V0RWwucGFyZW50ID8gdGFyZ2V0RWwgOiB2b2lkIDApO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRFbC5hcHBlbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHVud3JhcCA9IGZ1bmN0aW9uIHVud3JhcCgpIHtcbiAgdmFyIGdyYW5kUGFyZW50LCBwYXJlbnQsIHBhcmVudENoaWxkcmVuLCBwYXJlbnRTaWJsaW5nO1xuICBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50Q2hpbGRyZW4gPSBfcXVpY2tkb20uYmF0Y2gocGFyZW50LmNoaWxkcmVuKTtcbiAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHQ7XG4gICAgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXG4gICAgaWYgKGdyYW5kUGFyZW50KSB7XG4gICAgICBwYXJlbnQuZGV0YWNoKCk7XG5cbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nKSB7XG4gICAgICAgIHBhcmVudENoaWxkcmVuLmluc2VydEJlZm9yZShwYXJlbnRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudENoaWxkcmVuLmFwcGVuZFRvKGdyYW5kUGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UodGFyZ2V0RWwpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkgJiYgdGFyZ2V0RWwgIT09IHRoaXMpIHtcbiAgICAgIHRhcmdldEVsLmRldGFjaCgpO1xuXG4gICAgICBpZiAoKHJlZiA9IHRoaXMucGFyZW50KSAhPSBudWxsKSB7XG4gICAgICAgIHJlZi5fcmVtb3ZlQ2hpbGQodGhpcywgdGFyZ2V0RWwpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzKHRhcmdldCkge1xuICByZXR1cm4gaW5jbHVkZXModGhpcy5jbGFzc0xpc3QsIHRhcmdldCk7XG59O1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3ModGFyZ2V0KSB7XG4gIHZhciBjbGFzc0xpc3QsIHRhcmdldEluZGV4O1xuICBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdDtcbiAgdGFyZ2V0SW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZih0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbmRleCA9PT0gLTEpIHtcbiAgICBjbGFzc0xpc3QucHVzaCh0YXJnZXQpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NMaXN0Lmxlbmd0aCA+IDEgPyBjbGFzc0xpc3Quam9pbignICcpIDogY2xhc3NMaXN0WzBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3ModGFyZ2V0KSB7XG4gIHZhciBjbGFzc0xpc3QsIHRhcmdldEluZGV4O1xuICBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdDtcbiAgdGFyZ2V0SW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZih0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbmRleCAhPT0gLTEpIHtcbiAgICBjbGFzc0xpc3Quc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5sZW5ndGggPyBjbGFzc0xpc3Quam9pbignICcpIDogJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyh0YXJnZXQpIHtcbiAgaWYgKHRoaXMuaGFzQ2xhc3ModGFyZ2V0KSkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3ModGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZENsYXNzKHRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgc2V0UmVmID0gZnVuY3Rpb24gc2V0UmVmKHRhcmdldCkge1xuICB0aGlzLnJlZiA9IHRoaXMub3B0aW9ucy5yZWYgPSB0YXJnZXQ7XG4gIHRoaXMuYXR0cignZGF0YS1yZWYnLCB0YXJnZXQpO1xuICByZXR1cm4gdGhpcztcbn07XG52YXIgX3JlZnJlc2hQYXJlbnQgPSBmdW5jdGlvbiBfcmVmcmVzaFBhcmVudCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcbnZhciBfcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiBfcmVtb3ZlQ2hpbGQodGFyZ2V0Q2hpbGQsIHJlcGxhY2VtZW50Q2hpbGQpIHtcbiAgdmFyIGluZGV4T2ZDaGlsZDtcbiAgaW5kZXhPZkNoaWxkID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKHRhcmdldENoaWxkKTtcblxuICBpZiAoaW5kZXhPZkNoaWxkICE9PSAtMSkge1xuICAgIGlmIChyZXBsYWNlbWVudENoaWxkKSB7XG4gICAgICB0aGlzLmVsLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudENoaWxkLmVsLCB0YXJnZXRDaGlsZC5lbCk7XG5cbiAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleE9mQ2hpbGQsIDEsIHJlcGxhY2VtZW50Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRhcmdldENoaWxkLmVsKTtcblxuICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4T2ZDaGlsZCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uIChRdWlja0VsZW1lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdodG1sJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmlubmVySFRNTDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5pbm5lckhUTUwgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd0ZXh0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50ID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2xhc3NOYW1lJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmF3LmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsYXNzJywgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhdy5jbGFzc05hbWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NsYXNzTGlzdCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgbGlzdCA9IHRoaXMuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgaWYgKGxpc3RbbGlzdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICBsaXN0LnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS50b1RlbXBsYXRlID0gdG9UZW1wbGF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGNsb25lO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hcHBlbmRUbyA9IGFwcGVuZFRvO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgPSBwcmVwZW5kO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByZXBlbmRUbyA9IHByZXBlbmRUbztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hZnRlciA9IGFmdGVyO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmluc2VydEFmdGVyID0gaW5zZXJ0QWZ0ZXI7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlID0gYmVmb3JlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5kZXRhY2ggPSBkZXRhY2g7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gcmVtb3ZlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmVtcHR5ID0gZW1wdHk7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUud3JhcCA9IHdyYXA7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudW53cmFwID0gdW53cmFwO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gaGFzQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gdG9nZ2xlQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc2V0UmVmID0gc2V0UmVmO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9yZWZyZXNoUGFyZW50ID0gX3JlZnJlc2hQYXJlbnQ7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9yZW1vdmVDaGlsZCA9IF9yZW1vdmVDaGlsZDtcbn12YXIgdXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoSVMkMS5vYmplY3Qob3B0aW9ucykpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplT3B0aW9ucygpO1xuXG4gICAgdGhpcy5fYXBwbHlPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdXBkYXRlU3RhdGVTdHlsZXMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZVN0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIGksIGxlbiwgcGFyc2VkLCBzdGF0ZSwgdXBkYXRlZFN0YXRlcztcblxuICBpZiAoSVMkMS5vYmplY3RQbGFpbihzdHlsZXMpKSB7XG4gICAgZXh0ZW5kLmRlZXAuY29uY2F0KHRoaXMsIHBhcnNlZCA9IHRoaXMuX3BhcnNlU3R5bGVzKHN0eWxlcykpO1xuXG4gICAgaWYgKHBhcnNlZC5fc3R5bGVzKSB7XG4gICAgICB1cGRhdGVkU3RhdGVzID0gT2JqZWN0LmtleXMocGFyc2VkLl9zdHlsZXMpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB1cGRhdGVkU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gdXBkYXRlZFN0YXRlc1tpXTtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZShzdGF0ZSkgfHwgc3RhdGUgPT09ICdiYXNlJykge1xuICAgICAgICAgIHRoaXMuX2FwcGx5UmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlc1tzdGF0ZV0sIHRoaXMuX2dldEFjdGl2ZVN0YXRlcyhzdGF0ZSksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciB1cGRhdGVTdGF0ZVRleHRzID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVUZXh0cyh0ZXh0cykge1xuICB2YXIgcGFyc2VkO1xuXG4gIGlmIChJUyQxLm9iamVjdFBsYWluKHRleHRzKSkge1xuICAgIGV4dGVuZC5kZWVwLmNvbmNhdCh0aGlzLCBwYXJzZWQgPSB0aGlzLl9wYXJzZVRleHRzKHRleHRzKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgYXBwbHlEYXRhID0gZnVuY3Rpb24gYXBwbHlEYXRhKGRhdGEsIHBhc3NUaHJvdWdoKSB7XG4gIHZhciBjaGlsZCwgY29tcHV0ZXJzLCBkZWZhdWx0cywgaSwgaiwga2V5LCBrZXlzLCBsZW4sIGxlbjEsIHJlZjtcblxuICBpZiAodGhpcy5vcHRpb25zLnBhc3NEYXRhVG9DaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggJiYgKHBhc3NUaHJvdWdoICE9IG51bGwgPyBwYXNzVGhyb3VnaCA6IHBhc3NUaHJvdWdoID0gdHJ1ZSkpIHtcbiAgICByZWYgPSB0aGlzLl9jaGlsZHJlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICBjaGlsZC5hcHBseURhdGEoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXB1dGVycyA9IHRoaXMub3B0aW9ucy5jb21wdXRlcnMpIHtcbiAgICBkZWZhdWx0cyA9IHRoaXMub3B0aW9ucy5kZWZhdWx0cztcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoY29tcHV0ZXJzKTtcblxuICAgIGZvciAoaiA9IDAsIGxlbjEgPSBrZXlzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAga2V5ID0ga2V5c1tqXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnZva2VDb21wdXRlcnNPbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnZva2VkQ29tcHV0ZXJzW2tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ludm9rZWRDb21wdXRlcnNba2V5XSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzLl9ydW5Db21wdXRlcihrZXksIGRhdGFba2V5XSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRzICYmIGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdGhpcy5fcnVuQ29tcHV0ZXIoa2V5LCBkZWZhdWx0c1trZXldLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgX3J1bkNvbXB1dGVyID0gZnVuY3Rpb24gX3J1bkNvbXB1dGVyKGNvbXB1dGVyLCBhcmcsIGRhdGEpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wdXRlcnNbY29tcHV0ZXJdLmNhbGwodGhpcywgYXJnLCBkYXRhKTtcbn07XG5mdW5jdGlvbiBhcHBsaWNhdGlvbiAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudXBkYXRlT3B0aW9ucyA9IHVwZGF0ZU9wdGlvbnM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudXBkYXRlU3RhdGVTdHlsZXMgPSB1cGRhdGVTdGF0ZVN0eWxlcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS51cGRhdGVTdGF0ZVRleHRzID0gdXBkYXRlU3RhdGVUZXh0cztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hcHBseURhdGEgPSBhcHBseURhdGE7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9ydW5Db21wdXRlciA9IF9ydW5Db21wdXRlcjtcbn12YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIodGFyZ2V0LCBuZXdWYWx1ZSkge1xuICB2YXIgaSwga2V5LCBrZXlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoSVMkMS5vYmplY3QodGFyZ2V0KSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICBpID0gLTE7XG5cbiAgICAgIHdoaWxlIChrZXkgPSBrZXlzWysraV0pIHtcbiAgICAgICAgdGhpcy5hdHRyKGtleSwgdGFyZ2V0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKHRhcmdldCwgbmV3VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHByb3AgPSBmdW5jdGlvbiBwcm9wKHRhcmdldCwgbmV3VmFsdWUpIHtcbiAgdmFyIGksIGtleSwga2V5cztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuZWxbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBpZiAoSVMkMS5vYmplY3QodGFyZ2V0KSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICBpID0gLTE7XG5cbiAgICAgIHdoaWxlIChrZXkgPSBrZXlzWysraV0pIHtcbiAgICAgICAgdGhpcy5wcm9wKGtleSwgdGFyZ2V0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsW3RhcmdldF0gPSBuZXdWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIGF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hdHRyID0gYXR0cjtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucHJvcCA9IHByb3A7XG59dmFyIFF1aWNrRWxlbWVudCQxLCBzdmdOYW1lc3BhY2U7XG5zdmdOYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIFF1aWNrRWxlbWVudCQyID0gUXVpY2tFbGVtZW50JDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBRdWlja0VsZW1lbnQgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWlja0VsZW1lbnQodHlwZSwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrRWxlbWVudCk7XG5cbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgUXVpY2tFbGVtZW50LmNvdW50Kys7XG5cbiAgICAgIGlmICh0aGlzLnR5cGVbMF0gPT09ICcqJykge1xuICAgICAgICB0aGlzLnN2ZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwgPSB0aGlzLm9wdGlvbnMuZXhpc3RpbmcgfHwgKHRoaXMudHlwZSA9PT0gJ3RleHQnID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodHlwZW9mIHRoaXMub3B0aW9ucy50ZXh0ID09PSAnc3RyaW5nJyA/IHRoaXMub3B0aW9ucy50ZXh0IDogJycpIDogdGhpcy5zdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTmFtZXNwYWNlLCB0aGlzLnR5cGUuc2xpY2UoMSkpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnR5cGUpKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kID0gdGhpcy5wcmVwZW5kID0gdGhpcy5hdHRyID0gZnVuY3Rpb24gKCkge307XG4gICAgICB9IC8vIEBfdGV4dHMgPSB7fSAjIGRlZmluZWQgY29uZGl0aW9uYWxseVxuXG5cbiAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9zdHlsZXMgPSB7fTtcbiAgICAgIHRoaXMuX3N0YXRlID0gW107XG4gICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdOyAvLyBAX3Byb3ZpZGVkU3RhdGVzID0gW11cdFx0XHRcdCMgZGVmaW5lZCBjb25kaXRpb25hbGx5XG4gICAgICAvLyBAX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID0gW11cdFx0IyBkZWZpbmVkIGNvbmRpdGlvbmFsbHlcbiAgICAgIC8vIEBfZXZlbnRDYWxsYmFja3MgPSB7X19yZWZzOnt9fVx0IyBkZWZpbmVkIGNvbmRpdGlvbmFsbHlcblxuICAgICAgdGhpcy5fbm9ybWFsaXplT3B0aW9ucygpO1xuXG4gICAgICB0aGlzLl9hcHBseU9wdGlvbnMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoU3RhdGVFdmVudHMoKTtcblxuICAgICAgdGhpcy5fcHJveHlQYXJlbnQoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leGlzdGluZykge1xuICAgICAgICB0aGlzLl9yZWZyZXNoUGFyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwuX3F1aWNrRWxlbWVudCA9IHRoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrRWxlbWVudCwgW3tcbiAgICAgIGtleTogXCJ0b0pTT05cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHZhciBjaGlsZCwgY2hpbGRyZW4sIGksIGxlbiwgb3V0cHV0O1xuICAgICAgICBvdXRwdXQgPSBbdGhpcy50eXBlLCBleHRlbmQuY2xvbmUua2V5cyhlbGVtZW50KSh0aGlzLm9wdGlvbnMpXTtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZC50b0pTT04oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWlja0VsZW1lbnQ7XG4gIH0oKTtcbiAgUXVpY2tFbGVtZW50LmNvdW50ID0gMDtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKFF1aWNrRWxlbWVudCQxLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja0VsZW1lbnQkMS5uYW1lID0gJ1F1aWNrRWxlbWVudCc7XG59XG5pbml0JDEoUXVpY2tFbGVtZW50JDEpO1xuYWxpYXNlcyhRdWlja0VsZW1lbnQkMSk7XG50cmF2ZXJzaW5nKFF1aWNrRWxlbWVudCQxKTtcbmV2ZW50cyhRdWlja0VsZW1lbnQkMSk7XG5zdGF0ZSQxKFF1aWNrRWxlbWVudCQxKTtcbnN0eWxlJDEoUXVpY2tFbGVtZW50JDEpO1xubWFuaXB1bGF0aW9uKFF1aWNrRWxlbWVudCQxKTtcbmFwcGxpY2F0aW9uKFF1aWNrRWxlbWVudCQxKTtcbmF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudCQxKTt2YXIgc2NoZW1hID0ge1xuICB0eXBlOiAnZGl2JyxcbiAgcmVmOiB2b2lkIDAsXG4gIG9wdGlvbnM6IHt9LFxuICBjaGlsZHJlbjogW11cbn07XG52YXIgbWF0Y2hlc1NjaGVtYSA9IGZ1bmN0aW9uIG1hdGNoZXNTY2hlbWEob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0LnR5cGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvYmplY3QucmVmICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygb2JqZWN0Lm9wdGlvbnMgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvYmplY3QuY2hpbGRyZW4gIT09ICd1bmRlZmluZWQnO1xufTt2YXIgUEFSU0VfRVJST1JfUFJFRklYLCBwYXJzZVRyZWU7XG5QQVJTRV9FUlJPUl9QUkVGSVggPSAnVGVtcGxhdGUgUGFyc2UgRXJyb3I6IGV4cGVjdGVkJztcbnZhciBwYXJzZVRyZWUkMSA9IHBhcnNlVHJlZSA9IGZ1bmN0aW9uIHBhcnNlVHJlZSh0cmVlLCBwYXJzZUNoaWxkcmVuKSB7XG4gIHZhciBvdXRwdXQ7XG5cbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIUlTJDEuYXJyYXkodHJlZSk6XG4gICAgICBvdXRwdXQgPSB7fTtcblxuICAgICAgaWYgKCFJUyQxLnN0cmluZyh0cmVlWzBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoUEFSU0VfRVJST1JfUFJFRklYLCBcIiBzdHJpbmcgZm9yICd0eXBlJywgZ290ICdcIikuY29uY2F0KFN0cmluZyh0cmVlWzBdKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC50eXBlID0gdHJlZVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMSAmJiAhSVMkMS5vYmplY3QodHJlZVsxXSkgJiYgdHJlZVsxXSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoUEFSU0VfRVJST1JfUFJFRklYLCBcIiBvYmplY3QgZm9yICdvcHRpb25zJywgZ290ICdcIikuY29uY2F0KFN0cmluZyh0cmVlWzFdKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5vcHRpb25zID0gdHJlZVsxXSA/IGV4dGVuZC5kZWVwLmNsb25lKHRyZWVbMV0pIDogc2NoZW1hLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHRyZWVbMV0pIHtcbiAgICAgICAgICBvdXRwdXQucmVmID0gdHJlZVsxXS5pZCB8fCB0cmVlWzFdLnJlZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvdXRwdXQuY2hpbGRyZW4gPSB0cmVlLnNsaWNlKDIpO1xuXG4gICAgICBpZiAocGFyc2VDaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID09PSAzICYmIElTJDEub2JqZWN0UGxhaW4odHJlZVsyXSkgJiYgIUlTJDEudGVtcGxhdGUodHJlZVsyXSkpIHtcbiAgICAgICAgICBvdXRwdXQuY2hpbGRyZW4gPSB0cmVlWzJdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuY2hpbGRyZW4gPSBvdXRwdXQuY2hpbGRyZW4ubWFwKHF1aWNrZG9tLnRlbXBsYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcblxuICAgIGNhc2UgIShJUyQxLnN0cmluZyh0cmVlKSB8fCBJUyQxLmRvbVRleHQodHJlZSkpOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgdGV4dDogdHJlZS50ZXh0Q29udGVudCB8fCB0cmVlXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBzY2hlbWEuY2hpbGRyZW5cbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLmRvbUVsKHRyZWUpOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHJlZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICByZWY6IHRyZWUuaWQsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuZC5jbG9uZS5rZXlzKHRlbXBsYXRlKSh0cmVlKSxcbiAgICAgICAgY2hpbGRyZW46IHNjaGVtYS5jaGlsZHJlbi5tYXAuY2FsbCh0cmVlLmNoaWxkTm9kZXMsIHF1aWNrZG9tLnRlbXBsYXRlKVxuICAgICAgfTtcblxuICAgIGNhc2UgIUlTJDEucXVpY2tEb21FbCh0cmVlKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRyZWUudHlwZSxcbiAgICAgICAgcmVmOiB0cmVlLnJlZixcbiAgICAgICAgb3B0aW9uczogZXh0ZW5kLmNsb25lLmRlZXAubm90S2V5cyhbJ3JlbGF0ZWRJbnN0YW5jZScsICdyZWxhdGVkJ10pKHRyZWUub3B0aW9ucyksXG4gICAgICAgIGNoaWxkcmVuOiB0cmVlLmNoaWxkcmVuLm1hcChxdWlja2RvbS50ZW1wbGF0ZSlcbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLnRlbXBsYXRlKHRyZWUpOlxuICAgICAgcmV0dXJuIHRyZWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KFBBUlNFX0VSUk9SX1BSRUZJWCwgXCIgKGFycmF5IHx8IHN0cmluZyB8fCBkb21FbCB8fCBxdWlja0RvbUVsIHx8IHRlbXBsYXRlKSwgZ290IFwiKS5jb25jYXQoU3RyaW5nKHRyZWUpKSk7XG4gIH1cbn07dmFyIE5PVF9ERUVQX0tFWVMsIE5PVF9LRVlTLCBfZXh0ZW5kQnlSZWYsIGV4dGVuZFRlbXBsYXRlO1xuTk9UX0RFRVBfS0VZUyA9IFsncmVsYXRlZEluc3RhbmNlJywgJ3JlbGF0ZWQnLCAnZGF0YSddO1xuTk9UX0tFWVMgPSBbJ2NoaWxkcmVuJywgJ19jaGlsZFJlZnMnXTtcbnZhciBleHRlbmRUZW1wbGF0ZSQxID0gZXh0ZW5kVGVtcGxhdGUgPSBmdW5jdGlvbiBleHRlbmRUZW1wbGF0ZShjdXJyZW50T3B0cywgbmV3T3B0cywgZ2xvYmFsT3B0cykge1xuICB2YXIgY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGRyZW4sIGdsb2JhbE9wdHNUcmFuc2Zvcm0sIGluZGV4LCBtYXhMZW5ndGgsIG5lZWRzVGVtcGxhdGVXcmFwLCBuZXdDaGlsZCwgbmV3Q2hpbGRQcm9jZXNzZWQsIG5ld0NoaWxkcmVuLCBub0NoYW5nZXMsIG91dHB1dCwgcmVmLCByZW1haW5pbmdOZXdDaGlsZHJlbjtcblxuICBpZiAoZ2xvYmFsT3B0cykge1xuICAgIGdsb2JhbE9wdHNUcmFuc2Zvcm0gPSB7XG4gICAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChvcHRzLCBnbG9iYWxPcHRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKElTJDEuYXJyYXkobmV3T3B0cykpIHtcbiAgICBuZXdPcHRzID0gcGFyc2VUcmVlJDEobmV3T3B0cywgZmFsc2UpO1xuICB9IGVsc2UgaWYgKG5ld09wdHMgJiYgIW1hdGNoZXNTY2hlbWEobmV3T3B0cykpIHtcbiAgICBuZXdPcHRzID0ge1xuICAgICAgb3B0aW9uczogbmV3T3B0c1xuICAgIH07XG4gIH1cblxuICBvdXRwdXQgPSBleHRlbmQuZGVlcC5udWxsRGVsZXRlcy5ub3RLZXlzKE5PVF9LRVlTKS5ub3REZWVwKE5PVF9ERUVQX0tFWVMpLnRyYW5zZm9ybShnbG9iYWxPcHRzVHJhbnNmb3JtKS5jbG9uZShjdXJyZW50T3B0cywgbmV3T3B0cyk7XG4gIGN1cnJlbnRDaGlsZHJlbiA9IGN1cnJlbnRPcHRzLmNoaWxkcmVuO1xuICBuZXdDaGlsZHJlbiA9IChuZXdPcHRzICE9IG51bGwgPyBuZXdPcHRzLmNoaWxkcmVuIDogdm9pZCAwKSB8fCBbXTtcbiAgb3V0cHV0LmNoaWxkcmVuID0gW107XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKElTJDEuYXJyYXkobmV3Q2hpbGRyZW4pKSB7XG4gICAgbWF4TGVuZ3RoID0gTWF0aC5tYXgoY3VycmVudENoaWxkcmVuLmxlbmd0aCwgbmV3Q2hpbGRyZW4ubGVuZ3RoKTtcbiAgICBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKCsraW5kZXggIT09IG1heExlbmd0aCkge1xuICAgICAgbmVlZHNUZW1wbGF0ZVdyYXAgPSBub0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZHJlbltpbmRleF07XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkcmVuW2luZGV4XTtcblxuICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICBjYXNlICFJUyQxLnRlbXBsYXRlKG5ld0NoaWxkKTpcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZDtcblxuICAgICAgICAgIGNhc2UgIUlTJDEuYXJyYXkobmV3Q2hpbGQpOlxuICAgICAgICAgICAgcmV0dXJuIG5lZWRzVGVtcGxhdGVXcmFwID0gcGFyc2VUcmVlJDEobmV3Q2hpbGQpO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5zdHJpbmcobmV3Q2hpbGQpOlxuICAgICAgICAgICAgcmV0dXJuIG5lZWRzVGVtcGxhdGVXcmFwID0ge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBuZXdDaGlsZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FzZSAhKCFuZXdDaGlsZCAmJiAhZ2xvYmFsT3B0cyk6XG4gICAgICAgICAgICByZXR1cm4gbm9DaGFuZ2VzID0gdHJ1ZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmVlZHNUZW1wbGF0ZVdyYXAgPSBuZXdDaGlsZCB8fCB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KCk7XG5cbiAgICAgIGlmIChub0NoYW5nZXMpIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBjdXJyZW50Q2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKG5lZWRzVGVtcGxhdGVXcmFwKSB7XG4gICAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkID0gY3VycmVudENoaWxkID8gY3VycmVudENoaWxkLmV4dGVuZChuZXdDaGlsZFByb2Nlc3NlZCwgZ2xvYmFsT3B0cykgOiBuZXcgUXVpY2tUZW1wbGF0ZSQxKGV4dGVuZC5jbG9uZShzY2hlbWEsIG5ld0NoaWxkUHJvY2Vzc2VkKSk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5jaGlsZHJlbi5wdXNoKG5ld0NoaWxkUHJvY2Vzc2VkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoSVMkMS5vYmplY3QobmV3Q2hpbGRyZW4pKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBleHRlbmQuYWxsb3dOdWxsLmNsb25lKG5ld0NoaWxkcmVuKTtcbiAgICBvdXRwdXQuY2hpbGRyZW4gPSBfZXh0ZW5kQnlSZWYobmV3Q2hpbGRyZW4sIGN1cnJlbnRDaGlsZHJlbiwgZ2xvYmFsT3B0cyk7XG4gICAgcmVtYWluaW5nTmV3Q2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcblxuICAgIGZvciAocmVmIGluIHJlbWFpbmluZ05ld0NoaWxkcmVuKSB7XG4gICAgICBuZXdDaGlsZCA9IHJlbWFpbmluZ05ld0NoaWxkcmVuW3JlZl07XG4gICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IElTJDEub2JqZWN0UGxhaW4obmV3Q2hpbGQpICYmICFJUyQxLnRlbXBsYXRlKG5ld0NoaWxkKSA/IG5ld0NoaWxkIDogcGFyc2VUcmVlJDEobmV3Q2hpbGQpO1xuICAgICAgb3V0cHV0LmNoaWxkcmVuLnB1c2gobmV3IFF1aWNrVGVtcGxhdGUkMShuZXdDaGlsZFByb2Nlc3NlZCkpO1xuICAgICAgZGVsZXRlIHJlbWFpbmluZ05ld0NoaWxkcmVuW3JlZl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbl9leHRlbmRCeVJlZiA9IGZ1bmN0aW9uIGV4dGVuZEJ5UmVmKG5ld0NoaWxkcmVuUmVmcywgY3VycmVudENoaWxkcmVuLCBnbG9iYWxPcHRzKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQsIGksIGxlbiwgbmV3Q2hpbGQsIG5ld0NoaWxkUHJvY2Vzc2VkLCBvdXRwdXQ7XG5cbiAgaWYgKCFjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRDaGlsZHJlbjtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGN1cnJlbnRDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkcmVuW2ldO1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlblJlZnNbY3VycmVudENoaWxkLnJlZl07XG5cbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGN1cnJlbnRDaGlsZC5leHRlbmQobmV3Q2hpbGQsIGdsb2JhbE9wdHMpO1xuICAgICAgICBkZWxldGUgbmV3Q2hpbGRyZW5SZWZzW2N1cnJlbnRDaGlsZC5yZWZdO1xuICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgbmV3Q2hpbGRyZW5SZWZzW2N1cnJlbnRDaGlsZC5yZWZdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNhc2UgIWdsb2JhbE9wdHM6XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hpbGQuZXh0ZW5kKG51bGwsIGdsb2JhbE9wdHMpO1xuXG4gICAgICAgICAgICBjYXNlICFPYmplY3Qua2V5cyhuZXdDaGlsZHJlblJlZnMpLmxlbmd0aDpcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGlsZC5leHRlbmQoKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgIH1cblxuICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQuY2hpbGRyZW4gPSBfZXh0ZW5kQnlSZWYobmV3Q2hpbGRyZW5SZWZzLCBuZXdDaGlsZFByb2Nlc3NlZC5jaGlsZHJlbik7XG4gICAgICBvdXRwdXQucHVzaChuZXdDaGlsZFByb2Nlc3NlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTt2YXIgUXVpY2tUZW1wbGF0ZTtcbnZhciBRdWlja1RlbXBsYXRlJDEgPSBRdWlja1RlbXBsYXRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUXVpY2tUZW1wbGF0ZShjb25maWcsIGlzVHJlZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja1RlbXBsYXRlKTtcblxuICAgIGlmIChJUyQxLnRlbXBsYXRlKGNvbmZpZykpIHtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgY29uZmlnID0gaXNUcmVlID8gcGFyc2VUcmVlJDEoY29uZmlnKSA6IGNvbmZpZztcbiAgICBleHRlbmQodGhpcywgY29uZmlnKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWlja1RlbXBsYXRlLCBbe1xuICAgIGtleTogXCJleHRlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kKG5ld1ZhbHVlcywgZ2xvYmFsT3B0cykge1xuICAgICAgcmV0dXJuIG5ldyBRdWlja1RlbXBsYXRlKGV4dGVuZFRlbXBsYXRlJDEodGhpcywgbmV3VmFsdWVzLCBnbG9iYWxPcHRzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwYXduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwYXduKG5ld1ZhbHVlcywgZ2xvYmFsT3B0cywgZGF0YSkge1xuICAgICAgdmFyIGNoaWxkLCBjaGlsZERhdGEsIGNoaWxkcmVuLCBlbGVtZW50LCBpLCBsZW4sIG9wdGlvbnMsIHR5cGU7XG5cbiAgICAgIGlmIChuZXdWYWx1ZXMgJiYgbmV3VmFsdWVzLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ld1ZhbHVlcy5kYXRhO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdWYWx1ZXMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5ld1ZhbHVlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1ZhbHVlcyB8fCBnbG9iYWxPcHRzKSB7XG4gICAgICAgIHZhciBfZXh0ZW5kVGVtcGxhdGUgPSBleHRlbmRUZW1wbGF0ZSQxKHRoaXMsIG5ld1ZhbHVlcywgZ2xvYmFsT3B0cyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IF9leHRlbmRUZW1wbGF0ZS5vcHRpb25zO1xuICAgICAgICBjaGlsZHJlbiA9IF9leHRlbmRUZW1wbGF0ZS5jaGlsZHJlbjtcbiAgICAgICAgdHlwZSA9IF9leHRlbmRUZW1wbGF0ZS50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kLmNsb25lKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gX3F1aWNrZG9tLmNyZWF0ZShbdHlwZSwgb3B0aW9uc10pO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGREYXRhID0gb3B0aW9ucy5wYXNzRGF0YVRvQ2hpbGRyZW4gPyBkYXRhIHx8IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmQoY2hpbGQuc3Bhd24obnVsbCwgbnVsbCwgY2hpbGREYXRhKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5fcG9zdENyZWF0aW9uKGRhdGEpO1xuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVpY2tUZW1wbGF0ZTtcbn0oKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbmlmIChRdWlja1RlbXBsYXRlLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja1RlbXBsYXRlLm5hbWUgPSAnUXVpY2tUZW1wbGF0ZSc7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWlja1RlbXBsYXRlLnByb3RvdHlwZSwgJ2NoaWxkJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRSZWZzIHx8IF9nZXRDaGlsZFJlZnModGhpcyk7XG4gIH1cbn0pO1xuXG5fcXVpY2tkb20udGVtcGxhdGUgPSBmdW5jdGlvbiAodHJlZSkge1xuICByZXR1cm4gbmV3IFF1aWNrVGVtcGxhdGUodHJlZSwgdHJ1ZSk7XG59O1xuXG5fcXVpY2tkb20uaXNUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIElTJDEudGVtcGxhdGUodGFyZ2V0KTtcbn07dmFyIFF1aWNrQmF0Y2g7XG52YXIgUXVpY2tCYXRjaCQxID0gUXVpY2tCYXRjaCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1aWNrQmF0Y2goZWxlbWVudHMsIHJldHVyblJlc3VsdHMxKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrQmF0Y2gpO1xuXG4gICAgdGhpcy5yZXR1cm5SZXN1bHRzID0gcmV0dXJuUmVzdWx0czE7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBfcXVpY2tkb20oZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1aWNrQmF0Y2gsIFt7XG4gICAga2V5OiBcInJldmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXR1cm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldHVybihyZXR1cm5OZXh0KSB7XG4gICAgICBpZiAocmV0dXJuTmV4dCkge1xuICAgICAgICB0aGlzLnJldHVyblJlc3VsdHMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHRzO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWlja0JhdGNoO1xufSgpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKFF1aWNrQmF0Y2gubmFtZSA9PSBudWxsKSB7XG4gIFF1aWNrQmF0Y2gubmFtZSA9ICdRdWlja0JhdGNoJztcbn1cblxuT2JqZWN0LmtleXMoUXVpY2tFbGVtZW50JDIucHJvdG90eXBlKS5jb25jYXQoJ2NzcycsICdyZXBsYWNlV2l0aCcsICdodG1sJywgJ3RleHQnKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgcmV0dXJuIFF1aWNrQmF0Y2gucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICB2YXIgZWxlbWVudCwgcmVzdWx0cztcblxuICAgIHJlc3VsdHMgPSB0aGlzLmxhc3RSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzMTtcbiAgICAgIHJlZiA9IHRoaXMuZWxlbWVudHM7XG4gICAgICByZXN1bHRzMSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHJlZltpXTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSAnaHRtbCcgfHwgbWV0aG9kID09PSAndGV4dCcpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMxLnB1c2goZWxlbWVudFttZXRob2RdID0gbmV3VmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzMS5wdXNoKGVsZW1lbnRbbWV0aG9kXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZWxlbWVudDtcblxuICAgICAgICAgIHJlc3VsdHMxLnB1c2goKF9lbGVtZW50ID0gZWxlbWVudClbbWV0aG9kXS5hcHBseShfZWxlbWVudCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLnJldHVyblJlc3VsdHMpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcblxuX3F1aWNrZG9tLmJhdGNoID0gZnVuY3Rpb24gKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzKSB7XG4gIGlmICghSVMkMS5pdGVyYWJsZShlbGVtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaDogZXhwZWN0ZWQgYW4gaXRlcmFibGUsIGdvdCBcIi5jb25jYXQoU3RyaW5nKGVsZW1lbnRzKSkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBRdWlja0JhdGNoKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzKTtcbn07dmFyIHZlcnNpb24gPSBcIjEuMC45NFwiO3ZhciBTSE9SVENVVFMsIGksIGxlbiwgc2hvcnRjdXQ7XG5TSE9SVENVVFMgPSBbJ2xpbms6YScsICdhbmNob3I6YScsICdhJywgJ3RleHQnLCAnZGl2JywgJ3NwYW4nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2Zvb3RlcicsICdzZWN0aW9uJywgJ2J1dHRvbicsICdicicsICd1bCcsICdvbCcsICdsaScsICdmaWVsZHNldCcsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnb3B0aW9uJywgJ2Zvcm0nLCAnZnJhbWUnLCAnaHInLCAnaWZyYW1lJywgJ2ltZycsICdwaWN0dXJlJywgJ21haW4nLCAnbmF2JywgJ21ldGEnLCAnb2JqZWN0JywgJ3ByZScsICdzdHlsZScsICd0YWJsZScsICd0Ym9keScsICd0aCcsICd0cicsICd0ZCcsICd0Zm9vdCcsIC8vICd0ZW1wbGF0ZSdcbid2aWRlbyddO1xuXG5mb3IgKGkgPSAwLCBsZW4gPSBTSE9SVENVVFMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgc2hvcnRjdXQgPSBTSE9SVENVVFNbaV07XG5cbiAgKGZ1bmN0aW9uIChzaG9ydGN1dCkge1xuICAgIHZhciBwcm9wLCBzcGxpdCwgdHlwZTtcbiAgICBwcm9wID0gdHlwZSA9IHNob3J0Y3V0O1xuXG4gICAgaWYgKGluY2x1ZGVzKHNob3J0Y3V0LCAnOicpKSB7XG4gICAgICBzcGxpdCA9IHNob3J0Y3V0LnNwbGl0KCc6Jyk7XG4gICAgICBwcm9wID0gc3BsaXRbMF07XG4gICAgICB0eXBlID0gc3BsaXRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWlja2RvbVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBbdHlwZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICB9KShzaG9ydGN1dCk7XG59aW5pdChRdWlja0VsZW1lbnQkMiwgUXVpY2tXaW5kb3ckMik7XG5fcXVpY2tkb20uUXVpY2tFbGVtZW50ID0gUXVpY2tFbGVtZW50JDI7XG5fcXVpY2tkb20uUXVpY2tUZW1wbGF0ZSA9IFF1aWNrVGVtcGxhdGUkMTtcbl9xdWlja2RvbS5RdWlja1dpbmRvdyA9IFF1aWNrV2luZG93JDI7XG5fcXVpY2tkb20uUXVpY2tCYXRjaCA9IFF1aWNrQmF0Y2gkMTtcbl9xdWlja2RvbS52ZXJzaW9uID0gdmVyc2lvbjtcbl9xdWlja2RvbS5DU1MgPSBDU1M7XG52YXIgcXVpY2tkb20gPSBfcXVpY2tkb207IC8vIGV4cG9ydCB7cXVpY2tkb20gYXMgZGVmYXVsdCwgUXVpY2tFbGVtZW50LCBRdWlja1RlbXBsYXRlLCBRdWlja1dpbmRvdywgUXVpY2tCYXRjaH1cbmV4cG9ydCBkZWZhdWx0IHF1aWNrZG9tOyIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gKHByb21pc2UsIG9uRmluYWxseSkgPT4ge1xuXHRvbkZpbmFsbHkgPSBvbkZpbmFsbHkgfHwgKCgpID0+IHt9KTtcblxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKFxuXHRcdHZhbCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdHJlc29sdmUob25GaW5hbGx5KCkpO1xuXHRcdH0pLnRoZW4oKCkgPT4gdmFsKSxcblx0XHRlcnIgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHRyZXNvbHZlKG9uRmluYWxseSgpKTtcblx0XHR9KS50aGVuKCgpID0+IHtcblx0XHRcdHRocm93IGVycjtcblx0XHR9KVxuXHQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBGaW5hbGx5ID0gcmVxdWlyZSgncC1maW5hbGx5Jyk7XG5cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb21pc2UsIG1zLCBmYWxsYmFjaykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAodHlwZW9mIG1zICE9PSAnbnVtYmVyJyAmJiBtcyA+PSAwKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYG1zYCB0byBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuXHR9XG5cblx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXNvbHZlKGZhbGxiYWNrKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdzdHJpbmcnID8gZmFsbGJhY2sgOiBgUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgJHttc30gbWlsbGlzZWNvbmRzYDtcblx0XHRjb25zdCBlcnIgPSBmYWxsYmFjayBpbnN0YW5jZW9mIEVycm9yID8gZmFsbGJhY2sgOiBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuXG5cdFx0cmVqZWN0KGVycik7XG5cdH0sIG1zKTtcblxuXHRwRmluYWxseShcblx0XHRwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSxcblx0XHQoKSA9PiB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdH1cblx0KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwVGltZW91dCA9IHJlcXVpcmUoJ3AtdGltZW91dCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChlbWl0dGVyLCBldmVudCwgb3B0cykgPT4ge1xuXHRsZXQgY2FuY2VsO1xuXG5cdGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9wdHMgPSB7ZmlsdGVyOiBvcHRzfTtcblx0XHR9XG5cblx0XHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRyZWplY3Rpb25FdmVudHM6IFsnZXJyb3InXSxcblx0XHRcdG11bHRpQXJnczogZmFsc2Vcblx0XHR9LCBvcHRzKTtcblxuXHRcdGxldCBhZGRMaXN0ZW5lciA9IGVtaXR0ZXIub24gfHwgZW1pdHRlci5hZGRMaXN0ZW5lciB8fCBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0bGV0IHJlbW92ZUxpc3RlbmVyID0gZW1pdHRlci5vZmYgfHwgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciB8fCBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cblx0XHRpZiAoIWFkZExpc3RlbmVyIHx8ICFyZW1vdmVMaXN0ZW5lcikge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRW1pdHRlciBpcyBub3QgY29tcGF0aWJsZScpO1xuXHRcdH1cblxuXHRcdGFkZExpc3RlbmVyID0gYWRkTGlzdGVuZXIuYmluZChlbWl0dGVyKTtcblx0XHRyZW1vdmVMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyLmJpbmQoZW1pdHRlcik7XG5cblx0XHRjb25zdCByZXNvbHZlSGFuZGxlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdHZhbHVlID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYW5jZWwoKTtcblx0XHRcdHJlc29sdmUodmFsdWUpO1xuXHRcdH07XG5cblx0XHRjb25zdCByZWplY3RIYW5kbGVyID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0Y2FuY2VsKCk7XG5cblx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRyZWplY3QoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWplY3QocmVhc29uKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y2FuY2VsID0gKCkgPT4ge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoZXZlbnQsIHJlc29sdmVIYW5kbGVyKTtcblxuXHRcdFx0Zm9yIChjb25zdCByZWplY3Rpb25FdmVudCBvZiBvcHRzLnJlamVjdGlvbkV2ZW50cykge1xuXHRcdFx0XHRyZW1vdmVMaXN0ZW5lcihyZWplY3Rpb25FdmVudCwgcmVqZWN0SGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGV2ZW50LCByZXNvbHZlSGFuZGxlcik7XG5cblx0XHRmb3IgKGNvbnN0IHJlamVjdGlvbkV2ZW50IG9mIG9wdHMucmVqZWN0aW9uRXZlbnRzKSB7XG5cdFx0XHRhZGRMaXN0ZW5lcihyZWplY3Rpb25FdmVudCwgcmVqZWN0SGFuZGxlcik7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXQuY2FuY2VsID0gY2FuY2VsO1xuXG5cdGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiBwVGltZW91dChyZXQsIG9wdHMudGltZW91dCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY3JlYXRlRW5kQnJlYWsodmFsdWUpIHtcblx0dmFyIGluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXHRpbnN0YW5jZS52YWx1ZSA9IHZhbHVlO1xuXHRpbnN0YW5jZS5fX2lzRW5kQnJlYWsgPSB0cnVlO1xuXHRyZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCkge1xuXHR2YXIgZXJyID0gY3JlYXRlRW5kQnJlYWsodmFsKTtcblx0dGhyb3cgZXJyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZW5kID0gZnVuY3Rpb24gKGVycikge1xuXHRpZiAoZXJyLl9faXNFbmRCcmVhaykge1xuXHRcdHJldHVybiBlcnIudmFsdWU7XG5cdH1cblxuXHR0aHJvdyBlcnI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgdHlwZXNcbiAgaWYgKCB0eXBlICYmICgndHJhbnNpdGlvbicgPT09IHR5cGUgfHwgJ3RyYW5zJyA9PT0gdHlwZSkgKSB7XG4gICAgdHlwZXMgPSB7XG4gICAgICAnT1RyYW5zaXRpb24nOiAgICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICdNb3pUcmFuc2l0aW9uJzogICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ3RyYW5zaXRpb24nOiAgICAgICAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIGFuaW1hdGlvbiBpcyBkZWZhdWx0XG4gICAgdHlwZXMgPSB7XG4gICAgICAnT0FuaW1hdGlvbic6ICAgICAgJ29BbmltYXRpb25FbmQnLFxuICAgICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICAgJ01vekFuaW1hdGlvbic6ICAgICdhbmltYXRpb25lbmQnLFxuICAgICAgJ2FuaW1hdGlvbic6ICAgICAgICdhbmltYXRpb25lbmQnXG4gICAgfVxuICB9XG4gIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmFrZScpXG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0cmFucykge1xuICAgIHJldHVybiB1bmRlZmluZWQgIT09IGVsZW0uc3R5bGVbdHJhbnNdPyB0eXBlc1t0cmFuc106IHByZXZcbiAgfSwgJycpXG59XG4iLCIvKipcbiAqIGV2ZW50LWxpdGUuanMgLSBMaWdodC13ZWlnaHQgRXZlbnRFbWl0dGVyIChsZXNzIHRoYW4gMUtCIHdoZW4gZ3ppcHBlZClcbiAqXG4gKiBAY29weXJpZ2h0IFl1c3VrZSBLYXdhc2FraVxuICogQGxpY2Vuc2UgTUlUXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2thd2FuZXQvZXZlbnQtbGl0ZVxuICogQHNlZSBodHRwOi8va2F3YW5ldC5naXRodWIuaW8vZXZlbnQtbGl0ZS9FdmVudExpdGUuaHRtbFxuICogQGV4YW1wbGVcbiAqIHZhciBFdmVudExpdGUgPSByZXF1aXJlKFwiZXZlbnQtbGl0ZVwiKTtcbiAqXG4gKiBmdW5jdGlvbiBNeUNsYXNzKCkgey4uLn0gICAgICAgICAgICAgLy8geW91ciBjbGFzc1xuICpcbiAqIEV2ZW50TGl0ZS5taXhpbihNeUNsYXNzLnByb3RvdHlwZSk7ICAvLyBpbXBvcnQgZXZlbnQgbWV0aG9kc1xuICpcbiAqIHZhciBvYmogPSBuZXcgTXlDbGFzcygpO1xuICogb2JqLm9uKFwiZm9vXCIsIGZ1bmN0aW9uKCkgey4uLn0pOyAgICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyXG4gKiBvYmoub25jZShcImJhclwiLCBmdW5jdGlvbigpIHsuLi59KTsgICAvLyBhZGQgb25lLXRpbWUgZXZlbnQgbGlzdGVuZXJcbiAqIG9iai5lbWl0KFwiZm9vXCIpOyAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIGV2ZW50XG4gKiBvYmouZW1pdChcImJhclwiKTsgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwYXRjaCBhbm90aGVyIGV2ZW50XG4gKiBvYmoub2ZmKFwiZm9vXCIpOyAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJcbiAqL1xuXG5mdW5jdGlvbiBFdmVudExpdGUoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFdmVudExpdGUpKSByZXR1cm4gbmV3IEV2ZW50TGl0ZSgpO1xufVxuXG4oZnVuY3Rpb24oRXZlbnRMaXRlKSB7XG4gIC8vIGV4cG9ydCB0aGUgY2xhc3MgZm9yIG5vZGUuanNcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBtb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXRlO1xuXG4gIC8vIHByb3BlcnR5IG5hbWUgdG8gaG9sZCBsaXN0ZW5lcnNcbiAgdmFyIExJU1RFTkVSUyA9IFwibGlzdGVuZXJzXCI7XG5cbiAgLy8gbWV0aG9kcyB0byBleHBvcnRcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgb246IG9uLFxuICAgIG9uY2U6IG9uY2UsXG4gICAgb2ZmOiBvZmYsXG4gICAgZW1pdDogZW1pdFxuICB9O1xuXG4gIC8vIG1peGluIHRvIHNlbGZcbiAgbWl4aW4oRXZlbnRMaXRlLnByb3RvdHlwZSk7XG5cbiAgLy8gZXhwb3J0IG1peGluIGZ1bmN0aW9uXG4gIEV2ZW50TGl0ZS5taXhpbiA9IG1peGluO1xuXG4gIC8qKlxuICAgKiBJbXBvcnQgb24oKSwgb25jZSgpLCBvZmYoKSBhbmQgZW1pdCgpIG1ldGhvZHMgaW50byB0YXJnZXQgb2JqZWN0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gRXZlbnRMaXRlLm1peGluXG4gICAqIEBwYXJhbSB0YXJnZXQge1Byb3RvdHlwZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIHRhcmdldFtrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQGZ1bmN0aW9uIEV2ZW50TGl0ZS5wcm90b3R5cGUub25cbiAgICogQHBhcmFtIHR5cGUge3N0cmluZ31cbiAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufVxuICAgKiBAcmV0dXJucyB7RXZlbnRMaXRlfSBTZWxmIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICovXG5cbiAgZnVuY3Rpb24gb24odHlwZSwgZnVuYykge1xuICAgIGdldExpc3RlbmVycyh0aGlzLCB0eXBlKS5wdXNoKGZ1bmMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvbmUtdGltZSBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQGZ1bmN0aW9uIEV2ZW50TGl0ZS5wcm90b3R5cGUub25jZVxuICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gZnVuYyB7RnVuY3Rpb259XG4gICAqIEByZXR1cm5zIHtFdmVudExpdGV9IFNlbGYgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cblxuICBmdW5jdGlvbiBvbmNlKHR5cGUsIGZ1bmMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgd3JhcC5vcmlnaW5hbExpc3RlbmVyID0gZnVuYztcbiAgICBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSkucHVzaCh3cmFwKTtcbiAgICByZXR1cm4gdGhhdDtcblxuICAgIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgICBvZmYuY2FsbCh0aGF0LCB0eXBlLCB3cmFwKTtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gRXZlbnRMaXRlLnByb3RvdHlwZS5vZmZcbiAgICogQHBhcmFtIFt0eXBlXSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gW2Z1bmNdIHtGdW5jdGlvbn1cbiAgICogQHJldHVybnMge0V2ZW50TGl0ZX0gU2VsZiBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9mZih0eXBlLCBmdW5jKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBsaXN0bmVycztcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGF0W0xJU1RFTkVSU107XG4gICAgfSBlbHNlIGlmICghZnVuYykge1xuICAgICAgbGlzdG5lcnMgPSB0aGF0W0xJU1RFTkVSU107XG4gICAgICBpZiAobGlzdG5lcnMpIHtcbiAgICAgICAgZGVsZXRlIGxpc3RuZXJzW3R5cGVdO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RuZXJzKS5sZW5ndGgpIHJldHVybiBvZmYuY2FsbCh0aGF0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdG5lcnMgPSBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSwgdHJ1ZSk7XG4gICAgICBpZiAobGlzdG5lcnMpIHtcbiAgICAgICAgbGlzdG5lcnMgPSBsaXN0bmVycy5maWx0ZXIobmUpO1xuICAgICAgICBpZiAoIWxpc3RuZXJzLmxlbmd0aCkgcmV0dXJuIG9mZi5jYWxsKHRoYXQsIHR5cGUpO1xuICAgICAgICB0aGF0W0xJU1RFTkVSU11bdHlwZV0gPSBsaXN0bmVycztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoYXQ7XG5cbiAgICBmdW5jdGlvbiBuZSh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdCAhPT0gZnVuYyAmJiB0ZXN0Lm9yaWdpbmFsTGlzdGVuZXIgIT09IGZ1bmM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoICh0cmlnZ2VyKSBhbiBldmVudC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIEV2ZW50TGl0ZS5wcm90b3R5cGUuZW1pdFxuICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gW3ZhbHVlXSB7Kn1cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBhIGxpc3RlbmVyIHJlY2VpdmVkIHRoZSBldmVudFxuICAgKi9cblxuICBmdW5jdGlvbiBlbWl0KHR5cGUsIHZhbHVlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSwgdHJ1ZSk7XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgYXJnbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoYXJnbGVuID09PSAxKSB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCh6ZXJvYXJnKTtcbiAgICB9IGVsc2UgaWYgKGFyZ2xlbiA9PT0gMikge1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2gob25lYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2gobW9yZWFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gISFsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gemVyb2FyZyhmdW5jKSB7XG4gICAgICBmdW5jLmNhbGwodGhhdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25lYXJnKGZ1bmMpIHtcbiAgICAgIGZ1bmMuY2FsbCh0aGF0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9yZWFyZ3MoZnVuYykge1xuICAgICAgZnVuYy5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSwgcmVhZG9ubHkpIHtcbiAgICBpZiAocmVhZG9ubHkgJiYgIXRoYXRbTElTVEVORVJTXSkgcmV0dXJuO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGF0W0xJU1RFTkVSU10gfHwgKHRoYXRbTElTVEVORVJTXSA9IHt9KTtcbiAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdIHx8IChsaXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gIH1cblxufSkoRXZlbnRMaXRlKTtcbiIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0IHByb21pc2VFdmVudCBmcm9tJ3AtZXZlbnQnO2ltcG9ydCBwcm9taXNlQnJlYWsgZnJvbSdwcm9taXNlLWJyZWFrJztpbXBvcnQgSVNfIGZyb20nQGRhbmllbGthbGVuL2lzJztpbXBvcnQgZGV0ZWN0QW5pbWF0aW9uIGZyb20nZGV0ZWN0LWFuaW1hdGlvbi1lbmQtaGVscGVyJztpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20nZXZlbnQtbGl0ZSc7dmFyIElTO1xuSVMgPSBJU18uY3JlYXRlKCduYXRpdmVzJyk7XG5JUy5sb2FkKHtcbiAgJ2RvbUVsJzogRE9NLmlzRWwsXG4gICdxdWlja0VsJzogRE9NLmlzUXVpY2tFbCxcbiAgJ3RlbXBsYXRlJzogRE9NLmlzVGVtcGxhdGVcbn0pO1xudmFyIElTJDEgPSBJUzt2YXIgcG9wdXAgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ3BvcHVwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDFlNCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICB3aWR0aDogJzEwMHZ3JyxcbiAgICBoZWlnaHQ6IDAsXG4gICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIGBhbGwgMC4wMDFzIGxpbmVhciAke3BvcHVwLnNldHRpbmdzLmFuaW1hdGlvbiArIDF9bXNgO1xuICAgIH0sXG4gICAgJG9wZW46IHtcbiAgICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdhbGwgMC4wMDFzIGxpbmVhciAwcyc7XG4gICAgICB9LFxuICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgfVxuICB9XG59XSk7XG52YXIgb3ZlcmxheSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnb3ZlcmxheScsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgekluZGV4OiAxLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHdpZHRoOiAnMTAwdncnLFxuICAgIG1pbkhlaWdodDogJzEwMHZoJyxcbiAgICBvcGFjaXR5OiAwLFxuICAgIGJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3Mub3ZlcmxheUNvbG9yO1xuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gYG9wYWNpdHkgJHtwb3B1cC5zZXR0aW5ncy5hbmltYXRpb259bXNgO1xuICAgIH0sXG4gICAgJG9wZW46IHtcbiAgICAgIG9wYWNpdHk6IDFcbiAgICB9XG4gIH1cbn1dKTtcbnZhciBjb250ZW50ID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdjb250ZW50JyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDIsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICBtYXJnaW46ICcwIGF1dG8nLFxuICAgIHBhZGRpbmc6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNvbnRlbnRQYWRkaW5nO1xuICAgIH0sXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAocG9wdXApIHtcbiAgICAgIHZhciBkdXJhdGlvbjtcbiAgICAgIGR1cmF0aW9uID0gcG9wdXAuc2V0dGluZ3MuYW5pbWF0aW9uO1xuICAgICAgcmV0dXJuIGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcywgLXdlYmtpdC10cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcywgb3BhY2l0eSAke2R1cmF0aW9ufW1zYDtcbiAgICB9LFxuICAgICRvcGVuOiB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgXzogMFxuICAgIH0sXG4gICAgJGNlbnRlclBsYWNlbWVudDoge1xuICAgICAgbGVmdDogJzUwJScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJ1xuICAgIH0sXG4gICAgJHRvcFBsYWNlbWVudDoge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogJzUwJScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTEwMCUpJyxcbiAgICAgICRvcGVuOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgwKScsXG4gICAgICAgIF86IDFcbiAgICAgIH1cbiAgICB9LFxuICAgICRib3R0b21QbGFjZW1lbnQ6IHtcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDEwMCUpJyxcbiAgICAgICRvcGVuOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgwKScsXG4gICAgICAgIF86IDJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVyczoge1xuICAgIHBsYWNlbWVudDogZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUoYCR7cGxhY2VtZW50fVBsYWNlbWVudGAsIHRydWUpO1xuICAgIH0sXG4gICAgY29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZChjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGV2ZW50czoge1xuICAgICdzdGF0ZUNoYW5nZTp2aXNpYmxlJzogZnVuY3Rpb24gKHZpc2libGUpIHtcbiAgICAgIGlmICh2aXNpYmxlICYmIERPTSh0aGlzKS5yZWxhdGVkLnNldHRpbmdzLnBsYWNlbWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIERPTSh0aGlzKS5yZWxhdGVkLmFsaWduVG9DZW50ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dKTtcbnZhciBjbG9zZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnY2xvc2UnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGRpc3BsYXk6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgaWYgKHBvcHVwLnNldHRpbmdzLmNsb3NlLnNob3cpIHtcbiAgICAgICAgcmV0dXJuICdibG9jayc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9wOiBmdW5jdGlvbiAocG9wdXApIHtcbiAgICAgIGlmIChwb3B1cC5zZXR0aW5ncy5jbG9zZS5pbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNsb3NlLnBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2Uuc2l6ZSAqIDIuNSAqIC0xO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgaWYgKHBvcHVwLnNldHRpbmdzLmNsb3NlLmluc2lkZSkge1xuICAgICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2UucGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNsb3NlLnNpemU7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNsb3NlLnNpemU7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2UuY29sb3I7XG4gICAgfVxuICB9XG59LCBbJypzdmcnLCB7XG4gIGF0dHJzOiB7XG4gICAgdmlld0JveDogXCIwIDAgNDkyIDQ5MlwiXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJ1xuICB9XG59LCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIGQ6ICdNMzAwLjIgMjQ2TDQ4NC4xIDYyYzUuMS01LjEgNy45LTExLjggNy45LTE5IDAtNy4yLTIuOC0xNC03LjktMTlMNDY4IDcuOWMtNS4xLTUuMS0xMS44LTcuOS0xOS03LjkgLTcuMiAwLTE0IDIuOC0xOSA3LjlMMjQ2IDE5MS44IDYyIDcuOWMtNS4xLTUuMS0xMS44LTcuOS0xOS03LjkgLTcuMiAwLTE0IDIuOC0xOSA3LjlMNy45IDI0Yy0xMC41IDEwLjUtMTAuNSAyNy42IDAgMzguMUwxOTEuOCAyNDYgNy45IDQzMGMtNS4xIDUuMS03LjkgMTEuOC03LjkgMTkgMCA3LjIgMi44IDE0IDcuOSAxOWwxNi4xIDE2LjFjNS4xIDUuMSAxMS44IDcuOSAxOSA3LjkgNy4yIDAgMTQtMi44IDE5LTcuOWwxODQtMTg0IDE4NCAxODRjNS4xIDUuMSAxMS44IDcuOSAxOSA3LjloMGM3LjIgMCAxNC0yLjggMTktNy45bDE2LjEtMTYuMWM1LjEtNS4xIDcuOS0xMS44IDcuOS0xOSAwLTcuMi0yLjgtMTQtNy45LTE5TDMwMC4yIDI0NnonXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgZmlsbDogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2UuY29sb3I7XG4gICAgfVxuICB9XG59XV1dKTtcbnZhciBib2R5V3JhcHBlciA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgaWQ6ICdib2R5V3JhcHBlcicsXG4gIHBhc3NTdGF0ZVRvQ2hpbGRyZW46IGZhbHNlLFxuICBzdHlsZToge1xuICAgICRvcGVuOiB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB0b3A6ICcwJ1xuICAgIH1cbiAgfVxufV0pO1xudmFyIGh0bWwgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIGNvbXB1dGVyczoge1xuICAgIGh0bWw6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICByZXR1cm4gdGhpcy5odG1sID0gaHRtbDtcbiAgICB9XG4gIH1cbn1dKTt2YXIgdGVtcGxhdGVzPS8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxwb3B1cDogcG9wdXAsb3ZlcmxheTogb3ZlcmxheSxjb250ZW50OiBjb250ZW50LGNsb3NlOiBjbG9zZSxib2R5V3JhcHBlcjogYm9keVdyYXBwZXIsaHRtbDogaHRtbH0pO3ZhciBleHRlbmRTZXR0aW5ncyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgc2V0dGluZ3MpIHtcbiAgcmV0dXJuIGV4dGVuZC5maWx0ZXIoe1xuICAgIHBsYWNlbWVudDogSVMkMS5zdHJpbmcsXG4gICAgdGVtcGxhdGU6IElTJDEub2JqZWN0UGxhaW4sXG4gICAgY29uZGl0aW9uOiBJUyQxLmZ1bmN0aW9uLFxuICAgIGFuaW1hdGlvbjogSVMkMS5udW1iZXIsXG4gICAgb3ZlcmxheUNvbG9yOiBJUyQxLnN0cmluZyxcbiAgICBvcGVuOiBJUyQxLm9iamVjdFBsYWluLFxuICAgIGNsb3NlOiBJUyQxLm9iamVjdFBsYWluLFxuICAgIHRyaWdnZXJzOiBJUyQxLm9iamVjdFBsYWluXG4gIH0pLmNsb25lLmRlZXAubm90RGVlcCgnY29udGVudCcpKGRlZmF1bHRzLCBzZXR0aW5ncyk7XG59O1xudmFyIHNjaGVkdWxlU2Nyb2xsUmVzZXQgPSBmdW5jdGlvbiAoc2NoZWR1bGVOZXh0KSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsIDApO1xuXG4gICAgaWYgKHNjaGVkdWxlTmV4dCkge1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVTY3JvbGxSZXNldCgpO1xuICAgICAgfSwgc2NoZWR1bGVOZXh0KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciB0cmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGV0ZWN0QW5pbWF0aW9uKCd0cmFuc2l0aW9uJyk7XG59O1xudmFyIHNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZIC0gZG9jdW1lbnRPZmZzZXQoKTtcbn07XG52YXIgZG9jdW1lbnRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZWY7XG4gIHJldHVybiAoKChyZWYgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSAhPSBudWxsID8gcmVmLnRvcCA6IHZvaWQgMCkgfHwgMCkgKyB3aW5kb3cuc2Nyb2xsWTtcbn07XG52YXIgdmlzaWJpbGl0eUFwaUtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICFJUyQxLmRlZmluZWQoZG9jdW1lbnQuaGlkZGVuKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpZGRlbjogJ2hpZGRlbicsXG4gICAgICAgIHZpc2liaWxpdHljaGFuZ2U6ICd2aXNpYmlsaXR5Y2hhbmdlJ1xuICAgICAgfTtcblxuICAgIGNhc2UgIUlTJDEuZGVmaW5lZChkb2N1bWVudC5tc0hpZGRlbik6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoaWRkZW46ICdtc0hpZGRlbicsXG4gICAgICAgIHZpc2liaWxpdHljaGFuZ2U6ICdtc3Zpc2liaWxpdHljaGFuZ2UnXG4gICAgICB9O1xuXG4gICAgY2FzZSAhSVMkMS5kZWZpbmVkKGRvY3VtZW50LndlYmtpdEhpZGRlbik6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoaWRkZW46ICd3ZWJraXRIaWRkZW4nLFxuICAgICAgICB2aXNpYmlsaXR5Y2hhbmdlOiAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSdcbiAgICAgIH07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHt9O1xuICB9XG59O3ZhciByZWY7XG52YXIgaXNJRSA9IGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG52YXIgaXNJRTExID0gd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xudmFyIGlzRWRnZSA9IC9FZGdlLy50ZXN0KCgocmVmID0gd2luZG93Lm5hdmlnYXRvcikgIT0gbnVsbCA/IHJlZi51c2VyQWdlbnQgOiB2b2lkIDApIHx8ICcnKTt2YXIgUG9wdXAsIGJvZHk7XG5ib2R5ID0gRE9NKGRvY3VtZW50LmJvZHkpO1xuXG5Qb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgUG9wdXAgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIHN0YXRpYyB3cmFwQm9keSgpIHtcbiAgICAgIHZhciBib2R5Q2hpbGRyZW4sIGNoaWxkLCBpLCBsZW4sIHJlZjE7XG5cbiAgICAgIGlmICghKChyZWYxID0gdGhpcy5ib2R5V3JhcHBlcikgIT0gbnVsbCA/IHJlZjEucGFyZW50IDogdm9pZCAwKSkge1xuICAgICAgICB0aGlzLmJvZHlXcmFwcGVyID0gYm9keVdyYXBwZXIuc3Bhd24oKTtcbiAgICAgICAgYm9keUNoaWxkcmVuID0gYm9keS5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICB0aGlzLmJvZHlXcmFwcGVyLnByZXBlbmRUbyhib2R5KTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBib2R5Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGJvZHlDaGlsZHJlbltpXTtcbiAgICAgICAgICB0aGlzLmJvZHlXcmFwcGVyLmFwcGVuZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgdW53cmFwQm9keSgpIHtcbiAgICAgIHZhciBib2R5Q2hpbGRyZW4sIGNoaWxkLCBpLCBsZW47XG5cbiAgICAgIGlmICh0aGlzLmJvZHlXcmFwcGVyKSB7XG4gICAgICAgIGJvZHlDaGlsZHJlbiA9IHRoaXMuYm9keVdyYXBwZXIuY2hpbGRyZW4uc2xpY2UoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBib2R5Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGJvZHlDaGlsZHJlbltpXTtcbiAgICAgICAgICBib2R5LmFwcGVuZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvZHlXcmFwcGVyLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5V3JhcHBlciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGRlc3Ryb3lBbGwoKSB7XG4gICAgICB2YXIgaSwgaW5zdGFuY2UsIGluc3RhbmNlcywgbGVuO1xuICAgICAgaW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZXMuc2xpY2UoKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gaW5zdGFuY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVud3JhcEJvZHkoKTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgZGVmYXVsdHMsIHRlbXBsYXRlMSkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTE7XG4gICAgICB0aGlzLnNldHRpbmdzID0gZXh0ZW5kU2V0dGluZ3MoZGVmYXVsdHMsIHNldHRpbmdzKTtcbiAgICAgIHRoaXMuaWQgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTUpLnRvU3RyaW5nKDE2KTtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIG9wZW46IGZhbHNlLFxuICAgICAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IERPTSh0aGlzLnNldHRpbmdzLmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICBQb3B1cC5pbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICAgIFBvcHVwLndyYXBCb2R5KCk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuX2F0dGFjaEJpbmRpbmdzKCk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRlbXBsYXRlICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzLnRlbXBsYXRlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLl9hcHBseVRlbXBsYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWwucHJlcGVuZFRvKGJvZHkpO1xuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5vcGVuKSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVFbGVtZW50cygpIHtcbiAgICAgIHZhciBjbG9zZSwgY29uZmlnLCBjb250ZW50LCBkYXRhLCBvdmVybGF5O1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuc2V0dGluZ3MucGxhY2VtZW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25maWcgPSB7XG4gICAgICAgIHJlbGF0ZWRJbnN0YW5jZTogdGhpc1xuICAgICAgfTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlLnBvcHVwLnNwYXduKGRhdGEsIGNvbmZpZyk7XG4gICAgICBvdmVybGF5ID0gdGhpcy50ZW1wbGF0ZS5vdmVybGF5LnNwYXduKGRhdGEsIGNvbmZpZykuYXBwZW5kVG8odGhpcy5lbCk7XG4gICAgICBjb250ZW50ID0gdGhpcy50ZW1wbGF0ZS5jb250ZW50LnNwYXduKGRhdGEsIGNvbmZpZykuYXBwZW5kVG8odGhpcy5lbCk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNsb3NlLnNob3cpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlID0gdGhpcy50ZW1wbGF0ZS5jbG9zZS5zcGF3bihkYXRhLCBjb25maWcpLmFwcGVuZFRvKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseVRlbXBsYXRlKCkge1xuICAgICAgdmFyIGN1c3RvbSwgcmVmO1xuICAgICAgY3VzdG9tID0gdGhpcy5zZXR0aW5ncy50ZW1wbGF0ZTtcblxuICAgICAgZm9yIChyZWYgaW4gdGhpcy5lbC5jaGlsZCkge1xuICAgICAgICBpZiAoY3VzdG9tW3JlZl0pIHtcbiAgICAgICAgICB0aGlzLmVsLmNoaWxkW3JlZl0udXBkYXRlT3B0aW9ucyhjdXN0b21bcmVmXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXR0YWNoQmluZGluZ3MoKSB7XG4gICAgICB2YXIgY2xvc2UsIGhpZGRlbiwgcmVmMSwgcmVmMiwgdmlzaWJpbGl0eWNoYW5nZTtcbiAgICAgIGNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5lbC5jaGlsZC5vdmVybGF5Lm9uKCdtb3VzZXVwIHRvdWNoZW5kJywgY2xvc2UpO1xuXG4gICAgICBpZiAoKHJlZjEgPSB0aGlzLmVsLmNoaWxkLmNsb3NlKSAhPSBudWxsKSB7XG4gICAgICAgIHJlZjEub24oJ21vdXNldXAgdG91Y2hlbmQnLCBjbG9zZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnBsYWNlbWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgRE9NKHdpbmRvdykub24oYHJlc2l6ZS4ke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWduVG9DZW50ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmlnZ2Vycy5jbG9zZS5lc2MpIHtcbiAgICAgICAgRE9NKGRvY3VtZW50KS5vbihga2V5dXAuJHt0aGlzLmlkfWAsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcgJiYgdGhpcy5zdGF0ZS5vcGVuKSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLm9wZW4udmlzaWJpbGl0eSkge1xuICAgICAgICAoe1xuICAgICAgICAgIHZpc2liaWxpdHljaGFuZ2UsXG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSB2aXNpYmlsaXR5QXBpS2V5cygpKTtcbiAgICAgICAgRE9NKGRvY3VtZW50KS5vbihgJHt2aXNpYmlsaXR5Y2hhbmdlfS4ke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgICAgIGlmIChkb2N1bWVudFtoaWRkZW5dKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuKCd2aXNpYmlsaXR5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJpZ2dlcnMub3Blbi5leGl0SW50ZW50KSB7XG4gICAgICAgIERPTShkb2N1bWVudCkub24oYG1vdXNlb3V0LiR7dGhpcy5pZH1gLCBldmVudCA9PiB7XG4gICAgICAgICAgdmFyIGJhc2UsIHRocmVzaG9sZDtcbiAgICAgICAgICBiYXNlID0gaXNJRSB8fCBpc0lFMTEgfHwgaXNFZGdlID8gMTEwIDogMDtcbiAgICAgICAgICB0aHJlc2hvbGQgPSB0aGlzLnNldHRpbmdzLnlUaHJlc2hvbGQgKyBiYXNlO1xuXG4gICAgICAgICAgaWYgKGV2ZW50LmNsaWVudFkgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuKCdleGl0SW50ZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJpZ2dlcnMub3Blbi5uYXZpZ2F0aW9uICYmICgocmVmMiA9IHdpbmRvdy5oaXN0b3J5KSAhPSBudWxsID8gcmVmMi5wdXNoU3RhdGUgOiB2b2lkIDApKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XG4gICAgICAgICAgaWQ6ICdxdWlja3BvcHVwLW9yaWdpbidcbiAgICAgICAgfSwgJycsICcnKTtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgICBpZDogJ3F1aWNrcG9wdXAnXG4gICAgICAgIH0sICcnLCAnJyk7XG4gICAgICAgIHJldHVybiBET00od2luZG93KS5vbihgcG9wc3RhdGUuJHt0aGlzLmlkfWAsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnQuc3RhdGUuc3RhdGUuaWQgPT09ICdxdWlja3BvcHVwLW9yaWdpbicgJiYgdGhpcy5vcGVuKCduYXZpZ2F0aW9uJykpIDsgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2RldGFjaEJpbmRpbmdzKCkge1xuICAgICAgdmFyIGhpZGRlbiwgcmVmMSwgdmlzaWJpbGl0eWNoYW5nZTtcbiAgICAgIHRoaXMuZWwuY2hpbGQub3ZlcmxheS5vZmYoKTtcblxuICAgICAgaWYgKChyZWYxID0gdGhpcy5lbC5jaGlsZC5jbG9zZSkgIT0gbnVsbCkge1xuICAgICAgICByZWYxLm9mZigpO1xuICAgICAgfVxuXG4gICAgICAoe1xuICAgICAgICB2aXNpYmlsaXR5Y2hhbmdlLFxuICAgICAgICBoaWRkZW5cbiAgICAgIH0gPSB2aXNpYmlsaXR5QXBpS2V5cygpKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucGxhY2VtZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICBET00od2luZG93KS5vZmYoYHJlc2l6ZS4ke3RoaXMuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLm9wZW4ubmF2aWdhdGlvbikge1xuICAgICAgICBET00od2luZG93KS5vZmYoYHBvcHN0YXRlLiR7dGhpcy5pZH1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJpZ2dlcnMub3Blbi5leGl0SW50ZW50KSB7XG4gICAgICAgIERPTShkb2N1bWVudCkub2ZmKGBtb3VzZW91dC4ke3RoaXMuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLm9wZW4udmlzaWJpbGl0eSkge1xuICAgICAgICBET00oZG9jdW1lbnQpLm9mZihgJHt2aXNpYmlsaXR5Y2hhbmdlfS4ke3RoaXMuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLmNsb3NlLmVzYykge1xuICAgICAgICByZXR1cm4gRE9NKGRvY3VtZW50KS5vZmYoYGtleXVwLiR7dGhpcy5pZH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhyb3dEZXN0cm95ZWQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF0dGVtcHQgdG8gb3BlcmF0ZSBhIGRlc3Ryb3llZCBwb3B1cCBpbnN0YW5jZVwiKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZW50KHRhcmdldCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhSVMkMS5xdWlja0VsKHRhcmdldCk6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5kb21FbCh0YXJnZXQpOlxuICAgICAgICAgICAgcmV0dXJuIERPTSh0YXJnZXQpO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS50ZW1wbGF0ZSh0YXJnZXQpOlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zcGF3bigpO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5zdHJpbmcodGFyZ2V0KTpcbiAgICAgICAgICAgIHJldHVybiBodG1sLnNwYXduKHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGh0bWw6IHRhcmdldFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFyZ2V0IHByb3ZpZGVkIHRvIFBvcHVwOjpzZXRDb250ZW50KCknKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICBpZiAodGhpcy5lbC5jaGlsZC5jb250ZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50LmNoaWxkcmVuWzFdLnJlcGxhY2VXaXRoKHRoaXMuY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50LmFwcGVuZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFsaWduVG9DZW50ZXIoKSB7XG4gICAgICB2YXIgY29udGVudEhlaWdodCwgb2Zmc2V0LCB3aW5kb3dIZWlnaHQ7XG4gICAgICBjb250ZW50SGVpZ2h0ID0gdGhpcy5lbC5jaGlsZC5jb250ZW50LnJhdy5jbGllbnRIZWlnaHQ7XG4gICAgICB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmIChjb250ZW50SGVpZ2h0ID49IHdpbmRvd0hlaWdodCAtIDgwKSB7XG4gICAgICAgIG9mZnNldCA9IHdpbmRvdy5pbm5lcldpZHRoID4gNzM2ID8gMTAwIDogNjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAod2luZG93SGVpZ2h0IC0gY29udGVudEhlaWdodCkgLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50LnN0eWxlKCdtYXJnaW4nLCBgJHtvZmZzZXR9cHggYXV0b2ApO1xuICAgIH1cblxuICAgIG9wZW4odHJpZ2dlck5hbWUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dEZXN0cm95ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGhpcy5zdGF0ZS5vcGVuIHx8IFBvcHVwLmhhc09wZW4gJiYgIXRoaXMuc2V0dGluZ3MuZm9yY2VPcGVuIHx8ICsrdGhpcy5zdGF0ZS5jb3VudCA+PSB0aGlzLnNldHRpbmdzLm9wZW5MaW1pdCB8fCB3aW5kb3cuaW5uZXJXaWR0aCA8IHRoaXMuc2V0dGluZ3MudHJpZ2dlcnMub3Blbi5taW5XaWR0aCB8fCB0aGlzLnNldHRpbmdzLmNvbmRpdGlvbiAmJiAhdGhpcy5zZXR0aW5ncy5jb25kaXRpb24oKSkge1xuICAgICAgICAgIHJldHVybiBwcm9taXNlQnJlYWsoKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHZhciBvcGVuUG9wdXBzO1xuICAgICAgICB0aGlzLmVtaXQoJ2JlZm9yZW9wZW4nLCB0cmlnZ2VyTmFtZSk7XG5cbiAgICAgICAgaWYgKCFQb3B1cC5oYXNPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub2Zmc2V0ID0gc2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlblBvcHVwcyA9IFBvcHVwLmluc3RhbmNlcy5maWx0ZXIocG9wdXAgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBvcHVwICE9PSB0aGlzICYmIHBvcHVwLnN0YXRlLm9wZW47XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wZW5Qb3B1cHMubWFwKHBvcHVwID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gcG9wdXAuc3RhdGUub2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHBvcHVwLmNsb3NlKHRydWUpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBzY2hlZHVsZVNjcm9sbFJlc2V0KDUpO1xuICAgICAgICBQb3B1cC5ib2R5V3JhcHBlci5zdGF0ZSgnb3BlbicsIHRydWUpO1xuICAgICAgICBQb3B1cC5ib2R5V3JhcHBlci5zdHlsZSgndG9wJywgdGhpcy5zdGF0ZS5vZmZzZXQgKiAtMSk7XG4gICAgICAgIHRoaXMuZWwuc3RhdGUoJ29wZW4nLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5vcGVuID0gUG9wdXAuaGFzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucGxhY2VtZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRoaXMuYWxpZ25Ub0NlbnRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgdHJpZ2dlck5hbWUpO1xuXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5hbmltYXRpb24gfHwgIVBvcHVwLnRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdmaW5pc2hvcGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VFdmVudCh0aGlzLCAnZmluaXNob3BlbicpO1xuICAgICAgICAgIHRoaXMuZWwuY2hpbGQuY29udGVudC5vbihQb3B1cC50cmFuc2l0aW9uRW5kLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsLmNoaWxkLmNvbnRlbnQucmF3KSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNob3BlbicpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50Lm9mZihQb3B1cC50cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2gocHJvbWlzZUJyZWFrLmVuZCkudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xvc2UocHJldmVudFJlc2V0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5vcGVuKSB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2VCcmVhaygpO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlY2xvc2UnKTtcblxuICAgICAgICBpZiAocHJldmVudFJlc2V0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgcmVmMSwgcmVmMjtcblxuICAgICAgICAgICAgaWYgKCFQb3B1cC5oYXNPcGVuKSB7XG4gICAgICAgICAgICAgIGlmICgocmVmMSA9IFBvcHVwLmJvZHlXcmFwcGVyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmMS5zdGF0ZSgnb3BlbicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgocmVmMiA9IFBvcHVwLmJvZHlXcmFwcGVyKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmMi5zdHlsZSgndG9wJywgbnVsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbCgwLCB0aGlzLnN0YXRlLm9mZnNldCArIGRvY3VtZW50T2Zmc2V0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFBvcHVwLmhhc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWwuc3RhdGUoJ29wZW4nLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc3RhdGUub3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmFuaW1hdGlvbiB8fCAhUG9wdXAudHJhbnNpdGlvbkVuZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2ZpbmlzaGNsb3NlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2VFdmVudCh0aGlzLCAnZmluaXNoY2xvc2UnKTtcbiAgICAgICAgICB0aGlzLmVsLmNoaWxkLmNvbnRlbnQub24oUG9wdXAudHJhbnNpdGlvbkVuZCwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5lbC5jaGlsZC5jb250ZW50LnJhdykge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaGNsb3NlJyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmNvbnRlbnQub2ZmKFBvcHVwLnRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChwcm9taXNlQnJlYWsuZW5kKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX3Rocm93RGVzdHJveWVkKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xvc2UoKTtcblxuICAgICAgdGhpcy5fZGV0YWNoQmluZGluZ3MoKTtcblxuICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgIFBvcHVwLmluc3RhbmNlcy5zcGxpY2UoUG9wdXAuaW5zdGFuY2VzLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH1cbiAgUG9wdXAuaW5zdGFuY2VzID0gW107XG4gIFBvcHVwLmhhc09wZW4gPSBmYWxzZTtcbiAgUG9wdXAuYm9keVdyYXBwZXIgPSBudWxsO1xuICBQb3B1cC50cmFuc2l0aW9uRW5kID0gdHJhbnNpdGlvbkVuZCgpO1xuICByZXR1cm4gUG9wdXA7XG59LmNhbGwodW5kZWZpbmVkKTtcblxudmFyIFBvcHVwJDEgPSBQb3B1cDt2YXIgZGVmYXVsdHMgPSB7XG4gIHBsYWNlbWVudDogJ2NlbnRlcicsXG4gIG9wZW46IGZhbHNlLFxuICBmb3JjZU9wZW46IGZhbHNlLFxuICB0ZW1wbGF0ZTogbnVsbCxcbiAgY29uZGl0aW9uOiBudWxsLFxuICBhbmltYXRpb246IDMwMCxcbiAgY29udGVudFBhZGRpbmc6IDAsXG4gIHlUaHJlc2hvbGQ6IDE1LFxuICBvcGVuTGltaXQ6IDJlMzA4LFxuICBvdmVybGF5Q29sb3I6ICdyZ2JhKDAsMCwwLDAuODgpJyxcbiAgY2xvc2U6IHtcbiAgICBzaG93OiBmYWxzZSxcbiAgICBwYWRkaW5nOiAyMCxcbiAgICBpbnNpZGU6IGZhbHNlLFxuICAgIHNpemU6IDIyXG4gIH0sXG4gIHRyaWdnZXJzOiB7XG4gICAgb3Blbjoge1xuICAgICAgbmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICB2aXNpYmlsaXR5OiBmYWxzZSxcbiAgICAgIGV4aXRJbnRlbnQ6IGZhbHNlXG4gICAgfSxcbiAgICBjbG9zZToge1xuICAgICAgZXNjOiB0cnVlXG4gICAgfVxuICB9XG59O3ZhciB2ZXJzaW9uID0gXCIxLjAuMVwiO3ZhciBuZXdCdWlsZGVyLCBxdWlja3BvcHVwO1xuXG5uZXdCdWlsZGVyID0gZnVuY3Rpb24gKGRlZmF1bHRzLCB0ZW1wbGF0ZXMpIHtcbiAgdmFyIGJ1aWxkZXI7XG5cbiAgYnVpbGRlciA9IGZ1bmN0aW9uIChhcmcpIHtcblxuICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgIGNhc2UgYXJndW1lbnRzLmxlbmd0aCAhPT0gMDpcbiAgICAgICAgcmV0dXJuIG5ldyBQb3B1cCQxKG51bGwsIGRlZmF1bHRzLCB0ZW1wbGF0ZXMpO1xuXG4gICAgICBjYXNlIHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwJDEoe1xuICAgICAgICAgIGNvbnRlbnQ6IGh0bWwuc3Bhd24oe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBodG1sOiBhcmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LCBkZWZhdWx0cywgdGVtcGxhdGVzKTtcblxuICAgICAgY2FzZSAhRE9NLmlzRWwoYXJnKTpcbiAgICAgIGNhc2UgIURPTS5pc1F1aWNrRWwoYXJnKTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb3B1cCQxKHtcbiAgICAgICAgICBjb250ZW50OiBhcmdcbiAgICAgICAgfSwgZGVmYXVsdHMsIHRlbXBsYXRlcyk7XG5cbiAgICAgIGNhc2UgIURPTS5pc1RlbXBsYXRlKGFyZyk6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXAkMSh7XG4gICAgICAgICAgY29udGVudDogYXJnLnNwYXduKClcbiAgICAgICAgfSwgZGVmYXVsdHMsIHRlbXBsYXRlcyk7XG5cbiAgICAgIGNhc2UgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwJDEoYXJnLCBkZWZhdWx0cywgdGVtcGxhdGVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IHByb3ZpZGVkIHRvIFF1aWNrUG9wdXAnKTtcbiAgICB9XG4gIH07XG5cbiAgYnVpbGRlci5jb25maWcgPSBmdW5jdGlvbiAobmV3U2V0dGluZ3MsIG5ld1RlbXBsYXRlcykge1xuICAgIHZhciBuYW1lLCBvdXRwdXRTZXR0aW5ncywgb3V0cHV0VGVtcGxhdGVzLCB0ZW1wbGF0ZTtcblxuICAgIGlmICghSVMkMS5vYmplY3QobmV3U2V0dGluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFF1aWNrUG9wdXAgQ29uZmlnOiBpbnZhbGlkIGNvbmZpZyBvYmplY3QgcHJvdmlkZWQgJHtTdHJpbmcobmV3U2V0dGluZ3MpfWApO1xuICAgIH1cblxuICAgIG91dHB1dFNldHRpbmdzID0gZXh0ZW5kLmNsb25lLmRlZXAoZGVmYXVsdHMsIG5ld1NldHRpbmdzKTtcblxuICAgIGlmICghSVMkMS5vYmplY3QobmV3VGVtcGxhdGVzKSkge1xuICAgICAgb3V0cHV0VGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRUZW1wbGF0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gdGVtcGxhdGVzKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVzW25hbWVdO1xuXG4gICAgICAgIGlmIChuZXdUZW1wbGF0ZXNbbmFtZV0pIHtcbiAgICAgICAgICBvdXRwdXRUZW1wbGF0ZXNbbmFtZV0gPSB0ZW1wbGF0ZS5leHRlbmQobmV3VGVtcGxhdGVzW25hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRUZW1wbGF0ZXNbbmFtZV0gPSB0ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdCdWlsZGVyKG91dHB1dFNldHRpbmdzLCBvdXRwdXRUZW1wbGF0ZXMpO1xuICB9O1xuXG4gIGJ1aWxkZXIud3JhcEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBvcHVwJDEud3JhcEJvZHkoKTtcbiAgfTtcblxuICBidWlsZGVyLnVud3JhcEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBvcHVwJDEudW53cmFwQm9keSgpO1xuICB9O1xuXG4gIGJ1aWxkZXIuZGVzdHJveUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wdXAkMS5kZXN0cm95QWxsKCk7XG4gIH07XG5cbiAgYnVpbGRlci52ZXJzaW9uID0gdmVyc2lvbjtcbiAgYnVpbGRlci5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICBidWlsZGVyLnRlbXBsYXRlcyA9IHRlbXBsYXRlcztcbiAgcmV0dXJuIGJ1aWxkZXI7XG59O1xuXG5xdWlja3BvcHVwID0gbmV3QnVpbGRlcihkZWZhdWx0cywgdGVtcGxhdGVzKTtcbnZhciBxdWlja3BvcHVwJDEgPSBxdWlja3BvcHVwO2V4cG9ydCBkZWZhdWx0IHF1aWNrcG9wdXAkMTsiLCJpbXBvcnQgZGV0ZWN0QW5pbWF0aW9uIGZyb20gJ2RldGVjdC1hbmltYXRpb24tZW5kLWhlbHBlcidcbmltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5cbmV4cG9ydCBzdXBwb3J0c0FuaW1hdGlvbiA9ICgpLT4gISFkZXRlY3RBbmltYXRpb24oKVxuXG5leHBvcnQgdHJhbnNpdGlvbkVuZCA9ICgpLT4gZGV0ZWN0QW5pbWF0aW9uKCd0cmFuc2l0aW9uJylcblxuZXhwb3J0IHJlc3RhcnRTYW5kYm94ID0gKCktPlxuXHR3aW5kb3cuc2FuZGJveC5yZW1vdmUoKSBpZiB3aW5kb3cuc2FuZGJveFxuXHR3aW5kb3cuc2FuZGJveCA9IERPTS5kaXYgaWQ6J3NhbmRib3gnLCBzdHlsZTpcblx0XHRib3JkZXI6ICcxcHggc29saWQnXG5cdFx0cGFkZGluZzogMjBcblx0XHRib3hTaXppbmc6ICdib3JkZXItYm94J1xuXHRcblx0d2luZG93LnNhbmRib3guYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkiLCIvKiFcbiAqIGFzc2VydGlvbi1lcnJvclxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQHF1YWxpYW5jeS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9iamVjdCB0byBhbm90aGVyIGV4Y2x1ZGluZyBhbnkgb3JpZ2luYWxseVxuICogbGlzdGVkLiBSZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyBge31gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleGNsdWRlZCBwcm9wZXJ0aWVzIC4uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gZXhjbHVkZSAoKSB7XG4gIHZhciBleGNsdWRlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBmdW5jdGlvbiBleGNsdWRlUHJvcHMgKHJlcywgb2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghfmV4Y2x1ZGVzLmluZGV4T2Yoa2V5KSkgcmVzW2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBleHRlbmRFeGNsdWRlICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgLCBpID0gMFxuICAgICAgLCByZXMgPSB7fTtcblxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhjbHVkZVByb3BzKHJlcywgYXJnc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn07XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiAjIyMgQXNzZXJ0aW9uRXJyb3JcbiAqXG4gKiBBbiBleHRlbnNpb24gb2YgdGhlIEphdmFTY3JpcHQgYEVycm9yYCBjb25zdHJ1Y3RvciBmb3JcbiAqIGFzc2VydGlvbiBhbmQgdmFsaWRhdGlvbiBzY2VuYXJpb3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtjYWxsZWV9IHN0YXJ0IHN0YWNrIGZ1bmN0aW9uIChvcHRpb25hbClcbiAqL1xuXG5mdW5jdGlvbiBBc3NlcnRpb25FcnJvciAobWVzc2FnZSwgX3Byb3BzLCBzc2YpIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ25hbWUnLCAnbWVzc2FnZScsICdzdGFjaycsICdjb25zdHJ1Y3RvcicsICd0b0pTT04nKVxuICAgICwgcHJvcHMgPSBleHRlbmQoX3Byb3BzIHx8IHt9KTtcblxuICAvLyBkZWZhdWx0IHZhbHVlc1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdVbnNwZWNpZmllZCBBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuc2hvd0RpZmYgPSBmYWxzZTtcblxuICAvLyBjb3B5IGZyb20gcHJvcGVydGllc1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICB9XG5cbiAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICBzc2YgPSBzc2YgfHwgQXNzZXJ0aW9uRXJyb3I7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHNzZik7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEVycm9yLnByb3RvdHlwZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLyohXG4gKiBTdGF0aWNhbGx5IHNldCBuYW1lXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4vKiFcbiAqIEVuc3VyZSBjb3JyZWN0IGNvbnN0cnVjdG9yXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogQWxsb3cgZXJyb3JzIHRvIGJlIGNvbnZlcnRlZCB0byBKU09OIGZvciBzdGF0aWMgdHJhbnNmZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlIHN0YWNrIChkZWZhdWx0OiBgdHJ1ZWApXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB0aGF0IGNhbiBiZSBgSlNPTi5zdHJpbmdpZnlgXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnY29uc3RydWN0b3InLCAndG9KU09OJywgJ3N0YWNrJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKHsgbmFtZTogdGhpcy5uYW1lIH0sIHRoaXMpO1xuXG4gIC8vIGluY2x1ZGUgc3RhY2sgaWYgZXhpc3RzIGFuZCBub3QgdHVybmVkIG9mZlxuICBpZiAoZmFsc2UgIT09IHN0YWNrICYmIHRoaXMuc3RhY2spIHtcbiAgICBwcm9wcy5zdGFjayA9IHRoaXMuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiAhXG4gKiBDaGFpIC0gcGF0aHZhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbG9naWNhbHBhcmFkb3gvZmlsdHJcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5oYXNQcm9wZXJ0eShvYmplY3QsIG5hbWUpXG4gKlxuICogVGhpcyBhbGxvd3MgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIG93blxuICogb3IgaW5oZXJpdGVkIGZyb20gcHJvdG90eXBlIGNoYWluIG5hbWVkIHByb3BlcnR5LlxuICpcbiAqIEJhc2ljYWxseSBkb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBgaW5gXG4gKiBvcGVyYXRvciBidXQgd29ya3MgcHJvcGVybHkgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAqIGFuZCBvdGhlciBwcmltaXRpdmVzLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLCAnc3RyJyk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLCAnY29uc3RydWN0b3InKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmosICdiYXInKTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KG9iai5zdHIsICdsZW5ndGgnKTsgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5zdHIsIDEpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5zdHIsIDUpOyAgLy8gZmFsc2VcbiAqXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLmFyciwgJ2xlbmd0aCcpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5hcnIsIDIpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iai5hcnIsIDMpOyAgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIGl0IGV4aXN0c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaGFzUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzUHJvcGVydHkob2JqLCBuYW1lKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUaGUgYGluYCBvcGVyYXRvciBkb2VzIG5vdCB3b3JrIHdpdGggcHJpbWl0aXZlcy5cbiAgcmV0dXJuIG5hbWUgaW4gT2JqZWN0KG9iaik7XG59XG5cbi8qICFcbiAqICMjIHBhcnNlUGF0aChwYXRoKVxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIHN0cmluZyBvYmplY3RcbiAqIHBhdGhzLiBVc2UgaW4gY29uanVuY3Rpb24gd2l0aCBgaW50ZXJuYWxHZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBpbmZpbml0ZWx5IGRlZXAgYW5kIG5lc3RlZC5cbiAqICogQXJyYXlzIGFyZSBhbHNvIHZhbGlkIHVzaW5nIHRoZSBmb3JtYWwgYG15b2JqZWN0LmRvY3VtZW50WzNdLnByb3BlcnR5YC5cbiAqICogTGl0ZXJhbCBkb3RzIGFuZCBicmFja2V0cyAobm90IGRlbGltaXRlcikgbXVzdCBiZSBiYWNrc2xhc2gtZXNjYXBlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gcGFyc2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgc3RyID0gcGF0aC5yZXBsYWNlKC8oW15cXFxcXSlcXFsvZywgJyQxLlsnKTtcbiAgdmFyIHBhcnRzID0gc3RyLm1hdGNoKC8oXFxcXFxcLnxbXi5dKz8pKy9nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbiBtYXBNYXRjaGVzKHZhbHVlKSB7XG4gICAgdmFyIHJlZ2V4cCA9IC9eXFxbKFxcZCspXFxdJC87XG4gICAgdmFyIG1BcnIgPSByZWdleHAuZXhlYyh2YWx1ZSk7XG4gICAgdmFyIHBhcnNlZCA9IG51bGw7XG4gICAgaWYgKG1BcnIpIHtcbiAgICAgIHBhcnNlZCA9IHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQgPSB7IHA6IHZhbHVlLnJlcGxhY2UoL1xcXFwoWy5cXFtcXF1dKS9nLCAnJDEnKSB9O1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0pO1xufVxuXG4vKiAhXG4gKiAjIyBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZFssIHBhdGhEZXB0aF0pXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNlYXJjaCBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCAobmVzdGluZyBsZXZlbCkgb2YgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gcmV0cmlldmVcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQsIHBhdGhEZXB0aCkge1xuICB2YXIgdGVtcG9yYXJ5VmFsdWUgPSBvYmo7XG4gIHZhciByZXMgPSBudWxsO1xuICBwYXRoRGVwdGggPSAodHlwZW9mIHBhdGhEZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyBwYXJzZWQubGVuZ3RoIDogcGF0aERlcHRoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhEZXB0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKHRlbXBvcmFyeVZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQucCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgPSB0ZW1wb3JhcnlWYWx1ZVtwYXJ0LmldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcG9yYXJ5VmFsdWUgPSB0ZW1wb3JhcnlWYWx1ZVtwYXJ0LnBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gKHBhdGhEZXB0aCAtIDEpKSB7XG4gICAgICAgIHJlcyA9IHRlbXBvcmFyeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbi8qICFcbiAqICMjIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsdWUsIHBhcnNlZClcbiAqXG4gKiBDb21wYW5pb24gZnVuY3Rpb24gZm9yIGBwYXJzZVBhdGhgIHRoYXQgc2V0c1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgYSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCAndmFsdWUnLCBwYXJzZWQpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFuZCBkZWZpbmUgb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgdG8gdXNlIHVwb24gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCB2YWwsIHBhcnNlZCkge1xuICB2YXIgdGVtcE9iaiA9IG9iajtcbiAgdmFyIHBhdGhEZXB0aCA9IHBhcnNlZC5sZW5ndGg7XG4gIHZhciBwYXJ0ID0gbnVsbDtcbiAgLy8gSGVyZSB3ZSBpdGVyYXRlIHRocm91Z2ggZXZlcnkgcGFydCBvZiB0aGUgcGF0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhEZXB0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gbnVsbDtcbiAgICB2YXIgcHJvcFZhbCA9IG51bGw7XG4gICAgcGFydCA9IHBhcnNlZFtpXTtcblxuICAgIC8vIElmIGl0J3MgdGhlIGxhc3QgcGFydCBvZiB0aGUgcGF0aCwgd2Ugc2V0IHRoZSAncHJvcE5hbWUnIHZhbHVlIHdpdGggdGhlIHByb3BlcnR5IG5hbWVcbiAgICBpZiAoaSA9PT0gKHBhdGhEZXB0aCAtIDEpKSB7XG4gICAgICBwcm9wTmFtZSA9IHR5cGVvZiBwYXJ0LnAgPT09ICd1bmRlZmluZWQnID8gcGFydC5pIDogcGFydC5wO1xuICAgICAgLy8gTm93IHdlIHNldCB0aGUgcHJvcGVydHkgd2l0aCB0aGUgbmFtZSBoZWxkIGJ5ICdwcm9wTmFtZScgb24gb2JqZWN0IHdpdGggdGhlIGRlc2lyZWQgdmFsXG4gICAgICB0ZW1wT2JqW3Byb3BOYW1lXSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJ0LnAgIT09ICd1bmRlZmluZWQnICYmIHRlbXBPYmpbcGFydC5wXSkge1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpbcGFydC5wXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJ0LmkgIT09ICd1bmRlZmluZWQnICYmIHRlbXBPYmpbcGFydC5pXSkge1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpbcGFydC5pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIG9iaiBkb2Vzbid0IGhhdmUgdGhlIHByb3BlcnR5IHdlIGNyZWF0ZSBvbmUgd2l0aCB0aGF0IG5hbWUgdG8gZGVmaW5lIGl0XG4gICAgICB2YXIgbmV4dCA9IHBhcnNlZFtpICsgMV07XG4gICAgICAvLyBIZXJlIHdlIHNldCB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hpY2ggd2lsbCBiZSBkZWZpbmVkXG4gICAgICBwcm9wTmFtZSA9IHR5cGVvZiBwYXJ0LnAgPT09ICd1bmRlZmluZWQnID8gcGFydC5pIDogcGFydC5wO1xuICAgICAgLy8gSGVyZSB3ZSBkZWNpZGUgaWYgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlIGFuIGFycmF5IG9yIGEgbmV3IG9iamVjdFxuICAgICAgcHJvcFZhbCA9IHR5cGVvZiBuZXh0LnAgPT09ICd1bmRlZmluZWQnID8gW10gOiB7fTtcbiAgICAgIHRlbXBPYmpbcHJvcE5hbWVdID0gcHJvcFZhbDtcbiAgICAgIHRlbXBPYmogPSB0ZW1wT2JqW3Byb3BOYW1lXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAjIyMgLmdldFBhdGhJbmZvKG9iamVjdCwgcGF0aClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IGluZm8gaW4gYW5cbiAqIG9iamVjdCBnaXZlbiBhIHN0cmluZyBwYXRoLlxuICpcbiAqIFRoZSBwYXRoIGluZm8gY29uc2lzdHMgb2YgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAqIHBhcmVudCAtIFRoZSBwYXJlbnQgb2JqZWN0IG9mIHRoZSBwcm9wZXJ0eSByZWZlcmVuY2VkIGJ5IGBwYXRoYFxuICogKiBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbmFsIHByb3BlcnR5LCBhIG51bWJlciBpZiBpdCB3YXMgYW4gYXJyYXkgaW5kZXhlclxuICogKiB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiAqIGV4aXN0cyAtIFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cyBvciBub3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gaW5mb1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aEluZm9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGF0aEluZm8ob2JqLCBwYXRoKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgocGF0aCk7XG4gIHZhciBsYXN0ID0gcGFyc2VkW3BhcnNlZC5sZW5ndGggLSAxXTtcbiAgdmFyIGluZm8gPSB7XG4gICAgcGFyZW50OiBwYXJzZWQubGVuZ3RoID4gMSA/IGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkLCBwYXJzZWQubGVuZ3RoIC0gMSkgOiBvYmosXG4gICAgbmFtZTogbGFzdC5wIHx8IGxhc3QuaSxcbiAgICB2YWx1ZTogaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQpLFxuICB9O1xuICBpbmZvLmV4aXN0cyA9IGhhc1Byb3BlcnR5KGluZm8ucGFyZW50LCBpbmZvLm5hbWUpO1xuXG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0UGF0aFZhbHVlKG9iamVjdCwgcGF0aClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHZhbHVlcyBpbiBhblxuICogb2JqZWN0IGdpdmVuIGEgc3RyaW5nIHBhdGguXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIHByb3AxOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgICAgIH1cbiAqICAgICAgICwgcHJvcDI6IHtcbiAqICAgICAgICAgICAgIGFycjogWyB7IG5lc3RlZDogJ1VuaXZlcnNlJyB9IF1cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvIGFnYWluISdcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBnZXRQYXRoVmFsdWUob2JqLCAncHJvcDEuc3RyJyk7IC8vIEhlbGxvXG4gKiAgICAgZ2V0UGF0aFZhbHVlKG9iaiwgJ3Byb3AxLmF0dFsyXScpOyAvLyBiXG4gKiAgICAgZ2V0UGF0aFZhbHVlKG9iaiwgJ3Byb3AyLmFyclswXS5uZXN0ZWQnKTsgLy8gVW5pdmVyc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gdmFsdWUgb3IgYHVuZGVmaW5lZGBcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFBhdGhWYWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoVmFsdWUob2JqLCBwYXRoKSB7XG4gIHZhciBpbmZvID0gZ2V0UGF0aEluZm8ob2JqLCBwYXRoKTtcbiAgcmV0dXJuIGluZm8udmFsdWU7XG59XG5cbi8qKlxuICogIyMjIC5zZXRQYXRoVmFsdWUob2JqZWN0LCBwYXRoLCB2YWx1ZSlcbiAqXG4gKiBEZWZpbmUgdGhlIHZhbHVlIGluIGFuIG9iamVjdCBhdCBhIGdpdmVuIHN0cmluZyBwYXRoLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgb2JqID0ge1xuICogICAgIHByb3AxOiB7XG4gKiAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgIH1cbiAqICAgLCBwcm9wMjoge1xuICogICAgICAgICBhcnI6IFsgeyBuZXN0ZWQ6ICdVbml2ZXJzZScgfSBdXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvIGFnYWluISdcbiAqICAgICB9XG4gKiB9O1xuICogYGBgXG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSBhY2NlcHRhYmxlLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcHJvcGVydGllcyA9IHJlcXVpcmUoJ3RlYS1wcm9wZXJ0aWVzJyk7XG4gKiBwcm9wZXJ0aWVzLnNldChvYmosICdwcm9wMS5zdHInLCAnSGVsbG8gVW5pdmVyc2UhJyk7XG4gKiBwcm9wZXJ0aWVzLnNldChvYmosICdwcm9wMS5hcnJbMl0nLCAnQicpO1xuICogcHJvcGVydGllcy5zZXQob2JqLCAncHJvcDIuYXJyWzBdLm5lc3RlZC52YWx1ZScsIHsgaGVsbG86ICd1bml2ZXJzZScgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGhWYWx1ZShvYmosIHBhdGgsIHZhbCkge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpO1xuICBpbnRlcm5hbFNldFBhdGhWYWx1ZShvYmosIHZhbCwgcGFyc2VkKTtcbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhhc1Byb3BlcnR5OiBoYXNQcm9wZXJ0eSxcbiAgZ2V0UGF0aEluZm86IGdldFBhdGhJbmZvLFxuICBnZXRQYXRoVmFsdWU6IGdldFBhdGhWYWx1ZSxcbiAgc2V0UGF0aFZhbHVlOiBzZXRQYXRoVmFsdWUsXG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmZsYWcob2JqZWN0LCBrZXksIFt2YWx1ZV0pXG4gKlxuICogR2V0IG9yIHNldCBhIGZsYWcgdmFsdWUgb24gYW4gb2JqZWN0LiBJZiBhXG4gKiB2YWx1ZSBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCwgZWxzZSBpdCB3aWxsXG4gKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICpcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nLCAnYmFyJyk7IC8vIHNldHRlclxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycpOyAvLyBnZXR0ZXIsIHJldHVybnMgYGJhcmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgKG9wdGlvbmFsKVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGFnKG9iaiwga2V5LCB2YWx1ZSkge1xuICB2YXIgZmxhZ3MgPSBvYmouX19mbGFncyB8fCAob2JqLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBmbGFnc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZsYWdzW2tleV07XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0ZXN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMjIyAudGVzdChvYmplY3QsIGV4cHJlc3Npb24pXG4gKlxuICogVGVzdCBhbmQgb2JqZWN0IGZvciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgdGVzdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVzdChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIGV4cHIgPSBhcmdzWzBdO1xuICByZXR1cm4gbmVnYXRlID8gIWV4cHIgOiBleHByO1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC50eXBlRGV0ZWN0ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiAhXG4gKiB0eXBlLWRldGVjdFxuICogQ29weXJpZ2h0KGMpIDIwMTMgamFrZSBsdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xudmFyIHByb21pc2VFeGlzdHMgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDogZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGlkLWJsYWNrbGlzdFxuXG52YXIgc3ltYm9sRXhpc3RzID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgbWFwRXhpc3RzID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgc2V0RXhpc3RzID0gdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgd2Vha01hcEV4aXN0cyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrU2V0RXhpc3RzID0gdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnO1xudmFyIGRhdGFWaWV3RXhpc3RzID0gdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJztcbnZhciBzeW1ib2xJdGVyYXRvckV4aXN0cyA9IHN5bWJvbEV4aXN0cyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSAndW5kZWZpbmVkJztcbnZhciBzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyA9IHN5bWJvbEV4aXN0cyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFbnRyaWVzRXhpc3RzID0gc2V0RXhpc3RzICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgbWFwRW50cmllc0V4aXN0cyA9IG1hcEV4aXN0cyAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nO1xudmFyIHNldEl0ZXJhdG9yUHJvdG90eXBlID0gc2V0RW50cmllc0V4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IFNldCgpLmVudHJpZXMoKSk7XG52YXIgbWFwSXRlcmF0b3JQcm90b3R5cGUgPSBtYXBFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgTWFwKCkuZW50cmllcygpKTtcbnZhciBhcnJheUl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sSXRlcmF0b3JFeGlzdHMgJiYgdHlwZW9mIEFycmF5LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xudmFyIGFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBhcnJheUl0ZXJhdG9yRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpO1xudmFyIHN0cmluZ0l0ZXJhdG9yRXhpc3RzID0gc3ltYm9sSXRlcmF0b3JFeGlzdHMgJiYgdHlwZW9mIFN0cmluZy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSA9IHN0cmluZ0l0ZXJhdG9yRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZignJ1tTeW1ib2wuaXRlcmF0b3JdKCkpO1xudmFyIHRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoID0gODtcbnZhciB0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGggPSAtMTtcbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZXMgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhbiBvYmplY3QsXG4gKiBub3JtYWxpc2luZyBiZWhhdmlvdXIgYWNyb3NzIGVuZ2luZSB2ZXJzaW9ucyAmIHdlbGwgb3B0aW1pc2VkLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHlwZURldGVjdChvYmopIHtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDMsMDM5LDAzNSBvcHMvc2VjIMKxMS42MiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAxLDQyNCwxMzggb3BzL3NlYyDCsTQuNTQlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMSw2NTMsMTUzIG9wcy9zZWMgwrExLjkxJSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDksOTc4LDY2MCBvcHMvc2VjIMKxMS45MiUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAyLDU1Niw3Njkgb3BzL3NlYyDCsTEuNzMlICg3NyBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMzgsNTY0LDc5NiBvcHMvc2VjIMKxMS4xNSUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAzMSwxNDgsOTQwIG9wcy9zZWMgwrExLjEwJSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDMyLDY3OSwzMzAgb3BzL3NlYyDCsTEuOTAlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggMzIsMzYzLDM2OCBvcHMvc2VjIMKxMS4wNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAzMSwyOTYsODcwIG9wcy9zZWMgwrEwLjk2JSAoODMgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgdmFyIHR5cGVvZk9iaiA9IHR5cGVvZiBvYmo7XG4gIGlmICh0eXBlb2ZPYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGVvZk9iajtcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAyOCw2NDUsNzY1IG9wcy9zZWMgwrExLjE3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDM2LDQyOCw5NjIgb3BzL3NlYyDCsTEuMzclICg4NCBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdylgYFxuICAgKiAgLSBOb2RlID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFBoYW50b21KUyA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgRWRnZSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpYGBcbiAgICogIC0gQ2hyb21lIFdvcmtlciA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94IFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIFNhZmFyaSBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSAxMSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSBFZGdlIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqL1xuICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QpIHtcbiAgICByZXR1cm4gJ2dsb2JhbCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMiw4ODgsMzUyIG9wcy9zZWMgwrEwLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIyLDQ3OSw2NTAgb3BzL3NlYyDCsTAuOTYlICg4MSBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAoXG4gICAgQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID09PSBmYWxzZSB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBvYmopKVxuICApIHtcbiAgICByZXR1cm4gJ0FycmF5JztcbiAgfVxuXG4gIC8vIE5vdCBjYWNoaW5nIGV4aXN0ZW5jZSBvZiBgd2luZG93YCBhbmQgcmVsYXRlZCBwcm9wZXJ0aWVzIGR1ZSB0byBwb3RlbnRpYWxcbiAgLy8gZm9yIGB3aW5kb3dgIHRvIGJlIHVuc2V0IGJlZm9yZSB0ZXN0cyBpbiBxdWFzaS1icm93c2VyIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2xvY2F0aW9uKVxuICAgICAqIFdoYXRXRyBIVE1MJDcuNy4zIC0gVGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cubG9jYXRpb24pYGBcbiAgICAgKiAgLSBJRSA8PTExID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubG9jYXRpb24gPT09ICdvYmplY3QnICYmIG9iaiA9PT0gd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG9jdW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkMy4xLjEgLSBUaGUgYERvY3VtZW50YCBvYmplY3RcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTI2ODA5MjY4KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiAgICAgICBXaGF0V0cgSFRNTCBzdGF0ZXM6XG4gICAgICogICAgICAgICA+IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIFdpbmRvdyBvYmplY3RzIG11c3QgYWxzbyBoYXZlIGFcbiAgICAgKiAgICAgICAgID4gd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWRcbiAgICAgKiAgICAgICAgID4gSFRNTERvY3VtZW50IHdob3NlIHZhbHVlIGlzIHRoZSBEb2N1bWVudCBpbnRlcmZhY2Ugb2JqZWN0LlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpYGBcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ29iamVjdCcgJiYgb2JqID09PSB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNtaW1ldHlwZWFycmF5KVxuICAgICAgICogV2hhdFdHIEhUTUwkOC42LjEuNSAtIFBsdWdpbnMgLSBJbnRlcmZhY2UgTWltZVR5cGVBcnJheVxuICAgICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IubWltZVR5cGVzKWBgXG4gICAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNNaW1lVHlwZXNDb2xsZWN0aW9uXVwiXG4gICAgICAgKi9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvci5taW1lVHlwZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgb2JqID09PSB3aW5kb3cubmF2aWdhdG9yLm1pbWVUeXBlcykge1xuICAgICAgICByZXR1cm4gJ01pbWVUeXBlQXJyYXknO1xuICAgICAgfVxuXG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBQbHVnaW5BcnJheVxuICAgICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IucGx1Z2lucylgYFxuICAgICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TUGx1Z2luc0NvbGxlY3Rpb25dXCJcbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLnBsdWdpbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgb2JqID09PSB3aW5kb3cubmF2aWdhdG9yLnBsdWdpbnMpIHtcbiAgICAgICAgcmV0dXJuICdQbHVnaW5BcnJheSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCh0eXBlb2Ygd2luZG93LkhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSAmJlxuICAgICAgICBvYmogaW5zdGFuY2VvZiB3aW5kb3cuSFRNTEVsZW1lbnQpIHtcbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAgKiBXaGF0V0cgSFRNTCQ0LjQuNCAtIFRoZSBgYmxvY2txdW90ZWAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFF1b3RlRWxlbWVudGBcbiAgICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdibG9ja3F1b3RlJykpYGBcbiAgICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IEhUTUxCbG9ja0VsZW1lbnRdXCJcbiAgICAgICovXG4gICAgICBpZiAob2JqLnRhZ05hbWUgPT09ICdCTE9DS1FVT1RFJykge1xuICAgICAgICByZXR1cm4gJ0hUTUxRdW90ZUVsZW1lbnQnO1xuICAgICAgfVxuXG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNodG1sdGFibGVkYXRhY2VsbGVsZW1lbnQpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ0LjkuOSAtIFRoZSBgdGRgIGVsZW1lbnQgLSBJbnRlcmZhY2UgYEhUTUxUYWJsZURhdGFDZWxsRWxlbWVudGBcbiAgICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJykpXG4gICAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICovXG4gICAgICBpZiAob2JqLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MVGFibGVEYXRhQ2VsbEVsZW1lbnQnO1xuICAgICAgfVxuXG4gICAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNodG1sdGFibGVoZWFkZXJjZWxsZWxlbWVudClcbiAgICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRgXG4gICAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICAgKiAgICAgICB3aGljaCBzdWdnZXN0cyB0aGF0IGJyb3dzZXJzIHNob3VsZCB1c2UgSFRNTFRhYmxlQ2VsbEVsZW1lbnQgZm9yXG4gICAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpKVxuICAgICAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqL1xuICAgICAgaWYgKG9iai50YWdOYW1lID09PSAnVEgnKSB7XG4gICAgICAgIHJldHVybiAnSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgRmxvYXQ2NEFycmF5ICAgICAgIHggNjI1LDY0NCBvcHMvc2VjIMKxMS41OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEZsb2F0MzJBcnJheSAgICAgICB4IDEsMjc5LDg1MiBvcHMvc2VjIMKxMi45MSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQzMkFycmF5ICAgICAgICB4IDEsMTc4LDE4NSBvcHMvc2VjIMKxMS45NSUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQxNkFycmF5ICAgICAgICB4IDEsMDA4LDM4MCBvcHMvc2VjIMKxMi4yNSUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4QXJyYXkgICAgICAgICB4IDEsMTI4LDA0MCBvcHMvc2VjIMKxMi4xMSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDMyQXJyYXkgICAgICAgICB4IDEsMTcwLDExOSBvcHMvc2VjIMKxMi44OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDE2QXJyYXkgICAgICAgICB4IDEsMTc2LDM0OCBvcHMvc2VjIMKxNS43OSUgKDg2IHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDhBcnJheSAgICAgICAgICB4IDEsMDU4LDcwNyBvcHMvc2VjIMKxNC45NCUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4Q2xhbXBlZEFycmF5ICB4IDEsMTEwLDYzMyBvcHMvc2VjIMKxNC4yMCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgRmxvYXQ2NEFycmF5ICAgICAgIHggNywxMDUsNjcxIG9wcy9zZWMgwrExMy40NyUgKDY0IHJ1bnMgc2FtcGxlZClcbiAgKiAgIEZsb2F0MzJBcnJheSAgICAgICB4IDUsODg3LDkxMiBvcHMvc2VjIMKxMS40NiUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQzMkFycmF5ICAgICAgICB4IDYsNDkxLDY2MSBvcHMvc2VjIMKxMS43NiUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQxNkFycmF5ICAgICAgICB4IDYsNTU5LDc5NSBvcHMvc2VjIMKxMS42NyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4QXJyYXkgICAgICAgICB4IDYsNDYzLDk2NiBvcHMvc2VjIMKxMS40MyUgKDg1IHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDMyQXJyYXkgICAgICAgICB4IDUsNjQxLDg0MSBvcHMvc2VjIMKxMy40OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDE2QXJyYXkgICAgICAgICB4IDYsNTgzLDUxMSBvcHMvc2VjIMKxMS45OCUgKDgwIHJ1bnMgc2FtcGxlZClcbiAgKiAgIEludDhBcnJheSAgICAgICAgICB4IDYsNjA2LDA3OCBvcHMvc2VjIMKxMS43NCUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiAgIFVpbnQ4Q2xhbXBlZEFycmF5ICB4IDYsNjAyLDIyNCBvcHMvc2VjIMKxMS43NyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgdmFyIHN0cmluZ1RhZyA9IChzeW1ib2xUb1N0cmluZ1RhZ0V4aXN0cyAmJiBvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVGFnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHJpbmdUYWc7XG4gIH1cblxuICB2YXIgb2JqUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMSw3NzIsMzg1IG9wcy9zZWMgwrExLjg1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMiwxNDMsNjM0IG9wcy9zZWMgwrEyLjQ2JSAoNzggcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICByZWdleCBsaXRlcmFsICAgICAgeCAzLDkyOCwwMDkgb3BzL3NlYyDCsTAuNjUlICg3OCBydW5zIHNhbXBsZWQpXG4gICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAzLDkzMSwxMDggb3BzL3NlYyDCsTAuNTglICg4NCBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IFJlZ0V4cC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1JlZ0V4cCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIGRhdGUgICAgICAgICAgICAgICB4IDIsMTMwLDA3NCBvcHMvc2VjIMKxNC40MiUgKDY4IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMyw5NTMsNzc5IG9wcy9zZWMgwrExLjM1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAob2JqUHJvdG90eXBlID09PSBEYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnRGF0ZSc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtcHJvbWlzZS5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDI1LjQuNS40IC0gUHJvbWlzZS5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiUHJvbWlzZVwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFByb21pc2UucmVzb2x2ZSgpKWBgXG4gICAqICAtIENocm9tZSA8PTQ3ID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqICAtIEVkZ2UgPD0yMCA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKiAgLSBGaXJlZm94IDI5LUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICogIC0gU2FmYXJpIDcuMS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAqL1xuICBpZiAocHJvbWlzZUV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFByb21pc2UucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdQcm9taXNlJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgc2V0ICAgICAgICAgICAgICAgIHggMiwyMjIsMTg2IG9wcy9zZWMgwrExLjMxJSAoODIgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBzZXQgICAgICAgICAgICAgICAgeCA0LDU0NSw4Nzkgb3BzL3NlYyDCsTEuMTMlICg4MyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBTZXQucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdTZXQnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBtYXAgICAgICAgICAgICAgICAgeCAyLDM5Niw4NDIgb3BzL3NlYyDCsTEuNTklICg4MSBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDQsMTgzLDk0NSBvcHMvc2VjIMKxNi41OSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG1hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IE1hcC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ01hcCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIHdlYWtzZXQgICAgICAgICAgICB4IDEsMzIzLDIyMCBvcHMvc2VjIMKxMi4xNyUgKDc2IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgd2Vha3NldCAgICAgICAgICAgIHggNCwyMzcsNTEwIG9wcy9zZWMgwrEyLjAxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAod2Vha1NldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtTZXQucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdXZWFrU2V0JztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgd2Vha21hcCAgICAgICAgICAgIHggMSw1MDAsMjYwIG9wcy9zZWMgwrEyLjAyJSAoNzggcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICB3ZWFrbWFwICAgICAgICAgICAgeCAzLDg4MSwzODQgb3BzL3NlYyDCsTEuNDUlICg4MiBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmICh3ZWFrTWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha01hcC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1dlYWtNYXAnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLWRhdGF2aWV3LnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjQuMi40LjIxIC0gRGF0YVZpZXcucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIkRhdGFWaWV3XCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoZGF0YVZpZXdFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBEYXRhVmlldy5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0RhdGFWaWV3JztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lbWFwaXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMy4xLjUuMi4yIC0gJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJNYXAgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgTWFwKCkuZW50cmllcygpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKG1hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IG1hcEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdNYXAgSXRlcmF0b3InO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzZXRpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIzLjIuNS4yLjIgLSAlU2V0SXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIlNldCBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBTZXQoKS5lbnRyaWVzKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gc2V0SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1NldCBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMi4xLjUuMi4yIC0gJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIkFycmF5IEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW11bU3ltYm9sLml0ZXJhdG9yXSgpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBhcnJheUl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdBcnJheSBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjEuMS41LjIuMiAtICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU3RyaW5nIEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoJydbU3ltYm9sLml0ZXJhdG9yXSgpKWBgXG4gICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgKi9cbiAgaWYgKHN0cmluZ0l0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1N0cmluZyBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIG9iamVjdCBmcm9tIG51bGwgICB4IDIsNDI0LDMyMCBvcHMvc2VjIMKxMS42NyUgKDc2IHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggNSw4MzgsMDAwIG9wcy9zZWMgwrEwLjk5JSAoODQgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAob2JqUHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdFxuICAgIC5wcm90b3R5cGVcbiAgICAudG9TdHJpbmdcbiAgICAuY2FsbChvYmopXG4gICAgLnNsaWNlKHRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoLCB0b1N0cmluZ1JpZ2h0U2xpY2VMZW5ndGgpO1xufVxuXG5yZXR1cm4gdHlwZURldGVjdDtcblxufSkpKTtcbiIsIi8qIVxuICogQ2hhaSAtIGV4cGVjdFR5cGVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZXhwZWN0VHlwZXMob2JqLCB0eXBlcylcbiAqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIG9iamVjdCBiZWluZyB0ZXN0ZWQgYWdhaW5zdCBpcyBvZiBhIHZhbGlkIHR5cGUuXG4gKlxuICogICAgIHV0aWxzLmV4cGVjdFR5cGVzKHRoaXMsIFsnYXJyYXknLCAnb2JqZWN0JywgJ3N0cmluZyddKTtcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmogY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlIEEgbGlzdCBvZiBhbGxvd2VkIHR5cGVzIGZvciB0aGlzIGFzc2VydGlvblxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZXhwZWN0VHlwZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnYXNzZXJ0aW9uLWVycm9yJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cGVjdFR5cGVzKG9iaiwgdHlwZXMpIHtcbiAgdmFyIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcbiAgdmFyIHNzZmkgPSBmbGFnKG9iaiwgJ3NzZmknKTtcblxuICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgb2JqID0gZmxhZyhvYmosICdvYmplY3QnKTtcbiAgdHlwZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTsgfSk7XG4gIHR5cGVzLnNvcnQoKTtcblxuICAvLyBUcmFuc2Zvcm1zIFsnbG9yZW0nLCAnaXBzdW0nXSBpbnRvICdhIGxvcmVtLCBvciBhbiBpcHN1bSdcbiAgdmFyIHN0ciA9IHR5cGVzLm1hcChmdW5jdGlvbiAodCwgaW5kZXgpIHtcbiAgICB2YXIgYXJ0ID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHQuY2hhckF0KDApKSA/ICdhbicgOiAnYSc7XG4gICAgdmFyIG9yID0gdHlwZXMubGVuZ3RoID4gMSAmJiBpbmRleCA9PT0gdHlwZXMubGVuZ3RoIC0gMSA/ICdvciAnIDogJyc7XG4gICAgcmV0dXJuIG9yICsgYXJ0ICsgJyAnICsgdDtcbiAgfSkuam9pbignLCAnKTtcblxuICB2YXIgb2JqVHlwZSA9IHR5cGUob2JqKS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICghdHlwZXMuc29tZShmdW5jdGlvbiAoZXhwZWN0ZWQpIHsgcmV0dXJuIG9ialR5cGUgPT09IGV4cGVjdGVkOyB9KSkge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgIGZsYWdNc2cgKyAnb2JqZWN0IHRlc3RlZCBtdXN0IGJlICcgKyBzdHIgKyAnLCBidXQgJyArIG9ialR5cGUgKyAnIGdpdmVuJyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHNzZmlcbiAgICApO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0QWN0dWFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0QWN0dWFsKG9iamVjdCwgW2FjdHVhbF0pXG4gKlxuICogUmV0dXJucyB0aGUgYGFjdHVhbGAgdmFsdWUgZm9yIGFuIEFzc2VydGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldEFjdHVhbFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QWN0dWFsKG9iaiwgYXJncykge1xuICByZXR1cm4gYXJncy5sZW5ndGggPiA0ID8gYXJnc1s0XSA6IG9iai5fb2JqO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogIVxuICogQ2hhaSAtIGdldEZ1bmNOYW1lIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RnVuY05hbWUoY29uc3RydWN0b3JGbilcbiAqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24uXG4gKiBXaGVuIGEgbm9uLWZ1bmN0aW9uIGluc3RhbmNlIGlzIHBhc3NlZCwgcmV0dXJucyBgbnVsbGAuXG4gKiBUaGlzIGFsc28gaW5jbHVkZXMgYSBwb2x5ZmlsbCBmdW5jdGlvbiBpZiBgYUZ1bmMubmFtZWAgaXMgbm90IGRlZmluZWQuXG4gKlxuICogQG5hbWUgZ2V0RnVuY05hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciB0b1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jdGlvbk5hbWVNYXRjaCA9IC9cXHMqZnVuY3Rpb24oPzpcXHN8XFxzKlxcL1xcKlteKD86KlxcLyldK1xcKlxcL1xccyopKihbXlxcc1xcKFxcL10rKS87XG5mdW5jdGlvbiBnZXRGdW5jTmFtZShhRnVuYykge1xuICBpZiAodHlwZW9mIGFGdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbmFtZSA9ICcnO1xuICBpZiAodHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYUZ1bmMubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBIZXJlIHdlIHJ1biBhIHBvbHlmaWxsIGlmIEZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSBhbmQgaWYgYUZ1bmMubmFtZSBpcyBub3QgZGVmaW5lZFxuICAgIHZhciBtYXRjaCA9IHRvU3RyaW5nLmNhbGwoYUZ1bmMpLm1hdGNoKGZ1bmN0aW9uTmFtZU1hdGNoKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UndmUgZ290IGEgYG5hbWVgIHByb3BlcnR5IHdlIGp1c3QgdXNlIGl0XG4gICAgbmFtZSA9IGFGdW5jLm5hbWU7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRGdW5jTmFtZTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCwgZW51bWVyYWJsZSBvciBub3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGFkZFByb3BlcnR5KTtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLmluY2x1ZGVTdGFja1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIHN0YWNrIHRyYWNlXG4gICAqIGlzIGluY2x1ZGVkIGluIEFzc2VydGlvbiBlcnJvciBtZXNzYWdlLiBEZWZhdWx0IG9mIGZhbHNlXG4gICAqIHN1cHByZXNzZXMgc3RhY2sgdHJhY2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgPSB0cnVlOyAgLy8gZW5hYmxlIHN0YWNrIG9uIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCwgZm9yXG4gICAqIGV4YW1wbGUgZm9yIGxhcmdlIGRhdGEgc3RydWN0dXJlcywgdGhlIHZhbHVlIGlzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nXG4gICAqIGxpa2UgYFsgQXJyYXkoMykgXWAgb3IgYHsgT2JqZWN0IChwcm9wMSwgcHJvcDIpIH1gLlxuICAgKlxuICAgKiBTZXQgaXQgdG8gemVybyBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRydW5jYXRpbmcgYWx0b2dldGhlci5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IHVzZXJmdWwgd2hlbiBkb2luZyBhc3NlcnRpb25zIG9uIGFycmF5czogaGF2aW5nIHRoaXNcbiAgICogc2V0IHRvIGEgcmVhc29uYWJsZSBsYXJnZSB2YWx1ZSBtYWtlcyB0aGUgZmFpbHVyZSBtZXNzYWdlcyByZWFkaWx5XG4gICAqIGluc3BlY3RhYmxlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgPSAwOyAgLy8gZGlzYWJsZSB0cnVuY2F0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB0cnVuY2F0ZVRocmVzaG9sZDogNDAsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudXNlUHJveHlcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGRlZmluZXMgaWYgY2hhaSB3aWxsIHVzZSBhIFByb3h5IHRvIHRocm93XG4gICAqIGFuIGVycm9yIHdoZW4gYSBub24tZXhpc3RlbnQgcHJvcGVydHkgaXMgcmVhZCwgd2hpY2ggcHJvdGVjdHMgdXNlcnNcbiAgICogZnJvbSB0eXBvcyB3aGVuIHVzaW5nIHByb3BlcnR5LWJhc2VkIGFzc2VydGlvbnMuXG4gICAqXG4gICAqIFNldCBpdCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRoaXMgZmVhdHVyZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLnVzZVByb3h5ID0gZmFsc2U7ICAvLyBkaXNhYmxlIHVzZSBvZiBQcm94eVxuICAgKlxuICAgKiBUaGlzIGZlYXR1cmUgaXMgYXV0b21hdGljYWxseSBkaXNhYmxlZCByZWdhcmRsZXNzIG9mIHRoaXMgY29uZmlnIHZhbHVlXG4gICAqIGluIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgcHJveGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB1c2VQcm94eTogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5c1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgZGVmaW5lcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBpZ25vcmVkXG4gICAqIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlIGFzc2VydGlvbi5cbiAgICogVGhpcyBpcyBvbmx5IGFwcGxpZWQgaWYgdGhlIGVudmlyb25tZW50IENoYWkgaXMgcnVubmluZyBpbiBzdXBwb3J0cyBwcm94aWVzIGFuZFxuICAgKiBpZiB0aGUgYHVzZVByb3h5YCBjb25maWd1cmF0aW9uIHNldHRpbmcgaXMgZW5hYmxlZC5cbiAgICogQnkgZGVmYXVsdCwgYHRoZW5gIGFuZCBgaW5zcGVjdGAgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgdGhleSBkbyBub3QgZXhpc3Qgb24gdGhlXG4gICAqIGFzc2VydGlvbiBvYmplY3QgYmVjYXVzZSB0aGUgYC5pbnNwZWN0YCBwcm9wZXJ0eSBpcyByZWFkIGJ5IGB1dGlsLmluc3BlY3RgIChmb3IgZXhhbXBsZSwgd2hlblxuICAgKiB1c2luZyBgY29uc29sZS5sb2dgIG9uIHRoZSBhc3NlcnRpb24gb2JqZWN0KSBhbmQgYC50aGVuYCBpcyBuZWNlc3NhcnkgZm9yIHByb21pc2UgdHlwZS1jaGVja2luZy5cbiAgICpcbiAgICogICAgIC8vIEJ5IGRlZmF1bHQgdGhlc2Uga2V5cyB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGV5IGRvIG5vdCBleGlzdCBvbiB0aGUgYXNzZXJ0aW9uIG9iamVjdFxuICAgKiAgICAgY2hhaS5jb25maWcucHJveHlFeGNsdWRlZEtleXMgPSBbJ3RoZW4nLCAnaW5zcGVjdCddO1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBwcm94eUV4Y2x1ZGVkS2V5czogWyd0aGVuJywgJ2NhdGNoJywgJ2luc3BlY3QnLCAndG9KU09OJ11cbn07XG4iLCIvLyBUaGlzIGlzIChhbG1vc3QpIGRpcmVjdGx5IGZyb20gTm9kZS5qcyB1dGlsc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvZjhjMzM1ZDBjYWY0N2YxNmQzMTQxM2Y4OWFhMjhlZGEzODc4ZTNhYS9saWIvdXRpbC5qc1xuXG52YXIgZ2V0TmFtZSA9IHJlcXVpcmUoJ2dldC1mdW5jLW5hbWUnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zcGVjdDtcblxuLyoqXG4gKiAjIyMgLmluc3BlY3Qob2JqLCBbc2hvd0hpZGRlbl0sIFtkZXB0aF0sIFtjb2xvcnNdKVxuICpcbiAqIEVjaG9lcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJpZXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0hpZGRlbiBGbGFnIHRoYXQgc2hvd3MgaGlkZGVuIChub3QgZW51bWVyYWJsZSlcbiAqICAgIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBEZXB0aCBpbiB3aGljaCB0byBkZXNjZW5kIGluIG9iamVjdC4gRGVmYXVsdCBpcyAyLlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnMgRmxhZyB0byB0dXJuIG9uIEFOU0kgZXNjYXBlIGNvZGVzIHRvIGNvbG9yIHRoZVxuICogICAgb3V0cHV0LiBEZWZhdWx0IGlzIGZhbHNlIChubyBjb2xvcmluZykuXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBpbnNwZWN0XG4gKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBjdHggPSB7XG4gICAgc2hvd0hpZGRlbjogc2hvd0hpZGRlbixcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHI7IH1cbiAgfTtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgJ25vZGVUeXBlJyBpbiBvYmplY3QgJiZcbiAgICAgIG9iamVjdC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gSWYgdGhpcyBpcyBhIERPTSBlbGVtZW50LCB0cnkgdG8gZ2V0IHRoZSBvdXRlciBIVE1MLlxuICBpZiAoaXNET01FbGVtZW50KHZhbHVlKSkge1xuICAgIGlmICgnb3V0ZXJIVE1MJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm91dGVySFRNTDtcbiAgICAgIC8vIFRoaXMgdmFsdWUgZG9lcyBub3QgaGF2ZSBhbiBvdXRlckhUTUwgYXR0cmlidXRlLFxuICAgICAgLy8gICBpdCBjb3VsZCBzdGlsbCBiZSBhbiBYTUwgZWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIHNlcmlhbGl6ZSBpdFxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnhtbFZlcnNpb24pIHtcbiAgICAgICAgICB2YXIgeG1sU2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG4gICAgICAgICAgcmV0dXJuIHhtbFNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpcmVmb3ggMTEtIGRvIG5vdCBzdXBwb3J0IG91dGVySFRNTFxuICAgICAgICAgIC8vICAgSXQgZG9lcywgaG93ZXZlciwgc3VwcG9ydCBpbm5lckhUTUxcbiAgICAgICAgICAvLyAgIFVzZSB0aGUgZm9sbG93aW5nIHRvIHJlbmRlciB0aGUgZWxlbWVudFxuICAgICAgICAgIHZhciBucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdfJyk7XG5cbiAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmFsdWUuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgICAgICAgdmFyIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICAgICAgICAucmVwbGFjZSgnPjwnLCAnPicgKyB2YWx1ZS5pbm5lckhUTUwgKyAnPCcpO1xuICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYSBub24tbmF0aXZlIERPTSBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgLy8gICBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgZmxvdzpcbiAgICAgICAgLy8gICBwcmludGluZyB0aGUgZWxlbWVudCBhcyBpZiBpdCBpcyBhbiBvYmplY3QuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIgdmlzaWJsZUtleXMgPSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyh2YWx1ZSk7XG4gIHZhciBrZXlzID0gY3R4LnNob3dIaWRkZW4gPyBnZXRQcm9wZXJ0aWVzKHZhbHVlKSA6IHZpc2libGVLZXlzO1xuXG4gIHZhciBuYW1lLCBuYW1lU3VmZml4O1xuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dC5cbiAgLy8gSW4gSUUsIGVycm9ycyBoYXZlIGEgc2luZ2xlIGBzdGFja2AgcHJvcGVydHksIG9yIGlmIHRoZXkgYXJlIHZhbmlsbGEgYEVycm9yYCxcbiAgLy8gYSBgc3RhY2tgIHBsdXMgYGRlc2NyaXB0aW9uYCBwcm9wZXJ0eTsgaWdub3JlIHRob3NlIGZvciBjb25zaXN0ZW5jeS5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IChpc0Vycm9yKHZhbHVlKSAmJiAoXG4gICAgICAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ3N0YWNrJykgfHxcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMiAmJiBrZXlzWzBdID09PSAnZGVzY3JpcHRpb24nICYmIGtleXNbMV0gPT09ICdzdGFjaycpXG4gICAgICkpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgICAgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJydcbiAgICAsIGFycmF5ID0gZmFsc2VcbiAgICAsIHR5cGVkQXJyYXkgPSBmYWxzZVxuICAgICwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgIHR5cGVkQXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2UgaWYgKHR5cGVkQXJyYXkpIHtcbiAgICByZXR1cm4gZm9ybWF0VHlwZWRBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKHZhbHVlID09PSAwICYmICgxL3ZhbHVlKSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnLTAnLCAnbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUodmFsdWUudG9TdHJpbmcoKSwgJ3N5bWJvbCcpO1xuICB9XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHZhciBzdHIgPSAnWyAnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgLSA3KSB7XG4gICAgICBzdHIgKz0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc3RyICs9IHZhbHVlW2ldICsgJywgJztcbiAgfVxuICBzdHIgKz0gJyBdJztcblxuICAvLyBSZW1vdmluZyB0cmFpbGluZyBgLCBgIGlmIHRoZSBhcnJheSB3YXMgbm90IHRydW5jYXRlZFxuICBpZiAoc3RyLmluZGV4T2YoJywgIF0nKSAhPT0gLTEpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgnLCAgXScsICcgXScpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZTtcbiAgdmFyIHByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KTtcbiAgdmFyIHN0cjtcblxuICBpZiAocHJvcERlc2NyaXB0b3IpIHtcbiAgICBpZiAocHJvcERlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICBpZiAocHJvcERlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BEZXNjcmlwdG9yLnNldCkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlzaWJsZUtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhcikge1xuICAvLyBVbmZvcnR1bmF0ZWx5IHRoZXJlJ3Mgbm8gd2F5IHRvIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBhIFR5cGVkQXJyYXlcbiAgLy8gV2UgaGF2ZSB0byBjaGVjayBpZiBpdCdzIG9uZSBvZiB0aGVzZSB0eXBlc1xuICByZXR1cm4gKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgL1xcdytBcnJheV0kLy50ZXN0KG9iamVjdFRvU3RyaW5nKGFyKSkpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLm9iakRpc3BsYXkob2JqZWN0KVxuICpcbiAqIERldGVybWluZXMgaWYgYW4gb2JqZWN0IG9yIGFuIGFycmF5IG1hdGNoZXNcbiAqIGNyaXRlcmlhIHRvIGJlIGluc3BlY3RlZCBpbi1saW5lIGZvciBlcnJvclxuICogbWVzc2FnZXMgb3Igc2hvdWxkIGJlIHRydW5jYXRlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBqYXZhc2NyaXB0IG9iamVjdCB0byBpbnNwZWN0XG4gKiBAbmFtZSBvYmpEaXNwbGF5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb2JqRGlzcGxheShvYmopIHtcbiAgdmFyIHN0ciA9IGluc3BlY3Qob2JqKVxuICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIGlmIChjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgJiYgc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgcmV0dXJuICFvYmoubmFtZSB8fCBvYmoubmFtZSA9PT0gJydcbiAgICAgICAgPyAnW0Z1bmN0aW9uXSdcbiAgICAgICAgOiAnW0Z1bmN0aW9uOiAnICsgb2JqLm5hbWUgKyAnXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ1sgQXJyYXkoJyArIG9iai5sZW5ndGggKyAnKSBdJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLCBrc3RyID0ga2V5cy5sZW5ndGggPiAyXG4gICAgICAgICAgPyBrZXlzLnNwbGljZSgwLCAyKS5qb2luKCcsICcpICsgJywgLi4uJ1xuICAgICAgICAgIDoga2V5cy5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuICd7IE9iamVjdCAoJyArIGtzdHIgKyAnKSB9JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG1lc3NhZ2UgY29tcG9zaXRpb24gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJylcbiAgLCBnZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpXG4gICwgb2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShvYmplY3QsIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UpXG4gKlxuICogQ29uc3RydWN0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIGZsYWdzXG4gKiBhbmQgdGVtcGxhdGUgdGFncy4gVGVtcGxhdGUgdGFncyB3aWxsIHJldHVyblxuICogYSBzdHJpbmdpZmllZCBpbnNwZWN0aW9uIG9mIHRoZSBvYmplY3QgcmVmZXJlbmNlZC5cbiAqXG4gKiBNZXNzYWdlIHRlbXBsYXRlIHRhZ3M6XG4gKiAtIGAje3RoaXN9YCBjdXJyZW50IGFzc2VydGVkIG9iamVjdFxuICogLSBgI3thY3R9YCBhY3R1YWwgdmFsdWVcbiAqIC0gYCN7ZXhwfWAgZXhwZWN0ZWQgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE1lc3NhZ2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRNZXNzYWdlKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgdmFsID0gZmxhZyhvYmosICdvYmplY3QnKVxuICAgICwgZXhwZWN0ZWQgPSBhcmdzWzNdXG4gICAgLCBhY3R1YWwgPSBnZXRBY3R1YWwob2JqLCBhcmdzKVxuICAgICwgbXNnID0gbmVnYXRlID8gYXJnc1syXSA6IGFyZ3NbMV1cbiAgICAsIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcblxuICBpZih0eXBlb2YgbXNnID09PSBcImZ1bmN0aW9uXCIpIG1zZyA9IG1zZygpO1xuICBtc2cgPSBtc2cgfHwgJyc7XG4gIG1zZyA9IG1zZ1xuICAgIC5yZXBsYWNlKC8jXFx7dGhpc1xcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KHZhbCk7IH0pXG4gICAgLnJlcGxhY2UoLyNcXHthY3RcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheShhY3R1YWwpOyB9KVxuICAgIC5yZXBsYWNlKC8jXFx7ZXhwXFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkoZXhwZWN0ZWQpOyB9KTtcblxuICByZXR1cm4gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnICsgbXNnIDogbXNnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRyYW5zZmVyRmxhZ3MgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsID0gdHJ1ZSlcbiAqXG4gKiBUcmFuc2ZlciBhbGwgdGhlIGZsYWdzIGZvciBgYXNzZXJ0aW9uYCB0byBgb2JqZWN0YC4gSWZcbiAqIGBpbmNsdWRlQWxsYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhlbiB0aGUgYmFzZSBDaGFpXG4gKiBhc3NlcnRpb24gZmxhZ3MgKG5hbWVseSBgb2JqZWN0YCwgYHNzZmlgLCBgbG9ja1NzZmlgLFxuICogYW5kIGBtZXNzYWdlYCkgd2lsbCBub3QgYmUgdHJhbnNmZXJyZWQuXG4gKlxuICpcbiAqICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbigpO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBuZXdBc3NlcnRpb24pO1xuICpcbiAqICAgICB2YXIgYW5vdGhlckFzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24obXlPYmopO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBhbm90aGVyQXNzZXJ0aW9uLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtBc3NlcnRpb259IGFzc2VydGlvbiB0aGUgYXNzZXJ0aW9uIHRvIHRyYW5zZmVyIHRoZSBmbGFncyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgdG8gdHJhbnNmZXIgdGhlIGZsYWdzIHRvOyB1c3VhbGx5IGEgbmV3IGFzc2VydGlvblxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlQWxsXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSB0cmFuc2ZlckZsYWdzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwpIHtcbiAgdmFyIGZsYWdzID0gYXNzZXJ0aW9uLl9fZmxhZ3MgfHwgKGFzc2VydGlvbi5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgaWYgKCFvYmplY3QuX19mbGFncykge1xuICAgIG9iamVjdC5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIGluY2x1ZGVBbGwgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzID8gaW5jbHVkZUFsbCA6IHRydWU7XG5cbiAgZm9yICh2YXIgZmxhZyBpbiBmbGFncykge1xuICAgIGlmIChpbmNsdWRlQWxsIHx8XG4gICAgICAgIChmbGFnICE9PSAnb2JqZWN0JyAmJiBmbGFnICE9PSAnc3NmaScgJiYgZmxhZyAhPT0gJ2xvY2tTc2ZpJyAmJiBmbGFnICE9ICdtZXNzYWdlJykpIHtcbiAgICAgIG9iamVjdC5fX2ZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFscyBTeW1ib2w6IGZhbHNlLCBVaW50OEFycmF5OiBmYWxzZSwgV2Vha01hcDogZmFsc2UgKi9cbi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuZnVuY3Rpb24gRmFrZU1hcCgpIHtcbiAgdGhpcy5fa2V5ID0gJ2NoYWkvZGVlcC1lcWxfXycgKyBNYXRoLnJhbmRvbSgpICsgRGF0ZS5ub3coKTtcbn1cblxuRmFrZU1hcC5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0TWFwKGtleSkge1xuICAgIHJldHVybiBrZXlbdGhpcy5fa2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXRNYXAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMuX2tleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbn07XG5cbnZhciBNZW1vaXplTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogRmFrZU1hcDtcbi8qIVxuICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBNZW1vaXplTWFwIGhhcyByZWNvcmRlZCBhIHJlc3VsdCBvZiB0aGUgdHdvIG9wZXJhbmRzXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEByZXR1cm5zIHtCb29sZWFufG51bGx9IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVDb21wYXJlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbWVtb2l6ZU1hcCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlZnRIYW5kTWFwID0gbWVtb2l6ZU1hcC5nZXQobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kTWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxlZnRIYW5kTWFwLmdldChyaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBTZXQgdGhlIHJlc3VsdCBvZiB0aGUgZXF1YWxpdHkgaW50byB0aGUgTWVtb2l6ZU1hcFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNZW1vaXplTWFwfSBtZW1vaXplTWFwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3VsdFxuKi9cbmZ1bmN0aW9uIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwLCByZXN1bHQpIHtcbiAgLy8gVGVjaG5pY2FsbHksIFdlYWtNYXAga2V5cyBjYW4gKm9ubHkqIGJlIG9iamVjdHMsIG5vdCBwcmltaXRpdmVzLlxuICBpZiAoIW1lbW9pemVNYXAgfHwgaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0SGFuZE1hcCA9IG5ldyBNZW1vaXplTWFwKCk7XG4gICAgbGVmdEhhbmRNYXAuc2V0KHJpZ2h0SGFuZE9wZXJhbmQsIHJlc3VsdCk7XG4gICAgbWVtb2l6ZU1hcC5zZXQobGVmdEhhbmRPcGVyYW5kLCBsZWZ0SGFuZE1hcCk7XG4gIH1cbn1cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFsO1xubW9kdWxlLmV4cG9ydHMuTWVtb2l6ZU1hcCA9IE1lbW9pemVNYXA7XG5cbi8qKlxuICogQXNzZXJ0IGRlZXBseSBuZXN0ZWQgc2FtZVZhbHVlIGVxdWFsaXR5IGJldHdlZW4gdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChvcHRpb25hbCkgQWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5jb21wYXJhdG9yXSAob3B0aW9uYWwpIE92ZXJyaWRlIGRlZmF1bHQgYWxnb3JpdGhtLCBkZXRlcm1pbmluZyBjdXN0b20gZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tZW1vaXplXSAob3B0aW9uYWwpIFByb3ZpZGUgYSBjdXN0b20gbWVtb2l6YXRpb24gb2JqZWN0IHdoaWNoIHdpbGwgY2FjaGUgdGhlIHJlc3VsdHMgb2ZcbiAgICBjb21wbGV4IG9iamVjdHMgZm9yIGEgc3BlZWQgYm9vc3QuIEJ5IHBhc3NpbmcgYGZhbHNlYCB5b3UgY2FuIGRpc2FibGUgbWVtb2l6YXRpb24sIGJ1dCB0aGlzIHdpbGwgY2F1c2UgY2lyY3VsYXJcbiAgICByZWZlcmVuY2VzIHRvIGJsb3cgdGhlIHN0YWNrLlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICAvLyBJZiB3ZSBoYXZlIGEgY29tcGFyYXRvciwgd2UgY2FuJ3QgYXNzdW1lIGFueXRoaW5nOyBzbyBiYWlsIHRvIGl0cyBjaGVjayBmaXJzdC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNpbXBsZVJlc3VsdCA9IHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICB9XG5cbiAgLy8gRGVlcGVyIGNvbXBhcmlzb25zIGFyZSBwdXNoZWQgdGhyb3VnaCB0byBhIGxhcmdlciBmdW5jdGlvblxuICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTWFueSBjb21wYXJpc29ucyBjYW4gYmUgY2FuY2VsZWQgb3V0IGVhcmx5IHZpYSBzaW1wbGUgZXF1YWxpdHkgb3IgcHJpbWl0aXZlIGNoZWNrcy5cbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbnxudWxsfSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgLy8gRXF1YWwgcmVmZXJlbmNlcyAoZXhjZXB0IGZvciBOdW1iZXJzKSBjYW4gYmUgcmV0dXJuZWQgZWFybHlcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZCkge1xuICAgIC8vIEhhbmRsZSArLTAgY2FzZXNcbiAgICByZXR1cm4gbGVmdEhhbmRPcGVyYW5kICE9PSAwIHx8IDEgLyBsZWZ0SGFuZE9wZXJhbmQgPT09IDEgLyByaWdodEhhbmRPcGVyYW5kO1xuICB9XG5cbiAgLy8gaGFuZGxlIE5hTiBjYXNlc1xuICBpZiAoXG4gICAgbGVmdEhhbmRPcGVyYW5kICE9PSBsZWZ0SGFuZE9wZXJhbmQgJiYgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByaWdodEhhbmRPcGVyYW5kICE9PSByaWdodEhhbmRPcGVyYW5kIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gQW55dGhpbmcgdGhhdCBpcyBub3QgYW4gJ29iamVjdCcsIGkuZS4gc3ltYm9scywgZnVuY3Rpb25zLCBib29sZWFucywgbnVtYmVycyxcbiAgLy8gc3RyaW5ncywgYW5kIHVuZGVmaW5lZCwgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZS5cbiAgaWYgKGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICAvLyBFYXN5IG91dCBiL2MgaXQgd291bGQgaGF2ZSBwYXNzZWQgdGhlIGZpcnN0IGVxdWFsaXR5IGNoZWNrXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFRoZSBtYWluIGxvZ2ljIG9mIHRoZSBgZGVlcEVxdWFsYCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuKi9cbmZ1bmN0aW9uIGV4dGVuc2l2ZURlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMubWVtb2l6ZSA9IG9wdGlvbnMubWVtb2l6ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IG9wdGlvbnMubWVtb2l6ZSB8fCBuZXcgTWVtb2l6ZU1hcCgpO1xuICB2YXIgY29tcGFyYXRvciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYXJhdG9yO1xuXG4gIC8vIENoZWNrIGlmIGEgbWVtb2l6ZWQgcmVzdWx0IGV4aXN0cy5cbiAgdmFyIG1lbW9pemVSZXN1bHRMZWZ0ID0gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdExlZnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbWVtb2l6ZVJlc3VsdExlZnQ7XG4gIH1cbiAgdmFyIG1lbW9pemVSZXN1bHRSaWdodCA9IG1lbW9pemVDb21wYXJlKHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplKTtcbiAgaWYgKG1lbW9pemVSZXN1bHRSaWdodCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0UmlnaHQ7XG4gIH1cblxuICAvLyBJZiBhIGNvbXBhcmF0b3IgaXMgcHJlc2VudCwgdXNlIGl0LlxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIHZhciBjb21wYXJhdG9yUmVzdWx0ID0gY29tcGFyYXRvcihsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIC8vIENvbXBhcmF0b3JzIG1heSByZXR1cm4gbnVsbCwgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGdvIGJhY2sgdG8gZGVmYXVsdCBiZWhhdmlvci5cbiAgICBpZiAoY29tcGFyYXRvclJlc3VsdCA9PT0gZmFsc2UgfHwgY29tcGFyYXRvclJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgY29tcGFyYXRvclJlc3VsdCk7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclJlc3VsdDtcbiAgICB9XG4gICAgLy8gVG8gYWxsb3cgY29tcGFyYXRvcnMgdG8gb3ZlcnJpZGUgKmFueSogYmVoYXZpb3IsIHdlIHJhbiB0aGVtIGZpcnN0LiBTaW5jZSBpdCBkaWRuJ3QgZGVjaWRlXG4gICAgLy8gd2hhdCB0byBkbywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdG8gcmV0dXJuIHRoZSBiYXNpYyB0ZXN0cyBmaXJzdCBiZWZvcmUgd2UgbW92ZSBvbi5cbiAgICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBpZiAoc2ltcGxlUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAvLyBEb24ndCBtZW1vaXplIHRoaXMsIGl0IHRha2VzIGxvbmdlciB0byBzZXQvcmV0cmlldmUgdGhhbiB0byBqdXN0IGNvbXBhcmUuXG4gICAgICByZXR1cm4gc2ltcGxlUmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZWZ0SGFuZFR5cGUgPSB0eXBlKGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZFR5cGUgIT09IHR5cGUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVtcG9yYXJpbHkgc2V0IHRoZSBvcGVyYW5kcyBpbiB0aGUgbWVtb2l6ZSBvYmplY3QgdG8gcHJldmVudCBibG93aW5nIHRoZSBzdGFja1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCB0cnVlKTtcblxuICB2YXIgcmVzdWx0ID0gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKTtcbiAgbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsQnlUeXBlKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRUeXBlLCBvcHRpb25zKSB7XG4gIHN3aXRjaCAobGVmdEhhbmRUeXBlKSB7XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgLy8gSWYgdGhlc2UgdHlwZXMgYXJlIHRoZWlyIGluc3RhbmNlIHR5cGVzIChlLmcuIGBuZXcgTnVtYmVyYCkgdGhlbiByZS1kZWVwRXF1YWwgYWdhaW5zdCB0aGVpciB2YWx1ZXNcbiAgICAgIHJldHVybiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLnZhbHVlT2YoKSwgcmlnaHRIYW5kT3BlcmFuZC52YWx1ZU9mKCkpO1xuICAgIGNhc2UgJ1Byb21pc2UnOlxuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgIGNhc2UgJ1dlYWtTZXQnOlxuICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgPT09IHJpZ2h0SGFuZE9wZXJhbmQ7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdJbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpcbiAgICBjYXNlICdJbnQxNkFycmF5JzpcbiAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgY2FzZSAnSW50MzJBcnJheSc6XG4gICAgY2FzZSAnVWludDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICByZXR1cm4gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgICBjYXNlICdHZW5lcmF0b3InOlxuICAgICAgcmV0dXJuIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnRGF0YVZpZXcnOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kLmJ1ZmZlciksIG5ldyBVaW50OEFycmF5KHJpZ2h0SGFuZE9wZXJhbmQuYnVmZmVyKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobmV3IFVpbnQ4QXJyYXkobGVmdEhhbmRPcGVyYW5kKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gZW50cmllc0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnTWFwJzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKSB7XG4gIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQudG9TdHJpbmcoKSA9PT0gcmlnaHRIYW5kT3BlcmFuZC50b1N0cmluZygpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFNldHMvTWFwcyBmb3IgZXF1YWxpdHkuIEZhc3RlciB0aGFuIG90aGVyIGVxdWFsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1NldH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge1NldH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElFMTEgZG9lc24ndCBzdXBwb3J0IFNldCNlbnRyaWVzIG9yIFNldCNAQGl0ZXJhdG9yLCBzbyB3ZSBuZWVkIG1hbnVhbGx5IHBvcHVsYXRlIHVzaW5nIFNldCNmb3JFYWNoXG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSAhPT0gcmlnaHRIYW5kT3BlcmFuZC5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZWZ0SGFuZE9wZXJhbmQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBsZWZ0SGFuZEl0ZW1zID0gW107XG4gIHZhciByaWdodEhhbmRJdGVtcyA9IFtdO1xuICBsZWZ0SGFuZE9wZXJhbmQuZm9yRWFjaChmdW5jdGlvbiBnYXRoZXJFbnRyaWVzKGtleSwgdmFsdWUpIHtcbiAgICBsZWZ0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmlnaHRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIHJpZ2h0SGFuZEl0ZW1zLnB1c2goWyBrZXksIHZhbHVlIF0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRJdGVtcy5zb3J0KCksIHJpZ2h0SGFuZEl0ZW1zLnNvcnQoKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHMgc3VjaCBhcyBBcnJheXMsIFR5cGVkQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGxlZnRIYW5kT3BlcmFuZC5sZW5ndGg7XG4gIGlmIChsZW5ndGggIT09IHJpZ2h0SGFuZE9wZXJhbmQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgaW5kZXggPSAtMTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoZGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZFtpbmRleF0sIHJpZ2h0SGFuZE9wZXJhbmRbaW5kZXhdLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBnZW5lcmF0b3Igb2JqZWN0cyBzdWNoIGFzIHRob3NlIHJldHVybmVkIGJ5IGdlbmVyYXRvciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRvckVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChnZXRHZW5lcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCksIGdldEdlbmVyYXRvckVudHJpZXMocmlnaHRIYW5kT3BlcmFuZCksIG9wdGlvbnMpO1xufVxuXG4vKiFcbiAqIERldGVybWluZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhbiBAQGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBoYXNJdGVyYXRvckZ1bmN0aW9uKHRhcmdldCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGl0ZXJhdG9yIGVudHJpZXMgZnJvbSB0aGUgZ2l2ZW4gT2JqZWN0LiBJZiB0aGUgT2JqZWN0IGhhcyBubyBAQGl0ZXJhdG9yIGZ1bmN0aW9uLCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICogVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGl0ZXJhdG9yIC0gd2hpY2ggY291bGQgaGF2ZSBzaWRlIGVmZmVjdHMgZGVwZW5kaW5nIG9uIHRoZSBAQGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBAQGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRW50cmllcyh0YXJnZXQpIHtcbiAgaWYgKGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2V0R2VuZXJhdG9yRW50cmllcyh0YXJnZXRbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICB9IGNhdGNoIChpdGVyYXRvckVycm9yKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBlbnRyaWVzIGZyb20gYSBHZW5lcmF0b3IuIFRoaXMgd2lsbCBjb25zdW1lIHRoZSBnZW5lcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0dlbmVyYXRvcn0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIGVudHJpZXMgZnJvbSB0aGUgR2VuZXJhdG9yLlxuICovXG5mdW5jdGlvbiBnZXRHZW5lcmF0b3JFbnRyaWVzKGdlbmVyYXRvcikge1xuICB2YXIgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgdmFyIGFjY3VtdWxhdG9yID0gWyBnZW5lcmF0b3JSZXN1bHQudmFsdWUgXTtcbiAgd2hpbGUgKGdlbmVyYXRvclJlc3VsdC5kb25lID09PSBmYWxzZSkge1xuICAgIGdlbmVyYXRvclJlc3VsdCA9IGdlbmVyYXRvci5uZXh0KCk7XG4gICAgYWNjdW11bGF0b3IucHVzaChnZW5lcmF0b3JSZXN1bHQudmFsdWUpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyohXG4gKiBHZXRzIGFsbCBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIGtleXMgZnJvbSBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIHRoZSB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVLZXlzKHRhcmdldCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lcyBpZiB0d28gb2JqZWN0cyBoYXZlIG1hdGNoaW5nIHZhbHVlcywgZ2l2ZW4gYSBzZXQgb2Yga2V5cy4gRGVmZXJzIHRvIGRlZXBFcXVhbCBmb3IgdGhlIGVxdWFsaXR5IGNoZWNrIG9mXG4gKiBlYWNoIGtleS4gSWYgYW55IHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkgaXMgbm90IGVxdWFsLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UgKGVhcmx5KS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7QXJyYXl9IGtleXMgQW4gYXJyYXkgb2Yga2V5cyB0byBjb21wYXJlIHRoZSB2YWx1ZXMgb2YgbGVmdEhhbmRPcGVyYW5kIGFuZCByaWdodEhhbmRPcGVyYW5kIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2tleXNbaV1dLCByaWdodEhhbmRPcGVyYW5kW2tleXNbaV1dLCBvcHRpb25zKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBPYmplY3RzLiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGwgZGVmZXIgdG8gYGRlZXBFcXVhbGBcbiAqIGZvciBlYWNoIGVudW1lcmFibGUga2V5IGluIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVmdEhhbmRLZXlzID0gZ2V0RW51bWVyYWJsZUtleXMobGVmdEhhbmRPcGVyYW5kKTtcbiAgdmFyIHJpZ2h0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kS2V5cy5sZW5ndGggJiYgbGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gcmlnaHRIYW5kS2V5cy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEtleXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEtleXMuc29ydCgpO1xuICAgIGlmIChpdGVyYWJsZUVxdWFsKGxlZnRIYW5kS2V5cywgcmlnaHRIYW5kS2V5cykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXlzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZEtleXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxlZnRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kRW50cmllcyA9IGdldEl0ZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kRW50cmllcy5sZW5ndGggJiYgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gcmlnaHRIYW5kRW50cmllcy5sZW5ndGgpIHtcbiAgICBsZWZ0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJpZ2h0SGFuZEVudHJpZXMuc29ydCgpO1xuICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kRW50cmllcywgcmlnaHRIYW5kRW50cmllcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgbGVmdEhhbmRFbnRyaWVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kS2V5cy5sZW5ndGggPT09IDAgJiZcbiAgICAgIHJpZ2h0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qIVxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHByaW1pdGl2ZS5cbiAqXG4gKiBUaGlzIGludGVudGlvbmFsbHkgcmV0dXJucyB0cnVlIGZvciBhbGwgb2JqZWN0cyB0aGF0IGNhbiBiZSBjb21wYXJlZCBieSByZWZlcmVuY2UsXG4gKiBpbmNsdWRpbmcgZnVuY3Rpb25zIGFuZCBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCc7XG59XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qIVxuICogQ2hhaSAtIGlzUHJveHlFbmFibGVkIGhlbHBlclxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5pc1Byb3h5RW5hYmxlZCgpXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIENoYWkncyBwcm94eSBwcm90ZWN0aW9uIGZlYXR1cmUgaXMgZW5hYmxlZC4gSWZcbiAqIHByb3hpZXMgYXJlIHVuc3VwcG9ydGVkIG9yIGRpc2FibGVkIHZpYSB0aGUgdXNlcidzIENoYWkgY29uZmlnLCB0aGVuIHJldHVyblxuICogZmFsc2UuIE90aGVyd2lzZSwgcmV0dXJuIHRydWUuXG4gKlxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgaXNQcm94eUVuYWJsZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJveHlFbmFibGVkKCkge1xuICByZXR1cm4gY29uZmlnLnVzZVByb3h5ICYmXG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLmFkZFByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKVxuICpcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKCkge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuaW5zdGFuY2VvZihGb28pO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUuZm9vO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRQcm9wZXJ0eShjdHgsIG5hbWUsIGdldHRlcikge1xuICBnZXR0ZXIgPSBnZXR0ZXIgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHt9IDogZ2V0dGVyO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIHByb3BlcnR5R2V0dGVyKCkge1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgcHJvcGVydHlHZXR0ZXJgIGNhdXNlcyB0aGlzIGZ1bmN0aW9uIHRvXG4gICAgICAgIC8vIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb24gZnJhbWVzIGZyb20gdGhlXG4gICAgICAgIC8vIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZlxuICAgICAgICAvLyB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldCBhbmQgcHJveHkgcHJvdGVjdGlvbiBpcyBkaXNhYmxlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gZWl0aGVyIHRoaXMgYXNzZXJ0aW9uIGhhcyBiZWVuXG4gICAgICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkXG4gICAgICAgIC8vIGZyb20gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnXG4gICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uIEluIHRoZSBzZWNvbmRcbiAgICAgICAgLy8gY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHByb3h5IHByb3RlY3Rpb24gaXMgZW5hYmxlZCwgdGhlbiB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlblxuICAgICAgICAvLyBzZXQgYnkgdGhlIHByb3h5IGdldHRlci5cbiAgICAgICAgaWYgKCFpc1Byb3h5RW5hYmxlZCgpICYmICFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIHByb3BlcnR5R2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwidmFyIGZuTGVuZ3RoRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnVuY3Rpb24gKCkge30sICdsZW5ndGgnKTtcblxuLyohXG4gKiBDaGFpIC0gYWRkTGVuZ3RoR3VhcmQgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5hZGRMZW5ndGhHdWFyZChmbiwgYXNzZXJ0aW9uTmFtZSwgaXNDaGFpbmFibGUpXG4gKlxuICogRGVmaW5lIGBsZW5ndGhgIGFzIGEgZ2V0dGVyIG9uIHRoZSBnaXZlbiB1bmludm9rZWQgbWV0aG9kIGFzc2VydGlvbi4gVGhlXG4gKiBnZXR0ZXIgYWN0cyBhcyBhIGd1YXJkIGFnYWluc3QgY2hhaW5pbmcgYGxlbmd0aGAgZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZFxuICogbWV0aG9kIGFzc2VydGlvbiwgd2hpY2ggaXMgYSBwcm9ibGVtIGJlY2F1c2UgaXQgcmVmZXJlbmNlcyBgZnVuY3Rpb25gJ3NcbiAqIGJ1aWx0LWluIGBsZW5ndGhgIHByb3BlcnR5IGluc3RlYWQgb2YgQ2hhaSdzIGBsZW5ndGhgIGFzc2VydGlvbi4gV2hlbiB0aGVcbiAqIGdldHRlciBjYXRjaGVzIHRoZSB1c2VyIG1ha2luZyB0aGlzIG1pc3Rha2UsIGl0IHRocm93cyBhbiBlcnJvciB3aXRoIGFcbiAqIGhlbHBmdWwgbWVzc2FnZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgaW4gd2hpY2ggdGhpcyBtaXN0YWtlIGNhbiBiZSBtYWRlLiBUaGUgZmlyc3Qgd2F5IGlzIGJ5XG4gKiBjaGFpbmluZyB0aGUgYGxlbmd0aGAgYXNzZXJ0aW9uIGRpcmVjdGx5IG9mZiBvZiBhbiB1bmludm9rZWQgY2hhaW5hYmxlXG4gKiBtZXRob2QuIEluIHRoaXMgY2FzZSwgQ2hhaSBzdWdnZXN0cyB0aGF0IHRoZSB1c2VyIHVzZSBgbGVuZ3RoT2ZgIGluc3RlYWQuIFRoZVxuICogc2Vjb25kIHdheSBpcyBieSBjaGFpbmluZyB0aGUgYGxlbmd0aGAgYXNzZXJ0aW9uIGRpcmVjdGx5IG9mZiBvZiBhbiB1bmludm9rZWRcbiAqIG5vbi1jaGFpbmFibGUgbWV0aG9kLiBOb24tY2hhaW5hYmxlIG1ldGhvZHMgbXVzdCBiZSBpbnZva2VkIHByaW9yIHRvXG4gKiBjaGFpbmluZy4gSW4gdGhpcyBjYXNlLCBDaGFpIHN1Z2dlc3RzIHRoYXQgdGhlIHVzZXIgY29uc3VsdCB0aGUgZG9jcyBmb3IgdGhlXG4gKiBnaXZlbiBhc3NlcnRpb24uXG4gKlxuICogSWYgdGhlIGBsZW5ndGhgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyB1bmNvbmZpZ3VyYWJsZSwgdGhlbiByZXR1cm4gYGZuYFxuICogd2l0aG91dCBtb2RpZmljYXRpb24uXG4gKlxuICogTm90ZSB0aGF0IGluIEVTNiwgdGhlIGZ1bmN0aW9uJ3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgY29uZmlndXJhYmxlLCBzbyBvbmNlXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIGlzIGRyb3BwZWQsIENoYWkncyBgbGVuZ3RoYCBwcm9wZXJ0eSBjYW5cbiAqIHJlcGxhY2UgdGhlIGJ1aWx0LWluIGZ1bmN0aW9uJ3MgYGxlbmd0aGAgcHJvcGVydHksIGFuZCB0aGlzIGxlbmd0aCBndWFyZCB3aWxsXG4gKiBubyBsb25nZXIgYmUgbmVjZXNzYXJ5LiBJbiB0aGUgbWVhbiB0aW1lLCBtYWludGFpbmluZyBjb25zaXN0ZW5jeSBhY3Jvc3MgYWxsXG4gKiBlbnZpcm9ubWVudHMgaXMgdGhlIHByaW9yaXR5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXNzZXJ0aW9uTmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0NoYWluYWJsZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkTGVuZ3RoR3VhcmRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZExlbmd0aEd1YXJkIChmbiwgYXNzZXJ0aW9uTmFtZSwgaXNDaGFpbmFibGUpIHtcbiAgaWYgKCFmbkxlbmd0aERlc2MuY29uZmlndXJhYmxlKSByZXR1cm4gZm47XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQ2hhaW5hYmxlKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGguIER1ZScgK1xuICAgICAgICAgICcgdG8gYSBjb21wYXRpYmlsaXR5IGlzc3VlLCBcImxlbmd0aFwiIGNhbm5vdCBkaXJlY3RseSBmb2xsb3cgXCInICtcbiAgICAgICAgICBhc3NlcnRpb25OYW1lICsgJ1wiLiBVc2UgXCInICsgYXNzZXJ0aW9uTmFtZSArICcubGVuZ3RoT2ZcIiBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgYXNzZXJ0aW9uTmFtZSArICcubGVuZ3RoLiBTZWUnICtcbiAgICAgICAgJyBkb2NzIGZvciBwcm9wZXIgdXNhZ2Ugb2YgXCInICsgYXNzZXJ0aW9uTmFtZSArICdcIi4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmbjtcbn07XG4iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGdldFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldFByb3BlcnRpZXMnKTtcbnZhciBpc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcblxuLyohXG4gKiBDaGFpIC0gcHJveGlmeSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLnByb3hpZnkob2JqZWN0KVxuICpcbiAqIFJldHVybiBhIHByb3h5IG9mIGdpdmVuIG9iamVjdCB0aGF0IHRocm93cyBhbiBlcnJvciB3aGVuIGEgbm9uLWV4aXN0ZW50XG4gKiBwcm9wZXJ0eSBpcyByZWFkLiBCeSBkZWZhdWx0LCB0aGUgcm9vdCBjYXVzZSBpcyBhc3N1bWVkIHRvIGJlIGEgbWlzc3BlbGxlZFxuICogcHJvcGVydHksIGFuZCB0aHVzIGFuIGF0dGVtcHQgaXMgbWFkZSB0byBvZmZlciBhIHJlYXNvbmFibGUgc3VnZ2VzdGlvbiBmcm9tXG4gKiB0aGUgbGlzdCBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBIb3dldmVyLCBpZiBhIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUgaXNcbiAqIHByb3ZpZGVkLCB0aGVuIHRoZSByb290IGNhdXNlIGlzIGluc3RlYWQgYSBmYWlsdXJlIHRvIGludm9rZSBhIG5vbi1jaGFpbmFibGVcbiAqIG1ldGhvZCBwcmlvciB0byByZWFkaW5nIHRoZSBub24tZXhpc3RlbnQgcHJvcGVydHkuXG4gKlxuICogSWYgcHJveGllcyBhcmUgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQgdmlhIHRoZSB1c2VyJ3MgQ2hhaSBjb25maWcsIHRoZW5cbiAqIHJldHVybiBvYmplY3Qgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IG5vbkNoYWluYWJsZU1ldGhvZE5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHByb3hpZnlcbiAqL1xuXG52YXIgYnVpbHRpbnMgPSBbJ19fZmxhZ3MnLCAnX19tZXRob2RzJywgJ19vYmonLCAnYXNzZXJ0J107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJveGlmeShvYmosIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1Byb3h5RW5hYmxlZCgpKSByZXR1cm4gb2JqO1xuXG4gIHJldHVybiBuZXcgUHJveHkob2JqLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAvLyBUaGlzIGNoZWNrIGlzIGhlcmUgYmVjYXVzZSB3ZSBzaG91bGQgbm90IHRocm93IGVycm9ycyBvbiBTeW1ib2wgcHJvcGVydGllc1xuICAgICAgLy8gc3VjaCBhcyBgU3ltYm9sLnRvU3RyaW5nVGFnYC5cbiAgICAgIC8vIFRoZSB2YWx1ZXMgZm9yIHdoaWNoIGFuIGVycm9yIHNob3VsZCBiZSB0aHJvd24gY2FuIGJlIGNvbmZpZ3VyZWQgdXNpbmdcbiAgICAgIC8vIHRoZSBgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzYCBzZXR0aW5nLlxuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICBjb25maWcucHJveHlFeGNsdWRlZEtleXMuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xICYmXG4gICAgICAgICAgIVJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHkpKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgbWVzc2FnZSBmb3IgaW52YWxpZCBwcm9wZXJ0eSBhY2Nlc3Mgb2Ygbm9uLWNoYWluYWJsZSBtZXRob2RzLlxuICAgICAgICBpZiAobm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBub25DaGFpbmFibGVNZXRob2ROYW1lICsgJy4nICtcbiAgICAgICAgICAgIHByb3BlcnR5ICsgJy4gU2VlIGRvY3MgZm9yIHByb3BlciB1c2FnZSBvZiBcIicgK1xuICAgICAgICAgICAgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpcyByZWFzb25hYmx5IGNsb3NlIHRvIGFuIGV4aXN0aW5nIENoYWkgcHJvcGVydHksXG4gICAgICAgIC8vIHN1Z2dlc3QgdGhhdCBwcm9wZXJ0eSB0byB0aGUgdXNlci4gT25seSBzdWdnZXN0IHByb3BlcnRpZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpc3RhbmNlIGxlc3MgdGhhbiA0LlxuICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBzdWdnZXN0aW9uRGlzdGFuY2UgPSA0O1xuICAgICAgICBnZXRQcm9wZXJ0aWVzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiZcbiAgICAgICAgICAgIGJ1aWx0aW5zLmluZGV4T2YocHJvcCkgPT09IC0xXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IHN0cmluZ0Rpc3RhbmNlQ2FwcGVkKFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbkRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCBzdWdnZXN0aW9uRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbiA9IHByb3A7XG4gICAgICAgICAgICAgIHN1Z2dlc3Rpb25EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3VnZ2VzdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBwcm9wZXJ0eSArXG4gICAgICAgICAgICAnLiBEaWQgeW91IG1lYW4gXCInICsgc3VnZ2VzdGlvbiArICdcIj8nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBDaGFpIHByb3BlcnR5OiAnICsgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSB0aGlzIHByb3h5IGdldHRlciBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLiBGb3IgcHJvcGVydHlcbiAgICAgIC8vIGFzc2VydGlvbnMsIHRoaXMgcHJldmVudHMgdGhlIHByb3h5IGdldHRlciBmcm9tIHNob3dpbmcgdXAgaW4gdGhlIHN0YWNrXG4gICAgICAvLyB0cmFjZSBzaW5jZSBpdCdzIGludm9rZWQgYmVmb3JlIHRoZSBwcm9wZXJ0eSBnZXR0ZXIuIEZvciBtZXRob2QgYW5kXG4gICAgICAvLyBjaGFpbmFibGUgbWV0aG9kIGFzc2VydGlvbnMsIHRoaXMgZmxhZyB3aWxsIGVuZCB1cCBnZXR0aW5nIGNoYW5nZWQgdG9cbiAgICAgIC8vIHRoZSBtZXRob2Qgd3JhcHBlciwgd2hpY2ggaXMgZ29vZCBzaW5jZSB0aGlzIGZyYW1lIHdpbGwgbm8gbG9uZ2VyIGJlIGluXG4gICAgICAvLyB0aGUgc3RhY2sgb25jZSB0aGUgbWV0aG9kIGlzIGludm9rZWQuIE5vdGUgdGhhdCBDaGFpIGJ1aWx0aW4gYXNzZXJ0aW9uXG4gICAgICAvLyBwcm9wZXJ0aWVzIHN1Y2ggYXMgYF9fZmxhZ3NgIGFyZSBza2lwcGVkIHNpbmNlIHRoaXMgaXMgb25seSBtZWFudCB0b1xuICAgICAgLy8gY2FwdHVyZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYW4gYXNzZXJ0aW9uLiBUaGlzIHN0ZXAgaXMgYWxzbyBza2lwcGVkXG4gICAgICAvLyBpZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGh1cyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhc3NlcnRpb24gaXNcbiAgICAgIC8vIGJlaW5nIGNhbGxlZCBmcm9tIHdpdGhpbiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhhdCBjYXNlLCB0aGUgYHNzZmlgXG4gICAgICAvLyBmbGFnIGlzIGFscmVhZHkgc2V0IHRvIHRoZSBvdXRlciBhc3NlcnRpb24ncyBzdGFydGluZyBwb2ludC5cbiAgICAgIGlmIChidWlsdGlucy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEgJiYgIWZsYWcodGFyZ2V0LCAnbG9ja1NzZmknKSkge1xuICAgICAgICBmbGFnKHRhcmdldCwgJ3NzZmknLCBwcm94eUdldHRlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiAjIHN0cmluZ0Rpc3RhbmNlQ2FwcGVkKHN0ckEsIHN0ckIsIGNhcClcbiAqIFJldHVybiB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gc3RyaW5ncywgYnV0IG5vIG1vcmUgdGhhbiBjYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyQVxuICogQHBhcmFtIHtzdHJpbmd9IHN0ckJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm4ge251bWJlcn0gbWluKHN0cmluZyBkaXN0YW5jZSBiZXR3ZWVuIHN0ckEgYW5kIHN0ckIsIGNhcClcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ0Rpc3RhbmNlQ2FwcGVkKHN0ckEsIHN0ckIsIGNhcCkge1xuICBpZiAoTWF0aC5hYnMoc3RyQS5sZW5ndGggLSBzdHJCLmxlbmd0aCkgPj0gY2FwKSB7XG4gICAgcmV0dXJuIGNhcDtcbiAgfVxuXG4gIHZhciBtZW1vID0gW107XG4gIC8vIGBtZW1vYCBpcyBhIHR3by1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIGRpc3RhbmNlcy5cbiAgLy8gbWVtb1tpXVtqXSBpcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiBzdHJBLnNsaWNlKDAsIGkpIGFuZFxuICAvLyBzdHJCLnNsaWNlKDAsIGopLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBzdHJBLmxlbmd0aDsgaSsrKSB7XG4gICAgbWVtb1tpXSA9IEFycmF5KHN0ckIubGVuZ3RoICsgMSkuZmlsbCgwKTtcbiAgICBtZW1vW2ldWzBdID0gaTtcbiAgfVxuICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ckIubGVuZ3RoOyBqKyspIHtcbiAgICBtZW1vWzBdW2pdID0gajtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0ckEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2ggPSBzdHJBLmNoYXJDb2RlQXQoaSAtIDEpO1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IHN0ckIubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChNYXRoLmFicyhpIC0gaikgPj0gY2FwKSB7XG4gICAgICAgIG1lbW9baV1bal0gPSBjYXA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWVtb1tpXVtqXSA9IE1hdGgubWluKFxuICAgICAgICBtZW1vW2kgLSAxXVtqXSArIDEsXG4gICAgICAgIG1lbW9baV1baiAtIDFdICsgMSxcbiAgICAgICAgbWVtb1tpIC0gMV1baiAtIDFdICtcbiAgICAgICAgICAoY2ggPT09IHN0ckIuY2hhckNvZGVBdChqIC0gMSkgPyAwIDogMSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lbW9bc3RyQS5sZW5ndGhdW3N0ckIubGVuZ3RoXTtcbn1cbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5hZGRNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZE1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgbWV0aG9kV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgbWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXMgZnVuY3Rpb24gdG8gYmUgdGhlXG4gICAgLy8gc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZlxuICAgIC8vIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAvL1xuICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWYgdGhlXG4gICAgLy8gYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgIC8vIG92ZXJ3cml0dGVuIGJ5IGFub3RoZXIgYXNzZXJ0aW9uLCBvciB0aGlzIGFzc2VydGlvbiBpcyBiZWluZyBpbnZva2VkIGZyb21cbiAgICAvLyBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzXG4gICAgLy8gYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kIGNhc2UsIHRoZVxuICAgIC8vIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdXRlciBhc3NlcnRpb24uXG4gICAgaWYgKCFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgbWV0aG9kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH07XG5cbiAgYWRkTGVuZ3RoR3VhcmQobWV0aG9kV3JhcHBlciwgbmFtZSwgZmFsc2UpO1xuICBjdHhbbmFtZV0gPSBwcm94aWZ5KG1ldGhvZFdyYXBwZXIsIG5hbWUpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZVByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAub3ZlcndyaXRlUHJvcGVydHkoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd3JpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZVByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIHZhciBfZ2V0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIG5hbWUpXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAoX2dldCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX2dldC5nZXQpXG4gICAgX3N1cGVyID0gX2dldC5nZXRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyKCkge1xuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcmAgY2F1c2VzIHRoaXNcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXNcbiAgICAgICAgLy8gZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmXG4gICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0IGFuZCBwcm94eSBwcm90ZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWRcbiAgICAgICAgLy8gZnJvbSBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWdcbiAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZFxuICAgICAgICAvLyBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgcHJveHkgcHJvdGVjdGlvbiBpcyBlbmFibGVkLCB0aGVuIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIHNldCBieSB0aGUgcHJveHkgZ2V0dGVyLlxuICAgICAgICBpZiAoIWlzUHJveHlFbmFibGVkKCkgJiYgIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgb3ZlcndyaXRpbmdQcm9wZXJ0eUdldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBgbG9ja1NzZmlgIGZsYWcgdG8gYHRydWVgIHByZXZlbnRzIHRoZSBvdmVyd3JpdHRlblxuICAgICAgICAvLyBhc3NlcnRpb24gZnJvbSBjaGFuZ2luZyB0aGUgYHNzZmlgIGZsYWcuIEJ5IHRoaXMgcG9pbnQsIHRoZSBgc3NmaWBcbiAgICAgICAgLy8gZmxhZyBpcyBhbHJlYWR5IHNldCB0byB0aGUgY29ycmVjdCBzdGFydGluZyBwb2ludCBmb3IgdGhpcyBhc3NlcnRpb24uXG4gICAgICAgIHZhciBvcmlnTG9ja1NzZmkgPSBmbGFnKHRoaXMsICdsb2NrU3NmaScpO1xuICAgICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBvcmlnTG9ja1NzZmkpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBhZGRMZW5ndGhHdWFyZCA9IHJlcXVpcmUoJy4vYWRkTGVuZ3RoR3VhcmQnKTtcbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBwcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAub3ZlcndyaXRlTWV0aG9kKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndyaXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZCBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyBmdW5jdGlvbi4gTXVzdCByZXR1cm4gZnVuY3Rpb25cbiAqIHRvIGJlIHVzZWQgZm9yIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdlcXVhbCcsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoudmFsdWUpLnRvLmVxdWFsKHN0cik7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5lcXVhbCgnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgb3ZlcndyaXRlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb3ZlcndyaXRlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIHZhciBfbWV0aG9kID0gY3R4W25hbWVdXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB9O1xuXG4gIGlmIChfbWV0aG9kICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfbWV0aG9kKVxuICAgIF9zdXBlciA9IF9tZXRob2Q7XG5cbiAgdmFyIG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgb3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyYCBjYXVzZXMgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIHRvIGJlIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb24gZnJhbWVzIGZyb21cbiAgICAvLyB0aGUgc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZiB0aGVcbiAgICAvLyBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gZWl0aGVyIHRoaXMgYXNzZXJ0aW9uIGhhcyBiZWVuXG4gICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWQgZnJvbVxuICAgIC8vIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBgc3NmaWAgZmxhZyBoYXNcbiAgICAvLyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uIEluIHRoZSBzZWNvbmQgY2FzZSwgdGhlXG4gICAgLy8gYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICBpZiAoIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIpO1xuICAgIH1cblxuICAgIC8vIFNldHRpbmcgdGhlIGBsb2NrU3NmaWAgZmxhZyB0byBgdHJ1ZWAgcHJldmVudHMgdGhlIG92ZXJ3cml0dGVuIGFzc2VydGlvblxuICAgIC8vIGZyb20gY2hhbmdpbmcgdGhlIGBzc2ZpYCBmbGFnLiBCeSB0aGlzIHBvaW50LCB0aGUgYHNzZmlgIGZsYWcgaXMgYWxyZWFkeVxuICAgIC8vIHNldCB0byB0aGUgY29ycmVjdCBzdGFydGluZyBwb2ludCBmb3IgdGhpcyBhc3NlcnRpb24uXG4gICAgdmFyIG9yaWdMb2NrU3NmaSA9IGZsYWcodGhpcywgJ2xvY2tTc2ZpJyk7XG4gICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCB0cnVlKTtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9zdXBlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIG9yaWdMb2NrU3NmaSk7XG5cbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9XG5cbiAgYWRkTGVuZ3RoR3VhcmQob3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyLCBuYW1lLCBmYWxzZSk7XG4gIGN0eFtuYW1lXSA9IHByb3hpZnkob3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyLCBuYW1lKTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRDaGFpbmluZ01ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qIVxuICogTW9kdWxlIHZhcmlhYmxlc1xuICovXG5cbi8vIENoZWNrIHdoZXRoZXIgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgaXMgc3VwcG9ydGVkXG52YXIgY2FuU2V0UHJvdG90eXBlID0gdHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gV2l0aG91dCBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBzdXBwb3J0LCB0aGlzIG1vZHVsZSB3aWxsIG5lZWQgdG8gYWRkIHByb3BlcnRpZXMgdG8gYSBmdW5jdGlvbi5cbi8vIEhvd2V2ZXIsIHNvbWUgb2YgZnVuY3Rpb25zJyBvd24gcHJvcHMgYXJlIG5vdCBjb25maWd1cmFibGUgYW5kIHNob3VsZCBiZSBza2lwcGVkLlxudmFyIHRlc3RGbiA9IGZ1bmN0aW9uKCkge307XG52YXIgZXhjbHVkZU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdEZuKS5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRlc3RGbiwgbmFtZSk7XG5cbiAgLy8gTm90ZTogUGhhbnRvbUpTIDEueCBpbmNsdWRlcyBgY2FsbGVlYCBhcyBvbmUgb2YgYHRlc3RGbmAncyBvd24gcHJvcGVydGllcyxcbiAgLy8gYnV0IHRoZW4gcmV0dXJucyBgdW5kZWZpbmVkYCBhcyB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgYGNhbGxlZWAuIEFzIGFcbiAgLy8gd29ya2Fyb3VuZCwgd2UgcGVyZm9ybSBhbiBvdGhlcndpc2UgdW5uZWNlc3NhcnkgdHlwZS1jaGVjayBmb3IgYHByb3BEZXNjYCxcbiAgLy8gYW5kIHRoZW4gZmlsdGVyIGl0IG91dCBpZiBpdCdzIG5vdCBhbiBvYmplY3QgYXMgaXQgc2hvdWxkIGJlLlxuICBpZiAodHlwZW9mIHByb3BEZXNjICE9PSAnb2JqZWN0JylcbiAgICByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gIXByb3BEZXNjLmNvbmZpZ3VyYWJsZTtcbn0pO1xuXG4vLyBDYWNoZSBgRnVuY3Rpb25gIHByb3BlcnRpZXNcbnZhciBjYWxsICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFxuICAgIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vKipcbiAqICMjIyAuYWRkQ2hhaW5hYmxlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gYW4gb2JqZWN0LCBzdWNoIHRoYXQgdGhlIG1ldGhvZCBjYW4gYWxzbyBiZSBjaGFpbmVkLlxuICpcbiAqICAgICB1dGlscy5hZGRDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICpcbiAqIFRoZSByZXN1bHQgY2FuIHRoZW4gYmUgdXNlZCBhcyBib3RoIGEgbWV0aG9kIGFzc2VydGlvbiwgZXhlY3V0aW5nIGJvdGggYG1ldGhvZGAgYW5kXG4gKiBgY2hhaW5pbmdCZWhhdmlvcmAsIG9yIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIHdoaWNoIG9ubHkgZXhlY3V0ZXMgYGNoYWluaW5nQmVoYXZpb3JgLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvby5lcXVhbCgnZm9vJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGBuYW1lYCwgd2hlbiBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgaWYgKHR5cGVvZiBjaGFpbmluZ0JlaGF2aW9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgfVxuXG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IHtcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgLCBjaGFpbmluZ0JlaGF2aW9yOiBjaGFpbmluZ0JlaGF2aW9yXG4gIH07XG5cbiAgLy8gc2F2ZSB0aGUgbWV0aG9kcyBzbyB3ZSBjYW4gb3ZlcndyaXRlIHRoZW0gbGF0ZXIsIGlmIHdlIG5lZWQgdG8uXG4gIGlmICghY3R4Ll9fbWV0aG9kcykge1xuICAgIGN0eC5fX21ldGhvZHMgPSB7fTtcbiAgfVxuICBjdHguX19tZXRob2RzW25hbWVdID0gY2hhaW5hYmxlQmVoYXZpb3I7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gY2hhaW5hYmxlTWV0aG9kR2V0dGVyKCkge1xuICAgICAgICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGNoYWluYWJsZU1ldGhvZFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyB0aGUgYHNzZmlgIGZsYWcgdG8gYGNoYWluYWJsZU1ldGhvZFdyYXBwZXJgIGNhdXNlcyB0aGlzXG4gICAgICAgICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIC8vIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmXG4gICAgICAgICAgLy8gdGhlIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiB0aGlzIGFzc2VydGlvbiBpcyBiZWluZ1xuICAgICAgICAgIC8vIGludm9rZWQgZnJvbSBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoaXMgY2FzZSwgdGhlIGBzc2ZpYFxuICAgICAgICAgIC8vIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE5vdGUgdGhhdCBvdmVyd3JpdGluZyBhIGNoYWluYWJsZSBtZXRob2QgbWVyZWx5IHJlcGxhY2VzIHRoZSBzYXZlZFxuICAgICAgICAgIC8vIG1ldGhvZHMgaW4gYGN0eC5fX21ldGhvZHNgIGluc3RlYWQgb2YgY29tcGxldGVseSByZXBsYWNpbmcgdGhlXG4gICAgICAgICAgLy8gb3ZlcndyaXR0ZW4gYXNzZXJ0aW9uLiBUaGVyZWZvcmUsIGFuIG92ZXJ3cml0aW5nIGFzc2VydGlvbiB3b24ndFxuICAgICAgICAgIC8vIHNldCB0aGUgYHNzZmlgIG9yIGBsb2NrU3NmaWAgZmxhZ3MuXG4gICAgICAgICAgaWYgKCFmbGFnKHRoaXMsICdsb2NrU3NmaScpKSB7XG4gICAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgY2hhaW5hYmxlTWV0aG9kV3JhcHBlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgICAgICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGVuZ3RoR3VhcmQoY2hhaW5hYmxlTWV0aG9kV3JhcHBlciwgbmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVXNlIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoY2FuU2V0UHJvdG90eXBlKSB7XG4gICAgICAgICAgLy8gSW5oZXJpdCBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBvYmplY3QgYnkgcmVwbGFjaW5nIHRoZSBgRnVuY3Rpb25gIHByb3RvdHlwZVxuICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGBjYWxsYCBhbmQgYGFwcGx5YCBtZXRob2RzIGZyb20gYEZ1bmN0aW9uYFxuICAgICAgICAgIHByb3RvdHlwZS5jYWxsID0gY2FsbDtcbiAgICAgICAgICBwcm90b3R5cGUuYXBwbHkgPSBhcHBseTtcbiAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhaW5hYmxlTWV0aG9kV3JhcHBlciwgcHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHJlZGVmaW5lIGFsbCBwcm9wZXJ0aWVzIChzbG93ISlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFzc2VydGVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHgpO1xuICAgICAgICAgIGFzc2VydGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXJ0ZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZU5hbWVzLmluZGV4T2YoYXNzZXJ0ZXJOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgYXNzZXJ0ZXJOYW1lKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGFpbmFibGVNZXRob2RXcmFwcGVyLCBhc3NlcnRlck5hbWUsIHBkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgY2hhaW5hYmxlTWV0aG9kV3JhcHBlcik7XG4gICAgICAgIHJldHVybiBwcm94aWZ5KGNoYWluYWJsZU1ldGhvZFdyYXBwZXIpO1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuICpcbiAqIE92ZXJ3cml0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBjaGFpbmFibGUgbWV0aG9kXG4gKiBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBvclxuICogcHJvcGVydHkuICBNdXN0IHJldHVybiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBmb3JcbiAqIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdsZW5ndGhPZicsXG4gKiAgICAgICBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgKTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIC8gcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCAvIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgcHJvcGVydHlcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSBjdHguX19tZXRob2RzW25hbWVdO1xuXG4gIHZhciBfY2hhaW5pbmdCZWhhdmlvciA9IGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3I7XG4gIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiBvdmVyd3JpdGluZ0NoYWluYWJsZU1ldGhvZEdldHRlcigpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2hhaW5pbmdCZWhhdmlvcihfY2hhaW5pbmdCZWhhdmlvcikuY2FsbCh0aGlzKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBjaGFpLkFzc2VydGlvbigpO1xuICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICB9O1xuXG4gIHZhciBfbWV0aG9kID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kO1xuICBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QgPSBmdW5jdGlvbiBvdmVyd3JpdGluZ0NoYWluYWJsZU1ldGhvZFdyYXBwZXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfbWV0aG9kKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH07XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gY29tcGFyZUJ5SW5zcGVjdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyoqXG4gKiAjIyMgLmNvbXBhcmVCeUluc3BlY3QobWl4ZWQsIG1peGVkKVxuICpcbiAqIFRvIGJlIHVzZWQgYXMgYSBjb21wYXJlRnVuY3Rpb24gd2l0aCBBcnJheS5wcm90b3R5cGUuc29ydC4gQ29tcGFyZXMgZWxlbWVudHNcbiAqIHVzaW5nIGluc3BlY3QgaW5zdGVhZCBvZiBkZWZhdWx0IGJlaGF2aW9yIG9mIHVzaW5nIHRvU3RyaW5nIHNvIHRoYXQgU3ltYm9sc1xuICogYW5kIG9iamVjdHMgd2l0aCBpcnJlZ3VsYXIvbWlzc2luZyB0b1N0cmluZyBjYW4gc3RpbGwgYmUgc29ydGVkIHdpdGhvdXQgYVxuICogVHlwZUVycm9yLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGZpcnN0IGVsZW1lbnQgdG8gY29tcGFyZVxuICogQHBhcmFtIHtNaXhlZH0gc2Vjb25kIGVsZW1lbnQgdG8gY29tcGFyZVxuICogQHJldHVybnMge051bWJlcn0gLTEgaWYgJ2EnIHNob3VsZCBjb21lIGJlZm9yZSAnYic7IG90aGVyd2lzZSAxXG4gKiBAbmFtZSBjb21wYXJlQnlJbnNwZWN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tcGFyZUJ5SW5zcGVjdChhLCBiKSB7XG4gIHJldHVybiBpbnNwZWN0KGEpIDwgaW5zcGVjdChiKSA/IC0xIDogMTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBkaXJlY3RseS1vd25lZCBlbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMgb2YgYW5cbiAqIG9iamVjdC4gVGhpcyBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG4gKiByZXR1cm5zIGJvdGggZW51bWVyYWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyhvYmopIHtcbiAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKS5lbnVtZXJhYmxlO1xuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgPSByZXF1aXJlKCcuL2dldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMnKTtcblxuLyoqXG4gKiAjIyMgLmdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGRpcmVjdGx5LW93bmVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGFuIG9iamVjdC4gVGhpcyBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBPYmplY3Qua2V5cyBvbmx5XG4gKiByZXR1cm5zIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMsIG5vdCBlbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikuY29uY2F0KGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiAhXG4gKiBDaGFpIC0gY2hlY2tFcnJvciB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE2IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmNoZWNrRXJyb3JcbiAqXG4gKiBDaGVja3MgdGhhdCBhbiBlcnJvciBjb25mb3JtcyB0byBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYSBhbmQvb3IgcmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGl0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiAjIyMgLmNvbXBhdGlibGVJbnN0YW5jZSh0aHJvd24sIGVycm9yTGlrZSlcbiAqXG4gKiBDaGVja3MgaWYgdHdvIGluc3RhbmNlcyBhcmUgY29tcGF0aWJsZSAoc3RyaWN0IGVxdWFsKS5cbiAqIFJldHVybnMgZmFsc2UgaWYgZXJyb3JMaWtlIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBFcnJvciwgYmVjYXVzZSBpbnN0YW5jZXNcbiAqIGNhbiBvbmx5IGJlIGNvbXBhdGlibGUgaWYgdGhleSdyZSBib3RoIGVycm9yIGluc3RhbmNlcy5cbiAqXG4gKiBAbmFtZSBjb21wYXRpYmxlSW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IHRocm93biBlcnJvclxuICogQHBhcmFtIHtFcnJvcnxFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2Ugb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjb21wYXRpYmxlSW5zdGFuY2UodGhyb3duLCBlcnJvckxpa2UpIHtcbiAgcmV0dXJuIGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yICYmIHRocm93biA9PT0gZXJyb3JMaWtlO1xufVxuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZUNvbnN0cnVjdG9yKHRocm93biwgZXJyb3JMaWtlKVxuICpcbiAqIENoZWNrcyBpZiB0d28gY29uc3RydWN0b3JzIGFyZSBjb21wYXRpYmxlLlxuICogVGhpcyBmdW5jdGlvbiBjYW4gcmVjZWl2ZSBlaXRoZXIgYW4gZXJyb3IgY29uc3RydWN0b3Igb3JcbiAqIGFuIGVycm9yIGluc3RhbmNlIGFzIHRoZSBgZXJyb3JMaWtlYCBhcmd1bWVudC5cbiAqIENvbnN0cnVjdG9ycyBhcmUgY29tcGF0aWJsZSBpZiB0aGV5J3JlIHRoZSBzYW1lIG9yIGlmIG9uZSBpc1xuICogYW4gaW5zdGFuY2Ugb2YgYW5vdGhlci5cbiAqXG4gKiBAbmFtZSBjb21wYXRpYmxlQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXJyb3J9IHRocm93biBlcnJvclxuICogQHBhcmFtIHtFcnJvcnxFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2Ugb2JqZWN0IHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjb21wYXRpYmxlQ29uc3RydWN0b3IodGhyb3duLCBlcnJvckxpa2UpIHtcbiAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gSWYgYGVycm9yTGlrZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYW55IGVycm9yIHdlIGNvbXBhcmUgdGhlaXIgY29uc3RydWN0b3JzXG4gICAgcmV0dXJuIHRocm93bi5jb25zdHJ1Y3RvciA9PT0gZXJyb3JMaWtlLmNvbnN0cnVjdG9yIHx8IHRocm93biBpbnN0YW5jZW9mIGVycm9yTGlrZS5jb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIGlmIChlcnJvckxpa2UucHJvdG90eXBlIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3JMaWtlID09PSBFcnJvcikge1xuICAgIC8vIElmIGBlcnJvckxpa2VgIGlzIGEgY29uc3RydWN0b3IgdGhhdCBpbmhlcml0cyBmcm9tIEVycm9yLCB3ZSBjb21wYXJlIGB0aHJvd25gIHRvIGBlcnJvckxpa2VgIGRpcmVjdGx5XG4gICAgcmV0dXJuIHRocm93bi5jb25zdHJ1Y3RvciA9PT0gZXJyb3JMaWtlIHx8IHRocm93biBpbnN0YW5jZW9mIGVycm9yTGlrZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiAjIyMgLmNvbXBhdGlibGVNZXNzYWdlKHRocm93biwgZXJyTWF0Y2hlcilcbiAqXG4gKiBDaGVja3MgaWYgYW4gZXJyb3IncyBtZXNzYWdlIGlzIGNvbXBhdGlibGUgd2l0aCBhIG1hdGNoZXIgKFN0cmluZyBvciBSZWdFeHApLlxuICogSWYgdGhlIG1lc3NhZ2UgY29udGFpbnMgdGhlIFN0cmluZyBvciBwYXNzZXMgdGhlIFJlZ0V4cCB0ZXN0LFxuICogaXQgaXMgY29uc2lkZXJlZCBjb21wYXRpYmxlLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVNZXNzYWdlXG4gKiBAcGFyYW0ge0Vycm9yfSB0aHJvd24gZXJyb3JcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXJyTWF0Y2hlciB0byBsb29rIGZvciBpbnRvIHRoZSBtZXNzYWdlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVNZXNzYWdlKHRocm93biwgZXJyTWF0Y2hlcikge1xuICB2YXIgY29tcGFyaXNvblN0cmluZyA9IHR5cGVvZiB0aHJvd24gPT09ICdzdHJpbmcnID8gdGhyb3duIDogdGhyb3duLm1lc3NhZ2U7XG4gIGlmIChlcnJNYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIGVyck1hdGNoZXIudGVzdChjb21wYXJpc29uU3RyaW5nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyTWF0Y2hlciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29tcGFyaXNvblN0cmluZy5pbmRleE9mKGVyck1hdGNoZXIpICE9PSAtMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogIyMjIC5nZXRGdW5jdGlvbk5hbWUoY29uc3RydWN0b3JGbilcbiAqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24uXG4gKiBUaGlzIGFsc28gaW5jbHVkZXMgYSBwb2x5ZmlsbCBmdW5jdGlvbiBpZiBgY29uc3RydWN0b3JGbi5uYW1lYCBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAbmFtZSBnZXRGdW5jdGlvbk5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yRm5cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBmdW5jdGlvbk5hbWVNYXRjaCA9IC9cXHMqZnVuY3Rpb24oPzpcXHN8XFxzKlxcL1xcKlteKD86KlxcLyldK1xcKlxcL1xccyopKihbXlxcKFxcL10rKS87XG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoY29uc3RydWN0b3JGbikge1xuICB2YXIgbmFtZSA9ICcnO1xuICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yRm4ubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBIZXJlIHdlIHJ1biBhIHBvbHlmaWxsIGlmIGNvbnN0cnVjdG9yRm4ubmFtZSBpcyBub3QgZGVmaW5lZFxuICAgIHZhciBtYXRjaCA9IFN0cmluZyhjb25zdHJ1Y3RvckZuKS5tYXRjaChmdW5jdGlvbk5hbWVNYXRjaCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBjb25zdHJ1Y3RvckZuLm5hbWU7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn1cblxuLyoqXG4gKiAjIyMgLmdldENvbnN0cnVjdG9yTmFtZShlcnJvckxpa2UpXG4gKlxuICogR2V0cyB0aGUgY29uc3RydWN0b3IgbmFtZSBmb3IgYW4gRXJyb3IgaW5zdGFuY2Ugb3IgY29uc3RydWN0b3IgaXRzZWxmLlxuICpcbiAqIEBuYW1lIGdldENvbnN0cnVjdG9yTmFtZVxuICogQHBhcmFtIHtFcnJvcnxFcnJvckNvbnN0cnVjdG9yfSBlcnJvckxpa2VcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSkge1xuICB2YXIgY29uc3RydWN0b3JOYW1lID0gZXJyb3JMaWtlO1xuICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRGdW5jdGlvbk5hbWUoZXJyb3JMaWtlLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JMaWtlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYgYGVycmAgaXMgbm90IGFuIGluc3RhbmNlIG9mIEVycm9yIGl0IGlzIGFuIGVycm9yIGNvbnN0cnVjdG9yIGl0c2VsZiBvciBhbm90aGVyIGZ1bmN0aW9uLlxuICAgIC8vIElmIHdlJ3ZlIGdvdCBhIGNvbW1vbiBmdW5jdGlvbiB3ZSBnZXQgaXRzIG5hbWUsIG90aGVyd2lzZSB3ZSBtYXkgbmVlZCB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2VcbiAgICAvLyBvZiB0aGUgZXJyb3IganVzdCBpbiBjYXNlIGl0J3MgYSBwb29ybHktY29uc3RydWN0ZWQgZXJyb3IuIFBsZWFzZSBzZWUgY2hhaWpzL2NoYWkvaXNzdWVzLzQ1IHRvIGtub3cgbW9yZS5cbiAgICBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRGdW5jdGlvbk5hbWUoZXJyb3JMaWtlKS50cmltKCkgfHxcbiAgICAgICAgZ2V0RnVuY3Rpb25OYW1lKG5ldyBlcnJvckxpa2UoKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICB9XG5cbiAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbn1cblxuLyoqXG4gKiAjIyMgLmdldE1lc3NhZ2UoZXJyb3JMaWtlKVxuICpcbiAqIEdldHMgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSBhbiBlcnJvci5cbiAqIElmIGBlcnJgIGlzIGEgU3RyaW5nIGl0c2VsZiwgd2UgcmV0dXJuIGl0LlxuICogSWYgdGhlIGVycm9yIGhhcyBubyBtZXNzYWdlLCB3ZSByZXR1cm4gYW4gZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBuYW1lIGdldE1lc3NhZ2VcbiAqIEBwYXJhbSB7RXJyb3J8U3RyaW5nfSBlcnJvckxpa2VcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShlcnJvckxpa2UpIHtcbiAgdmFyIG1zZyA9ICcnO1xuICBpZiAoZXJyb3JMaWtlICYmIGVycm9yTGlrZS5tZXNzYWdlKSB7XG4gICAgbXNnID0gZXJyb3JMaWtlLm1lc3NhZ2U7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtc2cgPSBlcnJvckxpa2U7XG4gIH1cblxuICByZXR1cm4gbXNnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGF0aWJsZUluc3RhbmNlOiBjb21wYXRpYmxlSW5zdGFuY2UsXG4gIGNvbXBhdGlibGVDb25zdHJ1Y3RvcjogY29tcGF0aWJsZUNvbnN0cnVjdG9yLFxuICBjb21wYXRpYmxlTWVzc2FnZTogY29tcGF0aWJsZU1lc3NhZ2UsXG4gIGdldE1lc3NhZ2U6IGdldE1lc3NhZ2UsXG4gIGdldENvbnN0cnVjdG9yTmFtZTogZ2V0Q29uc3RydWN0b3JOYW1lLFxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGlzTmFOIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTUgU2FrdGhpcHJpeWFuIFZhaXJhbWFuaSA8dGhlY2hhcmdpbmd2b2xjYW5vQGdtYWlsLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5pc05hTih2YWx1ZSlcbiAqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIE5hTiBvciBub3QuXG4gKlxuICogICAgIHV0aWxzLmlzTmFOKE5hTik7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge1ZhbHVlfSBUaGUgdmFsdWUgd2hpY2ggaGFzIHRvIGJlIGNoZWNrZWQgaWYgaXQgaXMgTmFOXG4gKiBAbmFtZSBpc05hTlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgLy8gUmVmZXIgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWlzbmFuLW51bWJlclxuICAvLyBzZWN0aW9uJ3MgTk9URS5cbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuLy8gSWYgRUNNQVNjcmlwdCA2J3MgTnVtYmVyLmlzTmFOIGlzIHByZXNlbnQsIHByZWZlciB0aGF0LlxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNOYU4gfHwgaXNOYU47XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBEZXBlbmRlbmNpZXMgdGhhdCBhcmUgdXNlZCBmb3IgbXVsdGlwbGUgZXhwb3J0cyBhcmUgcmVxdWlyZWQgaGVyZSBvbmx5IG9uY2VcbiAqL1xuXG52YXIgcGF0aHZhbCA9IHJlcXVpcmUoJ3BhdGh2YWwnKTtcblxuLyohXG4gKiB0ZXN0IHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxuLyohXG4gKiB0eXBlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG4vKiFcbiAqIGV4cGVjdFR5cGVzIHV0aWxpdHlcbiAqL1xuZXhwb3J0cy5leHBlY3RUeXBlcyA9IHJlcXVpcmUoJy4vZXhwZWN0VHlwZXMnKTtcblxuLyohXG4gKiBtZXNzYWdlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldE1lc3NhZ2UgPSByZXF1aXJlKCcuL2dldE1lc3NhZ2UnKTtcblxuLyohXG4gKiBhY3R1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKTtcblxuLyohXG4gKiBJbnNwZWN0IHV0aWxcbiAqL1xuXG5leHBvcnRzLmluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyohXG4gKiBPYmplY3QgRGlzcGxheSB1dGlsXG4gKi9cblxuZXhwb3J0cy5vYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qIVxuICogRmxhZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5mbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qIVxuICogRmxhZyB0cmFuc2ZlcnJpbmcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIERlZXAgZXF1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZXFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKTtcblxuLyohXG4gKiBEZWVwIHBhdGggaW5mb1xuICovXG5cbmV4cG9ydHMuZ2V0UGF0aEluZm8gPSBwYXRodmFsLmdldFBhdGhJbmZvO1xuXG4vKiFcbiAqIENoZWNrIGlmIGEgcHJvcGVydHkgZXhpc3RzXG4gKi9cblxuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IHBhdGh2YWwuaGFzUHJvcGVydHk7XG5cbi8qIVxuICogRnVuY3Rpb24gbmFtZVxuICovXG5cbmV4cG9ydHMuZ2V0TmFtZSA9IHJlcXVpcmUoJ2dldC1mdW5jLW5hbWUnKTtcblxuLyohXG4gKiBhZGQgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLmFkZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9hZGRQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIGFkZCBNZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZE1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkTWV0aG9kJyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlUHJvcGVydHknKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1ldGhvZCcpO1xuXG4vKiFcbiAqIEFkZCBhIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZENoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbi8qIVxuICogT3ZlcndyaXRlIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbi8qIVxuICogQ29tcGFyZSBieSBpbnNwZWN0IG1ldGhvZFxuICovXG5cbmV4cG9ydHMuY29tcGFyZUJ5SW5zcGVjdCA9IHJlcXVpcmUoJy4vY29tcGFyZUJ5SW5zcGVjdCcpO1xuXG4vKiFcbiAqIEdldCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyA9IHJlcXVpcmUoJy4vZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scycpO1xuXG4vKiFcbiAqIEdldCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG5cbi8qIVxuICogQ2hlY2tzIGVycm9yIGFnYWluc3QgYSBnaXZlbiBzZXQgb2YgY3JpdGVyaWFcbiAqL1xuXG5leHBvcnRzLmNoZWNrRXJyb3IgPSByZXF1aXJlKCdjaGVjay1lcnJvcicpO1xuXG4vKiFcbiAqIFByb3hpZnkgdXRpbFxuICovXG5cbmV4cG9ydHMucHJveGlmeSA9IHJlcXVpcmUoJy4vcHJveGlmeScpO1xuXG4vKiFcbiAqIGFkZExlbmd0aEd1YXJkIHV0aWxcbiAqL1xuXG5leHBvcnRzLmFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xuXG4vKiFcbiAqIGlzUHJveHlFbmFibGVkIGhlbHBlclxuICovXG5cbmV4cG9ydHMuaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG5cbi8qIVxuICogaXNOYU4gbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5pc05hTiA9IHJlcXVpcmUoJy4vaXNOYU4nKTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2NoYWksIHV0aWwpIHtcbiAgLyohXG4gICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb25FcnJvciA9IF9jaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICBfY2hhaS5Bc3NlcnRpb24gPSBBc3NlcnRpb247XG5cbiAgLyohXG4gICAqIEFzc2VydGlvbiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBDcmVhdGVzIG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIGBBc3NlcnRpb25gIG9iamVjdHMgY29udGFpbiBtZXRhZGF0YSBpbiB0aGUgZm9ybSBvZiBmbGFncy4gVGhyZWUgZmxhZ3MgY2FuXG4gICAqIGJlIGFzc2lnbmVkIGR1cmluZyBpbnN0YW50aWF0aW9uIGJ5IHBhc3NpbmcgYXJndW1lbnRzIHRvIHRoaXMgY29uc3RydWN0b3I6XG4gICAqXG4gICAqIC0gYG9iamVjdGA6IFRoaXMgZmxhZyBjb250YWlucyB0aGUgdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb24uIEZvciBleGFtcGxlLCBpblxuICAgKiAgIHRoZSBhc3NlcnRpb24gYGV4cGVjdChudW1LaXR0ZW5zKS50by5lcXVhbCg3KTtgLCB0aGUgYG9iamVjdGAgZmxhZyB3aWxsXG4gICAqICAgY29udGFpbiBgbnVtS2l0dGVuc2Agc28gdGhhdCB0aGUgYGVxdWFsYCBhc3NlcnRpb24gY2FuIHJlZmVyZW5jZSBpdCB3aGVuXG4gICAqICAgbmVlZGVkLlxuICAgKlxuICAgKiAtIGBtZXNzYWdlYDogVGhpcyBmbGFnIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvIGJlXG4gICAqICAgcHJlcGVuZGVkIHRvIHRoZSBlcnJvciBtZXNzYWdlIHRoYXQncyBnZW5lcmF0ZWQgYnkgdGhlIGFzc2VydGlvbiB3aGVuIGl0XG4gICAqICAgZmFpbHMuXG4gICAqXG4gICAqIC0gYHNzZmlgOiBUaGlzIGZsYWcgc3RhbmRzIGZvciBcInN0YXJ0IHN0YWNrIGZ1bmN0aW9uIGluZGljYXRvclwiLiBJdFxuICAgKiAgIGNvbnRhaW5zIGEgZnVuY3Rpb24gcmVmZXJlbmNlIHRoYXQgc2VydmVzIGFzIHRoZSBzdGFydGluZyBwb2ludCBmb3JcbiAgICogICByZW1vdmluZyBmcmFtZXMgZnJvbSB0aGUgc3RhY2sgdHJhY2Ugb2YgdGhlIGVycm9yIHRoYXQncyBjcmVhdGVkIGJ5IHRoZVxuICAgKiAgIGFzc2VydGlvbiB3aGVuIGl0IGZhaWxzLiBUaGUgZ29hbCBpcyB0byBwcm92aWRlIGEgY2xlYW5lciBzdGFjayB0cmFjZSB0b1xuICAgKiAgIGVuZCB1c2VycyBieSByZW1vdmluZyBDaGFpJ3MgaW50ZXJuYWwgZnVuY3Rpb25zLiBOb3RlIHRoYXQgaXQgb25seSB3b3Jrc1xuICAgKiAgIGluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgYEVycm9yLmNhcHR1cmVTdGFja1RyYWNlYCwgYW5kIG9ubHkgd2hlblxuICAgKiAgIGBDaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2tgIGhhc24ndCBiZWVuIHNldCB0byBgZmFsc2VgLlxuICAgKlxuICAgKiAtIGBsb2NrU3NmaWA6IFRoaXMgZmxhZyBjb250cm9scyB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHNzZmlgIGZsYWdcbiAgICogICBzaG91bGQgcmV0YWluIGl0cyBjdXJyZW50IHZhbHVlLCBldmVuIGFzIGFzc2VydGlvbnMgYXJlIGNoYWluZWQgb2ZmIG9mXG4gICAqICAgdGhpcyBvYmplY3QuIFRoaXMgaXMgdXN1YWxseSBzZXQgdG8gYHRydWVgIHdoZW4gY3JlYXRpbmcgYSBuZXcgYXNzZXJ0aW9uXG4gICAqICAgZnJvbSB3aXRoaW4gYW5vdGhlciBhc3NlcnRpb24uIEl0J3MgYWxzbyB0ZW1wb3JhcmlseSBzZXQgdG8gYHRydWVgIGJlZm9yZVxuICAgKiAgIGFuIG92ZXJ3cml0dGVuIGFzc2VydGlvbiBnZXRzIGNhbGxlZCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBvYmogdGFyZ2V0IG9mIHRoZSBhc3NlcnRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAob3B0aW9uYWwpIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNzZmkgKG9wdGlvbmFsKSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3Zpbmcgc3RhY2sgZnJhbWVzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9ja1NzZmkgKG9wdGlvbmFsKSB3aGV0aGVyIG9yIG5vdCB0aGUgc3NmaSBmbGFnIGlzIGxvY2tlZFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uIChvYmosIG1zZywgc3NmaSwgbG9ja1NzZmkpIHtcbiAgICBmbGFnKHRoaXMsICdzc2ZpJywgc3NmaSB8fCBBc3NlcnRpb24pO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgbG9ja1NzZmkpO1xuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIG9iaik7XG4gICAgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICByZXR1cm4gdXRpbC5wcm94aWZ5KHRoaXMpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ2luY2x1ZGVTdGFjaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuaW5jbHVkZVN0YWNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5pbmNsdWRlU3RhY2sgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdzaG93RGlmZicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLnNob3dEaWZmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuc2hvd0RpZmYgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5hZGRDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UsIGV4cGVjdGVkLCBhY3R1YWwsIHNob3dEaWZmKVxuICAgKlxuICAgKiBFeGVjdXRlcyBhbiBleHByZXNzaW9uIGFuZCBjaGVjayBleHBlY3RhdGlvbnMuIFRocm93cyBBc3NlcnRpb25FcnJvciBmb3IgcmVwb3J0aW5nIGlmIHRlc3QgZG9lc24ndCBwYXNzLlxuICAgKlxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQHBhcmFtIHtQaGlsb3NvcGhpY2FsfSBleHByZXNzaW9uIHRvIGJlIHRlc3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbWVzc2FnZSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbWVzc2FnZSB0byBkaXNwbGF5IGlmIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG5lZ2F0ZWRNZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBuZWdhdGVkTWVzc2FnZSB0byBkaXNwbGF5IGlmIG5lZ2F0ZWQgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZCB2YWx1ZSAocmVtZW1iZXIgdG8gY2hlY2sgZm9yIG5lZ2F0aW9uKVxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWwgKG9wdGlvbmFsKSB3aWxsIGRlZmF1bHQgdG8gYHRoaXMub2JqYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dEaWZmIChvcHRpb25hbCkgd2hlbiBzZXQgdG8gYHRydWVgLCBhc3NlcnQgd2lsbCBkaXNwbGF5IGEgZGlmZiBpbiBhZGRpdGlvbiB0byB0aGUgbWVzc2FnZSBpZiBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBBc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uIChleHByLCBtc2csIG5lZ2F0ZU1zZywgZXhwZWN0ZWQsIF9hY3R1YWwsIHNob3dEaWZmKSB7XG4gICAgdmFyIG9rID0gdXRpbC50ZXN0KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGZhbHNlICE9PSBzaG93RGlmZikgc2hvd0RpZmYgPSB0cnVlO1xuICAgIGlmICh1bmRlZmluZWQgPT09IGV4cGVjdGVkICYmIHVuZGVmaW5lZCA9PT0gX2FjdHVhbCkgc2hvd0RpZmYgPSBmYWxzZTtcbiAgICBpZiAodHJ1ZSAhPT0gY29uZmlnLnNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvaykge1xuICAgICAgbXNnID0gdXRpbC5nZXRNZXNzYWdlKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYWN0dWFsID0gdXRpbC5nZXRBY3R1YWwodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2csIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIHNob3dEaWZmOiBzaG93RGlmZlxuICAgICAgfSwgKGNvbmZpZy5pbmNsdWRlU3RhY2spID8gdGhpcy5hc3NlcnQgOiBmbGFnKHRoaXMsICdzc2ZpJykpO1xuICAgIH1cbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5fb2JqXG4gICAqXG4gICAqIFF1aWNrIHJlZmVyZW5jZSB0byBzdG9yZWQgYGFjdHVhbGAgdmFsdWUgZm9yIHBsdWdpbiBkZXZlbG9wZXJzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsICdfb2JqJyxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgLCBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsKTtcbiAgICAgIH1cbiAgfSk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIF8pIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCBBc3NlcnRpb25FcnJvciA9IGNoYWkuQXNzZXJ0aW9uRXJyb3JcbiAgICAsIGZsYWcgPSBfLmZsYWc7XG5cbiAgLyoqXG4gICAqICMjIyBMYW5ndWFnZSBDaGFpbnNcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgcHJvdmlkZWQgYXMgY2hhaW5hYmxlIGdldHRlcnMgdG8gaW1wcm92ZSB0aGUgcmVhZGFiaWxpdHlcbiAgICogb2YgeW91ciBhc3NlcnRpb25zLlxuICAgKlxuICAgKiAqKkNoYWlucyoqXG4gICAqXG4gICAqIC0gdG9cbiAgICogLSBiZVxuICAgKiAtIGJlZW5cbiAgICogLSBpc1xuICAgKiAtIHRoYXRcbiAgICogLSB3aGljaFxuICAgKiAtIGFuZFxuICAgKiAtIGhhc1xuICAgKiAtIGhhdmVcbiAgICogLSB3aXRoXG4gICAqIC0gYXRcbiAgICogLSBvZlxuICAgKiAtIHNhbWVcbiAgICogLSBidXRcbiAgICogLSBkb2VzXG4gICAqIC0gc3RpbGxcbiAgICpcbiAgICogQG5hbWUgbGFuZ3VhZ2UgY2hhaW5zXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFsgJ3RvJywgJ2JlJywgJ2JlZW4nLCAnaXMnXG4gICwgJ2FuZCcsICdoYXMnLCAnaGF2ZScsICd3aXRoJ1xuICAsICd0aGF0JywgJ3doaWNoJywgJ2F0JywgJ29mJ1xuICAsICdzYW1lJywgJ2J1dCcsICdkb2VzJywgJ3N0aWxsJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYWxsIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZ1bmN0aW9uICgpIHt9KS50by5ub3QudGhyb3coKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5iZS5hbignYXJyYXknKS50aGF0LmRvZXMubm90LmluY2x1ZGUoMyk7XG4gICAqXG4gICAqIEp1c3QgYmVjYXVzZSB5b3UgY2FuIG5lZ2F0ZSBhbnkgYXNzZXJ0aW9uIHdpdGggYC5ub3RgIGRvZXNuJ3QgbWVhbiB5b3VcbiAgICogc2hvdWxkLiBXaXRoIGdyZWF0IHBvd2VyIGNvbWVzIGdyZWF0IHJlc3BvbnNpYmlsaXR5LiBJdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgdGhlIG9uZSBleHBlY3RlZCBvdXRwdXQgd2FzIHByb2R1Y2VkLCByYXRoZXIgdGhhbiBhc3NlcnRpbmdcbiAgICogdGhhdCBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgb3V0cHV0cyB3YXNuJ3QgcHJvZHVjZWQuIFNlZSBpbmRpdmlkdWFsXG4gICAqIGFzc2VydGlvbnMgZm9yIHNwZWNpZmljIGd1aWRhbmNlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5lcXVhbCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAuZXF1YWxgLCBgLmluY2x1ZGVgLCBgLm1lbWJlcnNgLCBgLmtleXNgLCBhbmQgYC5wcm9wZXJ0eWBcbiAgICogYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZCBvZiBzdHJpY3RcbiAgICogKGA9PT1gKSBlcXVhbGl0eS4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcFxuICAgKiBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWxzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5kZWVwLmVxdWFsKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmRlZXAuaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaW5jbHVkZSh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmRlZXAuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBtZW1iZXIgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uaGF2ZS5kZWVwLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaGF2ZS5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBzZXQgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMga2V5IGB7YTogMX1gXG4gICAqICAgICBleHBlY3QobmV3IFNldChbe2E6IDF9XSkpLnRvLmhhdmUuZGVlcC5rZXlzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8ubm90LmhhdmUua2V5cyhbe2E6IDF9XSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIHByb3BlcnR5IGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRcbiAgICpcbiAgICogRW5hYmxlcyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGluIGFsbCBgLnByb3BlcnR5YCBhbmQgYC5pbmNsdWRlYFxuICAgKiBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ2EuYlsxXScpO1xuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5uZXN0ZWQuaW5jbHVkZSh7J2EuYlsxXSc6ICd5J30pO1xuICAgKlxuICAgKiBJZiBgLmAgb3IgYFtdYCBhcmUgcGFydCBvZiBhbiBhY3R1YWwgcHJvcGVydHkgbmFtZSwgdGhleSBjYW4gYmUgZXNjYXBlZCBieVxuICAgKiBhZGRpbmcgdHdvIGJhY2tzbGFzaGVzIGJlZm9yZSB0aGVtLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsnLmEnOiB7J1tiXSc6ICd4J319KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnXFxcXC5hLlxcXFxbYlxcXFxdJyk7XG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogJ3gnfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnXFxcXC5hLlxcXFxbYlxcXFxdJzogJ3gnfSk7XG4gICAqXG4gICAqIGAubmVzdGVkYCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBgLm93bmAuXG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25lc3RlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZXN0ZWQnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3duXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5wcm9wZXJ0eWAgYW5kIGAuaW5jbHVkZWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW5cbiAgICogdG8gaWdub3JlIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duLnByb3BlcnR5KCdhJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm93bi5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlKHtiOiAyfSkuYnV0Lm5vdC5vd24uaW5jbHVkZSh7YjogMn0pO1xuICAgKlxuICAgKiBgLm93bmAgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggYC5uZXN0ZWRgLlxuICAgKlxuICAgKiBAbmFtZSBvd25cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnb3duJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9yZGVyZWRcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLm1lbWJlcnNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdFxuICAgKiBtZW1iZXJzIGJlIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uaGF2ZS5vcmRlcmVkLm1lbWJlcnMoWzEsIDJdKVxuICAgKiAgICAgICAuYnV0Lm5vdC5oYXZlLm9yZGVyZWQubWVtYmVycyhbMiwgMV0pO1xuICAgKlxuICAgKiBXaGVuIGAuaW5jbHVkZWAgYW5kIGAub3JkZXJlZGAgYXJlIGNvbWJpbmVkLCB0aGUgb3JkZXJpbmcgYmVnaW5zIGF0IHRoZVxuICAgKiBzdGFydCBvZiBib3RoIGFycmF5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKFsxLCAyXSlcbiAgICogICAgICAgLmJ1dC5ub3QuaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoWzIsIDNdKTtcbiAgICpcbiAgICogQG5hbWUgb3JkZXJlZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29yZGVyZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnb3JkZXJlZCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbnlcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIG9ubHkgcmVxdWlyZSB0aGF0XG4gICAqIHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGtleXMuIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mXG4gICAqIGAuYWxsYCwgd2hpY2ggcmVxdWlyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiBTZWUgdGhlIGAua2V5c2AgZG9jIGZvciBndWlkYW5jZSBvbiB3aGVuIHRvIHVzZSBgLmFueWAgb3IgYC5hbGxgLlxuICAgKlxuICAgKiBAbmFtZSBhbnlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbnknLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hbGxcbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGhhdmUgYWxsIG9mIHRoZSBnaXZlbiBrZXlzLiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBgLmFueWAsIHdoaWNoXG4gICAqIG9ubHkgcmVxdWlyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBgLmFsbGAgaXMgdXNlZCBieSBkZWZhdWx0IHdoZW4gbmVpdGhlciBgLmFsbGAgbm9yIGAuYW55YCBhcmVcbiAgICogYWRkZWQgZWFybGllciBpbiB0aGUgY2hhaW4uIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbGxgIGFueXdheVxuICAgKiBiZWNhdXNlIGl0IGltcHJvdmVzIHJlYWRhYmlsaXR5LlxuICAgKlxuICAgKiBTZWUgdGhlIGAua2V5c2AgZG9jIGZvciBndWlkYW5jZSBvbiB3aGVuIHRvIHVzZSBgLmFueWAgb3IgYC5hbGxgLlxuICAgKlxuICAgKiBAbmFtZSBhbGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdhbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnYWxsJywgdHJ1ZSk7XG4gICAgZmxhZyh0aGlzLCAnYW55JywgZmFsc2UpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGVbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIHR5cGUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHN0cmluZyBgdHlwZWAuIFR5cGVzXG4gICAqIGFyZSBjYXNlIGluc2Vuc2l0aXZlLiBTZWUgdGhlIGB0eXBlLWRldGVjdGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZVxuICAgKiB0eXBlIGRldGVjdGlvbiBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvdHlwZS1kZXRlY3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRXJyb3IpLnRvLmJlLmFuKCdlcnJvcicpO1xuICAgKiAgICAgZXhwZWN0KFByb21pc2UucmVzb2x2ZSgpKS50by5iZS5hKCdwcm9taXNlJyk7XG4gICAqICAgICBleHBlY3QobmV3IEZsb2F0MzJBcnJheSkudG8uYmUuYSgnZmxvYXQzMmFycmF5Jyk7XG4gICAqICAgICBleHBlY3QoU3ltYm9sKCkpLnRvLmJlLmEoJ3N5bWJvbCcpO1xuICAgKlxuICAgKiBgLmFgIHN1cHBvcnRzIG9iamVjdHMgdGhhdCBoYXZlIGEgY3VzdG9tIHR5cGUgc2V0IHZpYSBgU3ltYm9sLnRvU3RyaW5nVGFnYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtcbiAgICogICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdteUN1c3RvbVR5cGUnXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5iZS5hKCdteUN1c3RvbVR5cGUnKS5idXQubm90LmFuKCdvYmplY3QnKTtcbiAgICpcbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIHVzZSBgLmFgIHRvIGNoZWNrIGEgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgbWFraW5nIG1vcmVcbiAgICogYXNzZXJ0aW9ucyBvbiB0aGUgc2FtZSB0YXJnZXQuIFRoYXQgd2F5LCB5b3UgYXZvaWQgdW5leHBlY3RlZCBiZWhhdmlvciBmcm9tXG4gICAqIGFueSBhc3NlcnRpb24gdGhhdCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5iZS5hbignYXJyYXknKS50aGF0LmluY2x1ZGVzKDIpO1xuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5hbignYXJyYXknKS50aGF0LmlzLmVtcHR5O1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyB0aGUgZXhwZWN0ZWQgdHlwZSwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXRcbiAgICogaXNuJ3Qgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB0eXBlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5hbignYXJyYXknKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlIHRvXG4gICAqIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmEoJ3N0cmluZycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqXG4gICAqIGAuYWAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluIHRvIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mXG4gICAqIHlvdXIgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLmhhdmUuYS5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5hbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5hYC5cbiAgICpcbiAgICogQG5hbWUgYVxuICAgKiBAYWxpYXMgYW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFuICh0eXBlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBhcnRpY2xlID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHR5cGUuY2hhckF0KDApKSA/ICdhbiAnIDogJ2EgJztcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlID09PSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsWywgbXNnXSlcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgc3RyaW5nLCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gc3RyaW5nIGB2YWxgXG4gICAqIGlzIGEgc3Vic3RyaW5nIG9mIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmluY2x1ZGUoJ2ZvbycpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYW4gYXJyYXksIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBhXG4gICAqIG1lbWJlciBvZiB0aGUgdGFyZ2V0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZSgyKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIG9iamVjdFxuICAgKiBgdmFsYCdzIHByb3BlcnRpZXMgYXJlIGEgc3Vic2V0IG9mIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZSh7YTogMSwgYjogMn0pO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBTZXQgb3IgV2Vha1NldCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGB2YWxgIGlzIGFcbiAgICogbWVtYmVyIG9mIHRoZSB0YXJnZXQuIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtIGlzIHVzZWQuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMl0pKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBNYXAsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBgdmFsYCBpcyBvbmUgb2ZcbiAgICogdGhlIHZhbHVlcyBvZiB0aGUgdGFyZ2V0LiBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBNYXAoW1snYScsIDFdLCBbJ2InLCAyXV0pKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBCZWNhdXNlIGAuaW5jbHVkZWAgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLCBpdCdzXG4gICAqIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgdXNpbmcgYC5pbmNsdWRlYC4gU2VlIHRoZSBgLmFgXG4gICAqIGRvYyBmb3IgaW5mbyBvbiB0ZXN0aW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaW5jbHVkZXMoMik7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBhcnJheSBtZW1iZXJzIGFuZFxuICAgKiBvYmplY3QgcHJvcGVydGllcy4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHlcbiAgICogaW5zdGVhZCAoV2Vha1NldCB0YXJnZXRzIGFyZSBub3Qgc3VwcG9ydGVkKS4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3RcbiAgICogcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5kZWVwLmluY2x1ZGUoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmluY2x1ZGUoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBpbmNsdWRlcyBgeDoge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5kZWVwLmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKiAgICAgZXhwZWN0KHt4OiB7YTogMX19KS50by5ub3QuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGFsbCBvZiB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmUgc2VhcmNoZWQgd2hlbiB3b3JraW5nIHdpdGhcbiAgICogb2JqZWN0cy4gVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluaGVyaXRlZCBhbmQvb3Igbm9uLWVudW1lcmFibGUuXG4gICAqIEFkZCBgLm93bmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZXhjbHVkZSB0aGUgdGFyZ2V0J3MgaW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgZnJvbSB0aGUgc2VhcmNoLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm93bi5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlKHtiOiAyfSkuYnV0Lm5vdC5vd24uaW5jbHVkZSh7YjogMn0pO1xuICAgKlxuICAgKiBOb3RlIHRoYXQgYSB0YXJnZXQgb2JqZWN0IGlzIGFsd2F5cyBvbmx5IHNlYXJjaGVkIGZvciBgdmFsYCdzIG93blxuICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAub3duYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiAyfX0pLnRvLmRlZXAub3duLmluY2x1ZGUoe2E6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBBZGQgYC5uZXN0ZWRgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGVuYWJsZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIHdoZW5cbiAgICogcmVmZXJlbmNpbmcgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzFdJzogJ3knfSk7XG4gICAqXG4gICAqIElmIGAuYCBvciBgW11gIGFyZSBwYXJ0IG9mIGFuIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLCB0aGV5IGNhbiBiZSBlc2NhcGVkIGJ5XG4gICAqIGFkZGluZyB0d28gYmFja3NsYXNoZXMgYmVmb3JlIHRoZW0uXG4gICAqXG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogMn19KS50by5uZXN0ZWQuaW5jbHVkZSh7J1xcXFwuYS5cXFxcW2JcXFxcXSc6IDJ9KTtcbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5uZXN0ZWRgIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFt7YzogM31dfX0pLnRvLmRlZXAubmVzdGVkLmluY2x1ZGUoeydhLmJbMF0nOiB7YzogM319KTtcbiAgICpcbiAgICogYC5vd25gIGFuZCBgLm5lc3RlZGAgY2Fubm90IGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QuaW5jbHVkZSgndGFjbycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUoNCk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLmluY2x1ZGVgIHdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYmplY3QuXG4gICAqIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgb2JqZWN0IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgYHZhbGAncyBrZXkvdmFsdWUgcGFpcnMgYnV0IG1heSBvciBtYXlcbiAgICogbm90IGhhdmUgc29tZSBvZiB0aGVtLiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3NcbiAgICogZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IG9iamVjdCBpc24ndCBldmVuIGV4cGVjdGVkIHRvIGhhdmUgYHZhbGAncyBrZXlzLCBpdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YzogM30pLnRvLm5vdC5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YzogM30pLnRvLm5vdC5pbmNsdWRlKHthOiAxLCBiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYHZhbGAncyBrZXlzLCBpdCdzIG9mdGVuIGJlc3QgdG9cbiAgICogYXNzZXJ0IHRoYXQgZWFjaCBvZiB0aGUgcHJvcGVydGllcyBoYXMgaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCBlYWNoIHByb3BlcnR5IGRvZXNuJ3QgaGF2ZSBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMywgYjogNH0pLnRvLmluY2x1ZGUoe2E6IDMsIGI6IDR9KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMywgYjogNH0pLnRvLm5vdC5pbmNsdWRlKHthOiAxLCBiOiAyfSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmluY2x1ZGVgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUoNCwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmluY2x1ZGUoNCk7XG4gICAqXG4gICAqIGAuaW5jbHVkZWAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGxhbmd1YWdlIGNoYWluLCBjYXVzaW5nIGFsbCBgLm1lbWJlcnNgIGFuZFxuICAgKiBgLmtleXNgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhlIHRhcmdldCB0byBiZSBhXG4gICAqIHN1cGVyc2V0IG9mIHRoZSBleHBlY3RlZCBzZXQsIHJhdGhlciB0aGFuIGFuIGlkZW50aWNhbCBzZXQuIE5vdGUgdGhhdFxuICAgKiBgLm1lbWJlcnNgIGlnbm9yZXMgZHVwbGljYXRlcyBpbiB0aGUgc3Vic2V0IHdoZW4gYC5pbmNsdWRlYCBpcyBhZGRlZC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QncyBrZXlzIGFyZSBhIHN1cGVyc2V0IG9mIFsnYScsICdiJ10gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLmluY2x1ZGUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8ubm90LmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGEgc3VwZXJzZXQgb2YgWzEsIDJdIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICpcbiAgICogICAgIC8vIER1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCBhcmUgaWdub3JlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyLCAyLCAyXSk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBhZGRpbmcgYC5hbnlgIGVhcmxpZXIgaW4gdGhlIGNoYWluIGNhdXNlcyB0aGUgYC5rZXlzYCBhc3NlcnRpb25cbiAgICogdG8gaWdub3JlIGAuaW5jbHVkZWAuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5pbmNsdWRlc2AsIGAuY29udGFpbmAsIGFuZCBgLmNvbnRhaW5zYCBjYW4gYmUgdXNlZFxuICAgKiBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmluY2x1ZGVgLlxuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBhbGlhcyBjb250YWluXG4gICAqIEBhbGlhcyBpbmNsdWRlc1xuICAgKiBAYWxpYXMgY29udGFpbnNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBTYW1lVmFsdWVaZXJvKGEsIGIpIHtcbiAgICByZXR1cm4gKF8uaXNOYU4oYSkgJiYgXy5pc05hTihiKSkgfHwgYSA9PT0gYjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICBmbGFnKHRoaXMsICdjb250YWlucycsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZSAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIGRlc2NyaXB0b3IgPSBpc0RlZXAgPyAnZGVlcCAnIDogJyc7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgICB2YXIgaW5jbHVkZWQgPSBmYWxzZTtcblxuICAgIHN3aXRjaCAob2JqVHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaW5jbHVkZWQgPSBvYmouaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dlYWtzZXQnOlxuICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICd1bmFibGUgdG8gdXNlIC5kZWVwLmluY2x1ZGUgd2l0aCBXZWFrU2V0JyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5jbHVkZWQgPSBvYmouaGFzKHZhbCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtYXAnOlxuICAgICAgICB2YXIgaXNFcWwgPSBpc0RlZXAgPyBfLmVxbCA6IFNhbWVWYWx1ZVplcm87XG4gICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBpc0VxbChpdGVtLCB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaW5jbHVkZWQgPSBpbmNsdWRlZCB8fCBfLmVxbChpdGVtLCB2YWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLmhhcyh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IG9iai5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lcWwoaXRlbSwgdmFsKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIFRoaXMgYmxvY2sgaXMgZm9yIGFzc2VydGluZyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICAgICAgLy8gYF8uZXhwZWN0VHlwZXNgIGlzbid0IHVzZWQgaGVyZSBiZWNhdXNlIGAuaW5jbHVkZWAgc2hvdWxkIHdvcmsgd2l0aFxuICAgICAgICAvLyBvYmplY3RzIHdpdGggYSBjdXN0b20gYEBAdG9TdHJpbmdUYWdgLlxuICAgICAgICBpZiAodmFsICE9PSBPYmplY3QodmFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICAgIGZsYWdNc2cgKyAnb2JqZWN0IHRlc3RlZCBtdXN0IGJlIGFuIGFycmF5LCBhIG1hcCwgYW4gb2JqZWN0LCdcbiAgICAgICAgICAgICAgKyAnIGEgc2V0LCBhIHN0cmluZywgb3IgYSB3ZWFrc2V0LCBidXQgJyArIG9ialR5cGUgKyAnIGdpdmVuJyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgICAgICwgZmlyc3RFcnIgPSBudWxsXG4gICAgICAgICAgLCBudW1FcnJzID0gMDtcblxuICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgdmFyIHByb3BBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKG9iaik7XG4gICAgICAgICAgXy50cmFuc2ZlckZsYWdzKHRoaXMsIHByb3BBc3NlcnRpb24sIHRydWUpO1xuICAgICAgICAgIGZsYWcocHJvcEFzc2VydGlvbiwgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoIW5lZ2F0ZSB8fCBwcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHByb3BBc3NlcnRpb24ucHJvcGVydHkocHJvcCwgdmFsW3Byb3BdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvcEFzc2VydGlvbi5wcm9wZXJ0eShwcm9wLCB2YWxbcHJvcF0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUNvbnN0cnVjdG9yKGVyciwgQXNzZXJ0aW9uRXJyb3IpKSB7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdEVyciA9PT0gbnVsbCkgZmlyc3RFcnIgPSBlcnI7XG4gICAgICAgICAgICBudW1FcnJzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBXaGVuIHZhbGlkYXRpbmcgLm5vdC5pbmNsdWRlIHdpdGggbXVsdGlwbGUgcHJvcGVydGllcywgd2Ugb25seSB3YW50XG4gICAgICAgIC8vIHRvIHRocm93IGFuIGFzc2VydGlvbiBlcnJvciBpZiBhbGwgb2YgdGhlIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkLFxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIHRocm93IHRoZSBmaXJzdCBwcm9wZXJ0eSBhc3NlcnRpb24gZXJyb3IgdGhhdCB3ZVxuICAgICAgICAvLyBlbmNvdW50ZXJlZC5cbiAgICAgICAgaWYgKG5lZ2F0ZSAmJiBwcm9wcy5sZW5ndGggPiAxICYmIG51bUVycnMgPT09IHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IGZpcnN0RXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3NlcnQgaW5jbHVzaW9uIGluIGNvbGxlY3Rpb24gb3Igc3Vic3RyaW5nIGluIGEgc3RyaW5nLlxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaW5jbHVkZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gJyArIGRlc2NyaXB0b3IgKyAnaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90ICcgKyBkZXNjcmlwdG9yICsgJ2luY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY2x1ZGUnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2NvbnRhaW4nLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2NvbnRhaW5zJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlcycsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcblxuICAvKipcbiAgICogIyMjIC5va1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIHRydXRoeSB2YWx1ZSAoY29uc2lkZXJlZCBgdHJ1ZWAgaW4gYm9vbGVhbiBjb250ZXh0KS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBvclxuICAgKiBkZWVwbHkgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5va2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoMCkudG8uZXF1YWwoMCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMCkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLm9rO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29rJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnV0aHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHN5Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRydWVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC50cnVlYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYHRydWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLnRydWU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS50cnVlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnRydWU7XG4gICAqXG4gICAqIEBuYW1lIHRydWVcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd0cnVlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgZmxhZyh0aGlzLCAnbmVnYXRlJykgPyBmYWxzZSA6IHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mYWxzZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmZhbHNlYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLm5vdC5iZS5mYWxzZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmZhbHNlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZmFsc2U7XG4gICAqXG4gICAqIEBuYW1lIGZhbHNlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmFsc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZhbHNlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgZmxhZyh0aGlzLCAnbmVnYXRlJykgPyB0cnVlIDogZmFsc2VcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5udWxsXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubnVsbGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW4gbm90XG4gICAqIGVxdWFsIHRvIGBudWxsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUubnVsbDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5udWxsO1xuICAgKlxuICAgKiBAbmFtZSBudWxsXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbnVsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgbnVsbCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIG51bGwnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudW5kZWZpbmVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAudW5kZWZpbmVkYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhblxuICAgKiBub3QgZXF1YWwgdG8gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnVuZGVmaW5lZDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS51bmRlZmluZWQ7XG4gICAqXG4gICAqIEBuYW1lIHVuZGVmaW5lZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3VuZGVmaW5lZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdW5kZWZpbmVkID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB1bmRlZmluZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSB1bmRlZmluZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuTmFOXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGV4YWN0bHkgYE5hTmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoTmFOKS50by5iZS5OYU47XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuTmFOYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYE5hTmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmVxdWFsKCdmb28nKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLk5hTjsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5OYU47XG4gICAqXG4gICAqIEBuYW1lIE5hTlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ05hTicsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5pc05hTihmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBOYU4nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIE5hTidcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBub3Qgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBlaXRoZXIgYG51bGxgIG9yXG4gICAqIGB1bmRlZmluZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0b1xuICAgKiBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KDApLnRvLmVxdWFsKDApOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDApLnRvLmV4aXN0OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5leGlzdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8ubm90LmV4aXN0OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uZXhpc3Q7XG4gICAqXG4gICAqIEBuYW1lIGV4aXN0XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZXhpc3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXhpc3QnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBleGlzdCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5lbXB0eVxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGAuZW1wdHlgIGFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3NcbiAgICogYGxlbmd0aGAgcHJvcGVydHkgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgMGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KCcnKS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbWFwIG9yIHNldCwgYC5lbXB0eWAgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBgc2l6ZWBcbiAgICogcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gYDBgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoKSkudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3QobmV3IE1hcCgpKS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbm9uLWZ1bmN0aW9uIG9iamVjdCwgYC5lbXB0eWAgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXRcbiAgICogZG9lc24ndCBoYXZlIGFueSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBQcm9wZXJ0aWVzIHdpdGggU3ltYm9sLWJhc2VkXG4gICAqIGtleXMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGNvdW50LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9KS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogQmVjYXVzZSBgLmVtcHR5YCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUsIGl0J3NcbiAgICogaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZSB1c2luZyBgLmVtcHR5YC4gU2VlIHRoZSBgLmFgXG4gICAqIGRvYyBmb3IgaW5mbyBvbiB0ZXN0aW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbXSkudG8uYmUuYW4oJ2FycmF5JykudGhhdC5pcy5lbXB0eTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5lbXB0eWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGNvbnRhaW5zIGl0cyBleHBlY3RlZCBudW1iZXIgb2YgdmFsdWVzLFxuICAgKiByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCdzIG5vdCBlbXB0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuYmUuZW1wdHk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDIsIDNdKSkudG8uaGF2ZS5wcm9wZXJ0eSgnc2l6ZScsIDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDIsIDNdKSkudG8ubm90LmJlLmVtcHR5OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChPYmplY3Qua2V5cyh7YTogMX0pKS50by5oYXZlLmxlbmd0aE9mKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLmVtcHR5OyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10sICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5lbXB0eTtcbiAgICpcbiAgICogQG5hbWUgZW1wdHlcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdlbXB0eScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIGl0ZW1zQ291bnQ7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgICBzd2l0Y2ggKF8udHlwZSh2YWwpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGl0ZW1zQ291bnQgPSB2YWwubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICBjYXNlICdzZXQnOlxuICAgICAgICBpdGVtc0NvdW50ID0gdmFsLnNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Vha21hcCc6XG4gICAgICBjYXNlICd3ZWFrc2V0JzpcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAnLmVtcHR5IHdhcyBwYXNzZWQgYSB3ZWFrIGNvbGxlY3Rpb24nLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICAgICk7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHZhciBtc2cgPSBmbGFnTXNnICsgJy5lbXB0eSB3YXMgcGFzc2VkIGEgZnVuY3Rpb24gJyArIF8uZ2V0TmFtZSh2YWwpO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLnRyaW0oKSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWwgIT09IE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICcuZW1wdHkgd2FzIHBhc3NlZCBub24tc3RyaW5nIHByaW1pdGl2ZSAnICsgXy5pbnNwZWN0KHZhbCksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBzc2ZpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtc0NvdW50ID0gT2JqZWN0LmtleXModmFsKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIDAgPT09IGl0ZW1zQ291bnRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gdGVzdCAoKSB7XG4gICAqICAgICAgIGV4cGVjdChhcmd1bWVudHMpLnRvLmJlLmFyZ3VtZW50cztcbiAgICogICAgIH1cbiAgICpcbiAgICogICAgIHRlc3QoKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5hcmd1bWVudHNgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHdoaWNoIHR5cGUgdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgaXRzIG5vdCBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuYXJndW1lbnRzOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7fSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmFyZ3VtZW50cztcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuQXJndW1lbnRzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmFyZ3VtZW50c2AuXG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IF8udHlwZShvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnQXJndW1lbnRzJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byB0aGUgZ2l2ZW4gYHZhbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmVxdWFsKCdmb28nKTtcbiAgICpcbiAgICogQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZVxuICAgKiBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWxzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5kZWVwLmVxdWFsKHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFscyBgWzEsIDJdYFxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uZGVlcC5lcXVhbChbMSwgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8ubm90LmVxdWFsKFsxLCAyXSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZXF1YWxgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBvbmUgb2YgY291bnRsZXNzIHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5lcXVhbCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuZXF1YWxgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmVxdWFsKDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmVxdWFsc2AgYW5kIGBlcWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5lcXVhbGAuXG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBhbGlhcyBlcXVhbHNcbiAgICogQGFsaWFzIGVxXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RXF1YWwgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkZWVwJykpIHtcbiAgICAgIHZhciBwcmV2TG9ja1NzZmkgPSBmbGFnKHRoaXMsICdsb2NrU3NmaScpO1xuICAgICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCB0cnVlKTtcbiAgICAgIHRoaXMuZXFsKHZhbCk7XG4gICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHByZXZMb2NrU3NmaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gb2JqXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdGhpcy5fb2JqXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbCcsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWxzJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcScsIGFzc2VydEVxdWFsKTtcblxuICAvKipcbiAgICogIyMjIC5lcWwob2JqWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBgb2JqYC4gU2VlIHRoZVxuICAgKiBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGlzIGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWwgdG8ge2E6IDF9XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5lcWwoe2E6IDF9KS5idXQubm90LmVxdWFsKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgaXMgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbCB0byBbMSwgMl1cbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmVxbChbMSwgMl0pLmJ1dC5ub3QuZXF1YWwoWzEsIDJdKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5lcWxgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBkZWVwbHkgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXJcbiAgICogdGhhbiBub3QgZGVlcGx5IGVxdWFsIHRvIG9uZSBvZiBjb3VudGxlc3MgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5lcWwoe2E6IDF9KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5lcWwoe2I6IDJ9KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuZXFsYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5lcWwoe2I6IDJ9LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uZXFsKHtiOiAyfSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmVxbHNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuZXFsYC5cbiAgICpcbiAgICogVGhlIGAuZGVlcC5lcXVhbGAgYXNzZXJ0aW9uIGlzIGFsbW9zdCBpZGVudGljYWwgdG8gYC5lcWxgIGJ1dCB3aXRoIG9uZVxuICAgKiBkaWZmZXJlbmNlOiBgLmRlZXAuZXF1YWxgIGNhdXNlcyBkZWVwIGVxdWFsaXR5IGNvbXBhcmlzb25zIHRvIGFsc28gYmUgdXNlZFxuICAgKiBmb3IgYW55IG90aGVyIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiBAbmFtZSBlcWxcbiAgICogQGFsaWFzIGVxbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcWwob2JqLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5lcWwob2JqLCBmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsIG9ialxuICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWwnLCBhc3NlcnRFcWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWxzJywgYXNzZXJ0RXFsKTtcblxuICAvKipcbiAgICogIyMjIC5hYm92ZShuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGdyZWF0ZXIgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIG9yIGRhdGUgYG5gIHJlc3BlY3RpdmVseS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmFib3ZlKDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYFxuICAgKiBvciBgc2l6ZWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBnaXZlbiBudW1iZXIgYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5hYm92ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmFib3ZlKDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5hYm92ZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmFib3ZlKDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYWJvdmUoMik7XG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAuZ3RgIGFuZCBgLmdyZWF0ZXJUaGFuYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aFxuICAgKiBgLmFib3ZlYC5cbiAgICpcbiAgICogQG5hbWUgYWJvdmVcbiAgICogQGFsaWFzIGd0XG4gICAqIEBhbGlhcyBncmVhdGVyVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QWJvdmUgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBuVHlwZSA9IF8udHlwZShuKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGVycm9yTWVzc2FnZVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGggJiYgb2JqVHlwZSAhPT0gJ21hcCcgJiYgb2JqVHlwZSAhPT0gJ3NldCcpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gYWJvdmUgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gYWJvdmUgbXVzdCBiZSBhIG51bWJlcic7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAgICwgaXRlbXNDb3VudDtcbiAgICAgIGlmIChvYmpUeXBlID09PSAnbWFwJyB8fCBvYmpUeXBlID09PSAnc2V0Jykge1xuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGl0ZW1zQ291bnQgPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBhYm92ZSAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBpdGVtc0NvdW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYWJvdmUnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0JywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdncmVhdGVyVGhhbicsIGFzc2VydEFib3ZlKTtcblxuICAvKipcbiAgICogIyMjIC5sZWFzdChuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW5cbiAgICogbnVtYmVyIG9yIGRhdGUgYG5gIHJlc3BlY3RpdmVseS4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG9cbiAgICogaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmF0LmxlYXN0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubGVhc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5hdC5sZWFzdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubGVhc3RgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hdC5sZWFzdCgyLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmF0LmxlYXN0KDIpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5ndGVgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAubGVhc3RgLlxuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZWFzdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZXJyb3JNZXNzYWdlXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZTtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiBuVHlwZSAhPT0gJ2RhdGUnKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBsZWFzdCBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBsZWFzdCBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBhdCBsZWFzdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGl0ZW1zQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlYXN0JywgYXNzZXJ0TGVhc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndGUnLCBhc3NlcnRMZWFzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYmVsb3coblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBsZXNzIHRoYW4gdGhlIGdpdmVuIG51bWJlciBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5iZWxvdygyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aCgzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYmVsb3coNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmJlbG93YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5ub3QuYmUuYmVsb3coMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmJlbG93YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYmVsb3coMSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDIsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5iZWxvdygxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5sdGAgYW5kIGAubGVzc1RoYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAuYmVsb3dgLlxuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRCZWxvdyAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZXJyb3JNZXNzYWdlXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZTtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiBuVHlwZSAhPT0gJ2RhdGUnKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBiZWxvdyBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBiZWxvdyBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGJlbG93ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGl0ZW1zQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYmVsb3cnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbicsIGFzc2VydEJlbG93KTtcblxuICAvKipcbiAgICogIyMjIC5tb3N0KG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXJcbiAgICogb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHNcbiAgICogZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubW9zdCgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYXQubW9zdCgxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIGBuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi5hdC5tb3N0KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm1vc3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5iZS5hdC5tb3N0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5tb3N0YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubW9zdCgxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmF0Lm1vc3QoMSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmx0ZWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5tb3N0YC5cbiAgICpcbiAgICogQG5hbWUgbW9zdFxuICAgKiBAYWxpYXMgbHRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRNb3N0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIG1vc3QgbXVzdCBiZSBhIGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoblR5cGUgIT09ICdudW1iZXInICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbW9zdCBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBhdCBtb3N0ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgaXRlbXNDb3VudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtb3N0JywgYXNzZXJ0TW9zdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0ZScsIGFzc2VydE1vc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLndpdGhpbihzdGFydCwgZmluaXNoWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW5cbiAgICogbnVtYmVyIG9yIGRhdGUgYHN0YXJ0YCwgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIG9yIGRhdGUgYGZpbmlzaGAgcmVzcGVjdGl2ZWx5LlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWRcbiAgICogdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUud2l0aGluKDEsIDMpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS53aXRoaW4oMiwgMyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLndpdGhpbigxLCAyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmxlbmd0aE9mYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGBcbiAgICogb3IgYHNpemVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIGBzdGFydGAsIGFuZCBsZXNzXG4gICAqIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlciBgZmluaXNoYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZi53aXRoaW4oMiwgNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2Yud2l0aGluKDIsIDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC53aXRoaW5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS53aXRoaW4oMiwgNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLndpdGhpbmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDQpLnRvLmJlLndpdGhpbigxLCAzLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoNCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLndpdGhpbigxLCAzKTtcbiAgICpcbiAgICogQG5hbWUgd2l0aGluXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBsb3dlciBib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbmlzaCB1cHBlciBib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3dpdGhpbicsIGZ1bmN0aW9uIChzdGFydCwgZmluaXNoLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgc3RhcnRUeXBlID0gXy50eXBlKHN0YXJ0KS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGZpbmlzaFR5cGUgPSBfLnR5cGUoZmluaXNoKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGVycm9yTWVzc2FnZVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWVcbiAgICAgICwgcmFuZ2UgPSAoc3RhcnRUeXBlID09PSAnZGF0ZScgJiYgZmluaXNoVHlwZSA9PT0gJ2RhdGUnKVxuICAgICAgICAgID8gc3RhcnQudG9VVENTdHJpbmcoKSArICcuLicgKyBmaW5pc2gudG9VVENTdHJpbmcoKVxuICAgICAgICAgIDogc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIChzdGFydFR5cGUgIT09ICdkYXRlJyB8fCBmaW5pc2hUeXBlICE9PSAnZGF0ZScpKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudHMgdG8gd2l0aGluIG11c3QgYmUgZGF0ZXMnO1xuICAgIH0gZWxzZSBpZiAoKHN0YXJ0VHlwZSAhPT0gJ251bWJlcicgfHwgZmluaXNoVHlwZSAhPT0gJ251bWJlcicpICYmIChkb0xlbmd0aCB8fCBvYmpUeXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnRzIHRvIHdpdGhpbiBtdXN0IGJlIG51bWJlcnMnO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgICAsIGl0ZW1zQ291bnQ7XG4gICAgICBpZiAob2JqVHlwZSA9PT0gJ21hcCcgfHwgb2JqVHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBpdGVtc0NvdW50ID49IHN0YXJ0ICYmIGl0ZW1zQ291bnQgPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyB3aXRoaW4gJyArIHJhbmdlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IHN0YXJ0ICYmIG9iaiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZW9mKGNvbnN0cnVjdG9yWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkgeyB9XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IENhdCgpKS50by5iZS5hbi5pbnN0YW5jZW9mKENhdCk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5pbnN0YW5jZW9mYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogYC5pbnN0YW5jZW9mYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYW4uaW5zdGFuY2VvZihBcnJheSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hbi5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogRHVlIHRvIGxpbWl0YXRpb25zIGluIEVTNSwgYC5pbnN0YW5jZW9mYCBtYXkgbm90IGFsd2F5cyB3b3JrIGFzIGV4cGVjdGVkXG4gICAqIHdoZW4gdXNpbmcgYSB0cmFuc3BpbGVyIHN1Y2ggYXMgQmFiZWwgb3IgVHlwZVNjcmlwdC4gSW4gcGFydGljdWxhciwgaXQgbWF5XG4gICAqIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzIHdoZW4gc3ViY2xhc3NpbmcgYnVpbHQtaW4gb2JqZWN0IHN1Y2ggYXNcbiAgICogYEFycmF5YCwgYEVycm9yYCwgYW5kIGBNYXBgLiBTZWUgeW91ciB0cmFuc3BpbGVyJ3MgZG9jcyBmb3IgZGV0YWlsczpcbiAgICpcbiAgICogLSAoW0JhYmVsXShodHRwczovL2JhYmVsanMuaW8vZG9jcy91c2FnZS9jYXZlYXRzLyNjbGFzc2VzKSlcbiAgICogLSAoW1R5cGVTY3JpcHRdKGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrKSlcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuaW5zdGFuY2VPZmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5pbnN0YW5jZW9mYC5cbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQGFsaWFzIGluc3RhbmNlT2ZcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VPZiAoY29uc3RydWN0b3IsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgdmFyIHRhcmdldCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgdmFyIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgdmFyIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJyk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGlzSW5zdGFuY2VPZiA9IHRhcmdldCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBmbGFnTXNnICsgJ1RoZSBpbnN0YW5jZW9mIGFzc2VydGlvbiBuZWVkcyBhIGNvbnN0cnVjdG9yIGJ1dCAnXG4gICAgICAgICAgICArIF8udHlwZShjb25zdHJ1Y3RvcikgKyAnIHdhcyBnaXZlbi4nLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBfLmdldE5hbWUoY29uc3RydWN0b3IpO1xuICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICBuYW1lID0gJ2FuIHVubmFtZWQgY29uc3RydWN0b3InO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc0luc3RhbmNlT2ZcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lWywgdmFsWywgbXNnXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJyk7XG4gICAqXG4gICAqIFdoZW4gYHZhbGAgaXMgcHJvdmlkZWQsIGAucHJvcGVydHlgIGFsc28gYXNzZXJ0cyB0aGF0IHRoZSBwcm9wZXJ0eSdzIHZhbHVlXG4gICAqIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBgdmFsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAxKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZC4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGVcbiAgICogY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3JcbiAgICogaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIHByb3BlcnR5IGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICpcbiAgICogVGhlIHRhcmdldCdzIGVudW1lcmFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFsd2F5cyBpbmNsdWRlZFxuICAgKiBpbiB0aGUgc2VhcmNoLiBCeSBkZWZhdWx0LCBib3RoIG93biBhbmQgaW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkLlxuICAgKiBBZGQgYC5vd25gIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGV4Y2x1ZGUgaW5oZXJpdGVkIHByb3BlcnRpZXMgZnJvbSB0aGVcbiAgICogc2VhcmNoLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duLnByb3BlcnR5KCdhJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93bi5wcm9wZXJ0eSgnYScsIDEpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUub3duLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqIGAuZGVlcGAgYW5kIGAub3duYCBjYW4gYmUgY29tYmluZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmhhdmUuZGVlcC5vd24ucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKlxuICAgKiBBZGQgYC5uZXN0ZWRgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGVuYWJsZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIHdoZW5cbiAgICogcmVmZXJlbmNpbmcgbmVzdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdhLmJbMV0nKTtcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ2EuYlsxXScsICd5Jyk7XG4gICAqXG4gICAqIElmIGAuYCBvciBgW11gIGFyZSBwYXJ0IG9mIGFuIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLCB0aGV5IGNhbiBiZSBlc2NhcGVkIGJ5XG4gICAqIGFkZGluZyB0d28gYmFja3NsYXNoZXMgYmVmb3JlIHRoZW0uXG4gICAqXG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogJ3gnfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdcXFxcLmEuXFxcXFtiXFxcXF0nKTtcbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5uZXN0ZWRgIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFt7YzogM31dfX0pXG4gICAqICAgICAgIC50by5oYXZlLmRlZXAubmVzdGVkLnByb3BlcnR5KCdhLmJbMF0nLCB7YzogM30pO1xuICAgKlxuICAgKiBgLm93bmAgYW5kIGAubmVzdGVkYCBjYW5ub3QgYmUgY29tYmluZWQuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAucHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAucHJvcGVydHlgIHdoZW4gcHJvdmlkaW5nIGB2YWxgLiBUaGVcbiAgICogcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBrZXkgYG5hbWVgLCBvciB0aGF0IGl0XG4gICAqIGRvZXMgaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAgYnV0IGl0cyB2YWx1ZSBpc24ndCBlcXVhbCB0b1xuICAgKiB0aGUgZ2l2ZW4gYHZhbGAuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQnc1xuICAgKiBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleVxuICAgKiBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2EnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLnByb3BlcnR5KCdhJywgMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAsXG4gICAqIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcHJvcGVydHkgaGFzIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyXG4gICAqIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2EnLCAxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAucHJvcGVydHlgIGNoYW5nZXMgdGhlIHRhcmdldCBvZiBhbnkgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW5cbiAgICogdG8gYmUgdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCB0YXJnZXQgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScpLnRoYXQuaXMuYSgnbnVtYmVyJyk7XG4gICAqXG4gICAqIGAucHJvcGVydHlgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIGB2YWxgLCBvbmx5IHVzZSB0aGVcbiAgICogc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnByb3BlcnR5KCdhJywgMik7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdiJywgdW5kZWZpbmVkLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqIFRoZSBhYm92ZSBhc3NlcnRpb24gaXNuJ3QgdGhlIHNhbWUgdGhpbmcgYXMgbm90IHByb3ZpZGluZyBgdmFsYC4gSW5zdGVhZCxcbiAgICogaXQncyBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgYSBgYmAgcHJvcGVydHkgdGhhdCdzIGVxdWFsIHRvXG4gICAqIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBUaGUgYXNzZXJ0aW9ucyBgLm93blByb3BlcnR5YCBhbmQgYC5oYXZlT3duUHJvcGVydHlgIGNhbiBiZSB1c2VkXG4gICAqIGludGVyY2hhbmdlYWJseSB3aXRoIGAub3duLnByb3BlcnR5YC5cbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEByZXR1cm5zIHZhbHVlIG9mIHByb3BlcnR5IGZvciBjaGFpbmluZ1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRQcm9wZXJ0eSAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBpc05lc3RlZCA9IGZsYWcodGhpcywgJ25lc3RlZCcpXG4gICAgICAsIGlzT3duID0gZmxhZyh0aGlzLCAnb3duJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG5hbWVUeXBlID0gdHlwZW9mIG5hbWU7XG5cbiAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG5cbiAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgIGlmIChuYW1lVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAndGhlIGFyZ3VtZW50IHRvIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgd2hlbiB1c2luZyBuZXN0ZWQgc3ludGF4JyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmFtZVR5cGUgIT09ICdzdHJpbmcnICYmIG5hbWVUeXBlICE9PSAnbnVtYmVyJyAmJiBuYW1lVHlwZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAndGhlIGFyZ3VtZW50IHRvIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcsIG51bWJlciwgb3Igc3ltYm9sJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc05lc3RlZCAmJiBpc093bikge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICBmbGFnTXNnICsgJ1RoZSBcIm5lc3RlZFwiIGFuZCBcIm93blwiIGZsYWdzIGNhbm5vdCBiZSBjb21iaW5lZC4nLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHNzZmlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICBmbGFnTXNnICsgJ1RhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBzc2ZpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgbmVnYXRlID0gZmxhZyh0aGlzLCAnbmVnYXRlJylcbiAgICAgICwgcGF0aEluZm8gPSBpc05lc3RlZCA/IF8uZ2V0UGF0aEluZm8ob2JqLCBuYW1lKSA6IG51bGxcbiAgICAgICwgdmFsdWUgPSBpc05lc3RlZCA/IHBhdGhJbmZvLnZhbHVlIDogb2JqW25hbWVdO1xuXG4gICAgdmFyIGRlc2NyaXB0b3IgPSAnJztcbiAgICBpZiAoaXNEZWVwKSBkZXNjcmlwdG9yICs9ICdkZWVwICc7XG4gICAgaWYgKGlzT3duKSBkZXNjcmlwdG9yICs9ICdvd24gJztcbiAgICBpZiAoaXNOZXN0ZWQpIGRlc2NyaXB0b3IgKz0gJ25lc3RlZCAnO1xuICAgIGRlc2NyaXB0b3IgKz0gJ3Byb3BlcnR5ICc7XG5cbiAgICB2YXIgaGFzUHJvcGVydHk7XG4gICAgaWYgKGlzT3duKSBoYXNQcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIG5hbWUpO1xuICAgIGVsc2UgaWYgKGlzTmVzdGVkKSBoYXNQcm9wZXJ0eSA9IHBhdGhJbmZvLmV4aXN0cztcbiAgICBlbHNlIGhhc1Byb3BlcnR5ID0gXy5oYXNQcm9wZXJ0eShvYmosIG5hbWUpO1xuXG4gICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgbmVnYXRlZCBhc3NlcnRpb24gZm9yIGJvdGggbmFtZSBhbmQgdmFsLCBtZXJlbHkgaGF2aW5nXG4gICAgLy8gYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lIGlzbid0IGVub3VnaCB0byBjYXVzZSB0aGUgYXNzZXJ0aW9uIHRvXG4gICAgLy8gZmFpbC4gSXQgbXVzdCBib3RoIGhhdmUgYSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLCBhbmQgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhhdCBwcm9wZXJ0eSBtdXN0IGVxdWFsIHRoZSBnaXZlbiB2YWwuIFRoZXJlZm9yZSwgc2tpcCB0aGlzIGFzc2VydGlvbiBpblxuICAgIC8vIGZhdm9yIG9mIHRoZSBuZXh0LlxuICAgIGlmICghbmVnYXRlIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGhhc1Byb3BlcnR5XG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGhhc1Byb3BlcnR5ICYmIChpc0RlZXAgPyBfLmVxbCh2YWwsIHZhbHVlKSA6IHZhbCA9PT0gdmFsdWUpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3tleHB9LCBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Byb3BlcnR5JywgYXNzZXJ0UHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5IChuYW1lLCB2YWx1ZSwgbXNnKSB7XG4gICAgZmxhZyh0aGlzLCAnb3duJywgdHJ1ZSk7XG4gICAgYXNzZXJ0UHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHlEZXNjcmlwdG9yKG5hbWVbLCBkZXNjcmlwdG9yWywgbXNnXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBpdHMgb3duIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aCB0aGUgZ2l2ZW4ga2V5XG4gICAqIGBuYW1lYC4gRW51bWVyYWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQgaW4gdGhlXG4gICAqIHNlYXJjaC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJyk7XG4gICAqXG4gICAqIFdoZW4gYGRlc2NyaXB0b3JgIGlzIHByb3ZpZGVkLCBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgYWxzbyBhc3NlcnRzIHRoYXRcbiAgICogdGhlIHByb3BlcnR5J3MgZGVzY3JpcHRvciBpcyBkZWVwbHkgZXF1YWwgdG8gdGhlIGdpdmVuIGBkZXNjcmlwdG9yYC4gU2VlXG4gICAqIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJyk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgd2hlbiBwcm92aWRpbmdcbiAgICogYSBgZGVzY3JpcHRvcmAuIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5XG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aFxuICAgKiB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCwgb3IgdGhhdCBpdCBkb2VzIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlXG4gICAqIGdpdmVuIGtleSBgbmFtZWAgYnV0IGl0cyBub3QgZGVlcGx5IGVxdWFsIHRvIHRoZSBnaXZlbiBgZGVzY3JpcHRvcmAuIEl0J3NcbiAgICogb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW5cbiAgICogYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXNuJ3QgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aCB0aGUgZ2l2ZW5cbiAgICoga2V5IGBuYW1lYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YjogMn0pLnRvLm5vdC5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDEsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHdpdGggdGhlIGdpdmVuXG4gICAqIGtleSBgbmFtZWAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcHJvcGVydHkgaGFzIGl0cyBleHBlY3RlZFxuICAgKiBkZXNjcmlwdG9yLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnlcbiAgICogdW5leHBlY3RlZCBkZXNjcmlwdG9ycy5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDMsXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMSxcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAgY2hhbmdlcyB0aGUgdGFyZ2V0IG9mIGFueSBhc3NlcnRpb25zIHRoYXQgZm9sbG93XG4gICAqIGluIHRoZSBjaGFpbiB0byBiZSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICogdGFyZ2V0IG9iamVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJylcbiAgICogICAgICAgLnRoYXQuaGFzLnByb3BlcnR5KCdlbnVtZXJhYmxlJywgdHJ1ZSk7XG4gICAqXG4gICAqIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGFcbiAgICogY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvXG4gICAqIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZ1xuICAgKiBgZGVzY3JpcHRvcmAsIG9ubHkgdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYScsIHtcbiAgICogICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgKiAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICogICAgICAgdmFsdWU6IDIsXG4gICAqICAgICB9LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMixcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KVxuICAgKiAgICAgICAudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2InLCB1bmRlZmluZWQsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogVGhlIGFib3ZlIGFzc2VydGlvbiBpc24ndCB0aGUgc2FtZSB0aGluZyBhcyBub3QgcHJvdmlkaW5nIGBkZXNjcmlwdG9yYC5cbiAgICogSW5zdGVhZCwgaXQncyBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgYSBgYmAgcHJvcGVydHlcbiAgICogZGVzY3JpcHRvciB0aGF0J3MgZGVlcGx5IGVxdWFsIHRvIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5oYXZlT3duUHJvcGVydHlEZXNjcmlwdG9yYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aFxuICAgKiBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAuXG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgKG5hbWUsIGRlc2NyaXB0b3IsIG1zZykge1xuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1zZyA9IGRlc2NyaXB0b3I7XG4gICAgICBkZXNjcmlwdG9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciBhY3R1YWxEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3Qob2JqKSwgbmFtZSk7XG4gICAgaWYgKGFjdHVhbERlc2NyaXB0b3IgJiYgZGVzY3JpcHRvcikge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgXy5lcWwoZGVzY3JpcHRvciwgYWN0dWFsRGVzY3JpcHRvcilcbiAgICAgICAgLCAnZXhwZWN0ZWQgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvbiAje3RoaXN9IHRvIG1hdGNoICcgKyBfLmluc3BlY3QoZGVzY3JpcHRvcikgKyAnLCBnb3QgJyArIF8uaW5zcGVjdChhY3R1YWxEZXNjcmlwdG9yKVxuICAgICAgICAsICdleHBlY3RlZCB0aGUgb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9uICN7dGhpc30gdG8gbm90IG1hdGNoICcgKyBfLmluc3BlY3QoZGVzY3JpcHRvcilcbiAgICAgICAgLCBkZXNjcmlwdG9yXG4gICAgICAgICwgYWN0dWFsRGVzY3JpcHRvclxuICAgICAgICAsIHRydWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGFjdHVhbERlc2NyaXB0b3JcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGFuIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYW4gb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGFjdHVhbERlc2NyaXB0b3IpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHlEZXNjcmlwdG9yJywgYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvcicsIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvcik7XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoT2YoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgb3IgYHNpemVgIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXJcbiAgICogYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsxLCAyLCAzXSkpLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqICAgICBleHBlY3QobmV3IE1hcChbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0pKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmxlbmd0aE9mYC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWRcbiAgICogdmFsdWUsIHJhdGhlciB0aGFuIG5vdCBlcXVhbCB0byBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmhhdmUubGVuZ3RoT2YoNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmxlbmd0aE9mYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLmxlbmd0aE9mKDIpO1xuICAgKlxuICAgKiBgLmxlbmd0aE9mYCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIGNhdXNpbmcgYWxsIGAuYWJvdmVgLFxuICAgKiBgLmJlbG93YCwgYC5sZWFzdGAsIGAubW9zdGAsIGFuZCBgLndpdGhpbmAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGVcbiAgICogY2hhaW4gdG8gdXNlIHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBwcm9wZXJ0eSBhcyB0aGUgdGFyZ2V0LiBIb3dldmVyLCBpdCdzXG4gICAqIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGVxdWFsIHRvIGl0c1xuICAgKiBleHBlY3RlZCBsZW5ndGgsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0cyBgbGVuZ3RoYCBwcm9wZXJ0eSBmYWxsc1xuICAgKiB3aXRoaW4gc29tZSByYW5nZSBvZiB2YWx1ZXMuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgyKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0LmxlYXN0KDMpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5hdC5tb3N0KDMpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogRHVlIHRvIGEgY29tcGF0aWJpbGl0eSBpc3N1ZSwgdGhlIGFsaWFzIGAubGVuZ3RoYCBjYW4ndCBiZSBjaGFpbmVkIGRpcmVjdGx5XG4gICAqIG9mZiBvZiBhbiB1bmludm9rZWQgbWV0aG9kIHN1Y2ggYXMgYC5hYC4gVGhlcmVmb3JlLCBgLmxlbmd0aGAgY2FuJ3QgYmUgdXNlZFxuICAgKiBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmxlbmd0aE9mYCBpbiBldmVyeSBzaXR1YXRpb24uIEl0J3MgcmVjb21tZW5kZWQgdG9cbiAgICogYWx3YXlzIHVzZSBgLmxlbmd0aE9mYCBpbnN0ZWFkIG9mIGAubGVuZ3RoYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUuYS5sZW5ndGgoMyk7IC8vIGluY29tcGF0aWJsZTsgdGhyb3dzIGVycm9yXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmEubGVuZ3RoT2YoMyk7ICAvLyBwYXNzZXMgYXMgZXhwZWN0ZWRcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoT2ZcbiAgICogQGFsaWFzIGxlbmd0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoQ2hhaW4gKCkge1xuICAgIGZsYWcodGhpcywgJ2RvTGVuZ3RoJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGggKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAsIGl0ZW1zQ291bnQ7XG5cbiAgICBzd2l0Y2ggKG9ialR5cGUpIHtcbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICBjYXNlICdzZXQnOlxuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXRlbXNDb3VudCA9PSBuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgb2YgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBvZiAje2FjdH0nXG4gICAgICAsIG5cbiAgICAgICwgaXRlbXNDb3VudFxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaChyZVssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG1hdGNoZXMgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5tYXRjaCgvXmZvby8pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm1hdGNoYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubm90Lm1hdGNoKC90YWNvLyk7XG4gICAqXG4gICAqIGAubWF0Y2hgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL3RhY28vLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicsICdub29vIHdoeSBmYWlsPz8nKS50by5tYXRjaCgvdGFjby8pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5tYXRjaGVzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm1hdGNoYC5cbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQGFsaWFzIG1hdGNoZXNcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0TWF0Y2gocmUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmUuZXhlYyhvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG1hdGNoICcgKyByZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gbWF0Y2ggJyArIHJlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoJywgYXNzZXJ0TWF0Y2gpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaGVzJywgYXNzZXJ0TWF0Y2gpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmluZyhzdHJbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBzdHJpbmcgY29udGFpbnMgdGhlIGdpdmVuIHN1YnN0cmluZyBgc3RyYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ2JhcicpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnN0cmluZ2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm5vdC5oYXZlLnN0cmluZygndGFjbycpO1xuICAgKlxuICAgKiBgLnN0cmluZ2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLnN0cmluZygndGFjbycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJywgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUuc3RyaW5nKCd0YWNvJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzdHJpbmcnLCBmdW5jdGlvbiAoc3RyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdzdHJpbmcnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB+b2JqLmluZGV4T2Yoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5rZXlzKGtleTFbLCBrZXkyWywgLi4uXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG9iamVjdCwgYXJyYXksIG1hcCwgb3Igc2V0IGhhcyB0aGUgZ2l2ZW4ga2V5cy4gT25seVxuICAgKiB0aGUgdGFyZ2V0J3Mgb3duIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2VhcmNoLlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYW4gb2JqZWN0IG9yIGFycmF5LCBrZXlzIGNhbiBiZSBwcm92aWRlZCBhcyBvbmUgb3IgbW9yZVxuICAgKiBzdHJpbmcgYXJndW1lbnRzLCBhIHNpbmdsZSBhcnJheSBhcmd1bWVudCwgb3IgYSBzaW5nbGUgb2JqZWN0IGFyZ3VtZW50LiBJblxuICAgKiB0aGUgbGF0dGVyIGNhc2UsIG9ubHkgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG9iamVjdCBtYXR0ZXI7IHRoZSB2YWx1ZXMgYXJlXG4gICAqIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdChbJ3gnLCAneSddKS50by5oYXZlLmFsbC5rZXlzKDAsIDEpO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cyhbJ2EnLCAnYiddKTtcbiAgICogICAgIGV4cGVjdChbJ3gnLCAneSddKS50by5oYXZlLmFsbC5rZXlzKFswLCAxXSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKHthOiA0LCBiOiA1fSk7IC8vIGlnbm9yZSA0IGFuZCA1XG4gICAqICAgICBleHBlY3QoWyd4JywgJ3knXSkudG8uaGF2ZS5hbGwua2V5cyh7MDogNCwgMTogNX0pOyAvLyBpZ25vcmUgNCBhbmQgNVxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBtYXAgb3Igc2V0LCBlYWNoIGtleSBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgc2VwYXJhdGVcbiAgICogYXJndW1lbnQuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IE1hcChbWydhJywgMV0sIFsnYicsIDJdXSkpLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWydhJywgJ2InXSkpLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBCZWNhdXNlIGAua2V5c2AgZG9lcyBkaWZmZXJlbnQgdGhpbmdzIGJhc2VkIG9uIHRoZSB0YXJnZXQncyB0eXBlLCBpdCdzXG4gICAqIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmUgdXNpbmcgYC5rZXlzYC4gU2VlIHRoZSBgLmFgIGRvY1xuICAgKiBmb3IgaW5mbyBvbiB0ZXN0aW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmJlLmFuKCdvYmplY3QnKS50aGF0Lmhhcy5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHN0cmljdCAoYD09PWApIGVxdWFsaXR5IGlzIHVzZWQgdG8gY29tcGFyZSBrZXlzIG9mIG1hcHMgYW5kXG4gICAqIHNldHMuIEFkZCBgLmRlZXBgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHVzZSBkZWVwIGVxdWFsaXR5IGluc3RlYWQuIFNlZVxuICAgKiB0aGUgYGRlZXAtZXFsYCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlIGRlZXAgZXF1YWxpdHkgYWxnb3JpdGhtOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IHNldCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBrZXkgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8uaGF2ZS5hbGwuZGVlcC5rZXlzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8ubm90LmhhdmUuYWxsLmtleXMoW3thOiAxfV0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgdGFyZ2V0IG11c3QgaGF2ZSBhbGwgb2YgdGhlIGdpdmVuIGtleXMgYW5kIG5vIG1vcmUuIEFkZFxuICAgKiBgLmFueWAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gb25seSByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCBoYXZlIGF0IGxlYXN0XG4gICAqIG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cy4gQWxzbywgYWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGVcbiAgICogYC5rZXlzYC4gSXQncyBvZnRlbiBiZXN0IHRvIGFkZCBgLmFueWAgd2hlbiBuZWdhdGluZyBgLmtleXNgLCBhbmQgdG8gdXNlXG4gICAqIGAuYWxsYCB3aGVuIGFzc2VydGluZyBgLmtleXNgIHdpdGhvdXQgbmVnYXRpb24uXG4gICAqXG4gICAqIFdoZW4gbmVnYXRpbmcgYC5rZXlzYCwgYC5hbnlgIGlzIHByZWZlcnJlZCBiZWNhdXNlIGAubm90LmFueS5rZXlzYCBhc3NlcnRzXG4gICAqIGV4YWN0bHkgd2hhdCdzIGV4cGVjdGVkIG9mIHRoZSBvdXRwdXQsIHdoZXJlYXMgYC5ub3QuYWxsLmtleXNgIGNyZWF0ZXNcbiAgICogdW5jZXJ0YWluIGV4cGVjdGF0aW9ucy5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkOyBhc3NlcnRzIHRoYXQgdGFyZ2V0IGRvZXNuJ3QgaGF2ZSBhbnkgb2YgdGhlIGdpdmVuIGtleXNcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLm5vdC5oYXZlLmFueS5rZXlzKCdjJywgJ2QnKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZDsgYXNzZXJ0cyB0aGF0IHRhcmdldCBkb2Vzbid0IGhhdmUgYWxsIG9mIHRoZSBnaXZlblxuICAgKiAgICAgLy8ga2V5cyBidXQgbWF5IG9yIG1heSBub3QgaGF2ZSBzb21lIG9mIHRoZW1cbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLm5vdC5oYXZlLmFsbC5rZXlzKCdjJywgJ2QnKTtcbiAgICpcbiAgICogV2hlbiBhc3NlcnRpbmcgYC5rZXlzYCB3aXRob3V0IG5lZ2F0aW9uLCBgLmFsbGAgaXMgcHJlZmVycmVkIGJlY2F1c2VcbiAgICogYC5hbGwua2V5c2AgYXNzZXJ0cyBleGFjdGx5IHdoYXQncyBleHBlY3RlZCBvZiB0aGUgb3V0cHV0LCB3aGVyZWFzXG4gICAqIGAuYW55LmtleXNgIGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucy5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkOyBhc3NlcnRzIHRoYXQgdGFyZ2V0IGhhcyBhbGwgdGhlIGdpdmVuIGtleXNcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkOyBhc3NlcnRzIHRoYXQgdGFyZ2V0IGhhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuXG4gICAqICAgICAvLyBrZXlzIGJ1dCBtYXkgb3IgbWF5IG5vdCBoYXZlIG1vcmUgb2YgdGhlbVxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBgLmFsbGAgaXMgdXNlZCBieSBkZWZhdWx0IHdoZW4gbmVpdGhlciBgLmFsbGAgbm9yIGAuYW55YCBhcHBlYXJcbiAgICogZWFybGllciBpbiB0aGUgY2hhaW4uIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhZGQgYC5hbGxgIGFueXdheSBiZWNhdXNlXG4gICAqIGl0IGltcHJvdmVzIHJlYWRhYmlsaXR5LlxuICAgKlxuICAgKiAgICAgLy8gQm90aCBhc3NlcnRpb25zIGFyZSBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5rZXlzKCdhJywgJ2InKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLmluY2x1ZGVgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIHJlcXVpcmUgdGhhdCB0aGUgdGFyZ2V0J3Mga2V5cyBiZSBhXG4gICAqIHN1cGVyc2V0IG9mIHRoZSBleHBlY3RlZCBrZXlzLCByYXRoZXIgdGhhbiBpZGVudGljYWwgc2V0cy5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QncyBrZXlzIGFyZSBhIHN1cGVyc2V0IG9mIFsnYScsICdiJ10gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMiwgYzogM30pLnRvLmluY2x1ZGUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8ubm90LmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpZiBgLmFueWAgYW5kIGAuaW5jbHVkZWAgYXJlIGNvbWJpbmVkLCBvbmx5IHRoZSBgLmFueWAgdGFrZXNcbiAgICogZWZmZWN0LiBUaGUgYC5pbmNsdWRlYCBpcyBpZ25vcmVkIGluIHRoaXMgY2FzZS5cbiAgICpcbiAgICogICAgIC8vIEJvdGggYXNzZXJ0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmluY2x1ZGUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUua2V5KCdiJyk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmtleWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5rZXlzYC5cbiAgICpcbiAgICogQG5hbWUga2V5c1xuICAgKiBAYWxpYXMga2V5XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfEFycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRLZXlzIChrZXlzKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKVxuICAgICAgLCBrZXlzVHlwZSA9IF8udHlwZShrZXlzKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGlzRGVlcCA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgLCBzdHJcbiAgICAgICwgZGVlcFN0ciA9ICcnXG4gICAgICAsIGFjdHVhbFxuICAgICAgLCBvayA9IHRydWVcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKTtcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcbiAgICB2YXIgbWl4ZWRBcmdzTXNnID0gZmxhZ01zZyArICd3aGVuIHRlc3Rpbmcga2V5cyBhZ2FpbnN0IGFuIG9iamVjdCBvciBhbiBhcnJheSB5b3UgbXVzdCBnaXZlIGEgc2luZ2xlIEFycmF5fE9iamVjdHxTdHJpbmcgYXJndW1lbnQgb3IgbXVsdGlwbGUgU3RyaW5nIGFyZ3VtZW50cyc7XG5cbiAgICBpZiAob2JqVHlwZSA9PT0gJ01hcCcgfHwgb2JqVHlwZSA9PT0gJ1NldCcpIHtcbiAgICAgIGRlZXBTdHIgPSBpc0RlZXAgPyAnZGVlcGx5ICcgOiAnJztcbiAgICAgIGFjdHVhbCA9IFtdO1xuXG4gICAgICAvLyBNYXAgYW5kIFNldCAnLmtleXMnIGFyZW4ndCBzdXBwb3J0ZWQgaW4gSUUgMTEuIFRoZXJlZm9yZSwgdXNlIC5mb3JFYWNoLlxuICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7IGFjdHVhbC5wdXNoKGtleSkgfSk7XG5cbiAgICAgIGlmIChrZXlzVHlwZSAhPT0gJ0FycmF5Jykge1xuICAgICAgICBrZXlzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWN0dWFsID0gXy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyhvYmopO1xuXG4gICAgICBzd2l0Y2ggKGtleXNUeXBlKSB7XG4gICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtaXhlZEFyZ3NNc2csIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1peGVkQXJnc01zZywgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGtleXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHN0cmluZ2lmeSBub24tU3ltYm9scyBiZWNhdXNlIFN5bWJvbHMgd291bGQgYmVjb21lIFwiU3ltYm9sKClcIlxuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnID8gdmFsIDogU3RyaW5nKHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZmxhZ01zZyArICdrZXlzIHJlcXVpcmVkJywgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGhcbiAgICAgICwgYW55ID0gZmxhZyh0aGlzLCAnYW55JylcbiAgICAgICwgYWxsID0gZmxhZyh0aGlzLCAnYWxsJylcbiAgICAgICwgZXhwZWN0ZWQgPSBrZXlzO1xuXG4gICAgaWYgKCFhbnkgJiYgIWFsbCkge1xuICAgICAgYWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYW55XG4gICAgaWYgKGFueSkge1xuICAgICAgb2sgPSBleHBlY3RlZC5zb21lKGZ1bmN0aW9uKGV4cGVjdGVkS2V5KSB7XG4gICAgICAgIHJldHVybiBhY3R1YWwuc29tZShmdW5jdGlvbihhY3R1YWxLZXkpIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lcWwoZXhwZWN0ZWRLZXksIGFjdHVhbEtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZEtleSA9PT0gYWN0dWFsS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYWxsXG4gICAgaWYgKGFsbCkge1xuICAgICAgb2sgPSBleHBlY3RlZC5ldmVyeShmdW5jdGlvbihleHBlY3RlZEtleSkge1xuICAgICAgICByZXR1cm4gYWN0dWFsLnNvbWUoZnVuY3Rpb24oYWN0dWFsS2V5KSB7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZXFsKGV4cGVjdGVkS2V5LCBhY3R1YWxLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWRLZXkgPT09IGFjdHVhbEtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgICBvayA9IG9rICYmIGtleXMubGVuZ3RoID09IGFjdHVhbC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gS2V5IHN0cmluZ1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfLmluc3BlY3Qoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgaWYgKGFsbCkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBhbmQgJyArIGxhc3Q7XG4gICAgICB9XG4gICAgICBpZiAoYW55KSB7XG4gICAgICAgIHN0ciA9IGtleXMuam9pbignLCAnKSArICcsIG9yICcgKyBsYXN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBfLmluc3BlY3Qoa2V5c1swXSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybVxuICAgIHN0ciA9IChsZW4gPiAxID8gJ2tleXMgJyA6ICdrZXkgJykgKyBzdHI7XG5cbiAgICAvLyBIYXZlIC8gaW5jbHVkZVxuICAgIHN0ciA9IChmbGFnKHRoaXMsICdjb250YWlucycpID8gJ2NvbnRhaW4gJyA6ICdoYXZlICcpICsgc3RyO1xuXG4gICAgLy8gQXNzZXJ0aW9uXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9rXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBkZWVwU3RyICsgc3RyXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCAnICsgZGVlcFN0ciArIHN0clxuICAgICAgLCBleHBlY3RlZC5zbGljZSgwKS5zb3J0KF8uY29tcGFyZUJ5SW5zcGVjdClcbiAgICAgICwgYWN0dWFsLnNvcnQoXy5jb21wYXJlQnlJbnNwZWN0KVxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleXMnLCBhc3NlcnRLZXlzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5JywgYXNzZXJ0S2V5cyk7XG5cbiAgLyoqXG4gICAqICMjIyAudGhyb3coW2Vycm9yTGlrZV0sIFtlcnJNc2dNYXRjaGVyXSwgW21zZ10pXG4gICAqXG4gICAqIFdoZW4gbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC50aHJvd2AgaW52b2tlcyB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZFxuICAgKiBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGFuIGVycm9yIGNvbnN0cnVjdG9yLCBgLnRocm93YFxuICAgKiBpbnZva2VzIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gdGhhdCdzIGFuXG4gICAqIGluc3RhbmNlIG9mIHRoYXQgZXJyb3IgY29uc3RydWN0b3IuXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYW4gZXJyb3IgaW5zdGFuY2UsIGAudGhyb3dgIGludm9rZXNcbiAgICogdGhlIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB0aGF0J3Mgc3RyaWN0bHlcbiAgICogKGA9PT1gKSBlcXVhbCB0byB0aGF0IGVycm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpO1xuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KGVycik7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhIHN0cmluZywgYC50aHJvd2AgaW52b2tlcyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHdpdGggYSBtZXNzYWdlIHRoYXRcbiAgICogY29udGFpbnMgdGhhdCBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdygnc2FsbW9uJyk7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgYC50aHJvd2BcbiAgICogaW52b2tlcyB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHdpdGggYVxuICAgKiBtZXNzYWdlIHRoYXQgbWF0Y2hlcyB0aGF0IHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KC9zYWxtb24vKTtcbiAgICpcbiAgICogV2hlbiB0d28gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYW5kIHRoZSBmaXJzdCBpcyBhbiBlcnJvciBpbnN0YW5jZSBvclxuICAgKiBjb25zdHJ1Y3RvciwgYW5kIHRoZSBzZWNvbmQgaXMgYSBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uLCBgLnRocm93YFxuICAgKiBpbnZva2VzIHRoZSBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB0aGF0IGZ1bGZpbGxzIGJvdGhcbiAgICogY29uZGl0aW9ucyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7XG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yLCAnc2FsbW9uJyk7XG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvciwgL3NhbG1vbi8pO1xuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhlcnIsICdzYWxtb24nKTtcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coZXJyLCAvc2FsbW9uLyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAudGhyb3dgLlxuICAgKlxuICAgKiAgICAgdmFyIGdvb2RGbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KCk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGl0J3MgZGFuZ2Vyb3VzIHRvIG5lZ2F0ZSBgLnRocm93YCB3aGVuIHByb3ZpZGluZyBhbnkgYXJndW1lbnRzLlxuICAgKiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucyBieSBhc3NlcnRpbmcgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGVpdGhlciBkb2Vzbid0IHRocm93IGFuIGVycm9yLCBvciB0aGF0IGl0IHRocm93cyBhbiBlcnJvciBidXQgb2YgYVxuICAgKiBkaWZmZXJlbnQgdHlwZSB0aGFuIHRoZSBnaXZlbiB0eXBlLCBvciB0aGF0IGl0IHRocm93cyBhbiBlcnJvciBvZiB0aGUgZ2l2ZW5cbiAgICogdHlwZSBidXQgd2l0aCBhIG1lc3NhZ2UgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhlIGdpdmVuIHN0cmluZy4gSXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhblxuICAgKiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpc24ndCBleHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICB2YXIgZ29vZEZuID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdyhSZWZlcmVuY2VFcnJvciwgJ3gnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiB0aGF0IHRoZSBlcnJvciBpcyBvZiBpdHMgZXhwZWN0ZWQgdHlwZSwgYW5kIGhhcyBhIG1lc3NhZ2UgdGhhdCBpbmNsdWRlcyBhblxuICAgKiBleHBlY3RlZCBzdHJpbmcsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0IGRvZXNuJ3QgaGF2ZSBvbmUgb2YgbWFueVxuICAgKiB1bmV4cGVjdGVkIHR5cGVzLCBhbmQgZG9lc24ndCBoYXZlIGEgbWVzc2FnZSB0aGF0IGluY2x1ZGVzIHNvbWUgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yLCAnc2FsbW9uJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLm5vdC50aHJvdyhSZWZlcmVuY2VFcnJvciwgJ3gnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAudGhyb3dgIGNoYW5nZXMgdGhlIHRhcmdldCBvZiBhbnkgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG9cbiAgICogYmUgdGhlIGVycm9yIG9iamVjdCB0aGF0J3MgdGhyb3duLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpO1xuICAgKiAgICAgZXJyLmNvZGUgPSA0MjtcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IpLndpdGgucHJvcGVydHkoJ2NvZGUnLCA0Mik7XG4gICAqXG4gICAqIGAudGhyb3dgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIGFsd2F5cyB1c2VcbiAgICogdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgdmFyIGdvb2RGbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8udGhyb3coVHlwZUVycm9yLCAneCcsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChnb29kRm4sICdub29vIHdoeSBmYWlsPz8nKS50by50aHJvdygpO1xuICAgKlxuICAgKiBEdWUgdG8gbGltaXRhdGlvbnMgaW4gRVM1LCBgLnRocm93YCBtYXkgbm90IGFsd2F5cyB3b3JrIGFzIGV4cGVjdGVkIHdoZW5cbiAgICogdXNpbmcgYSB0cmFuc3BpbGVyIHN1Y2ggYXMgQmFiZWwgb3IgVHlwZVNjcmlwdC4gSW4gcGFydGljdWxhciwgaXQgbWF5XG4gICAqIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzIHdoZW4gc3ViY2xhc3NpbmcgdGhlIGJ1aWx0LWluIGBFcnJvcmAgb2JqZWN0IGFuZFxuICAgKiB0aGVuIHBhc3NpbmcgdGhlIHN1YmNsYXNzZWQgY29uc3RydWN0b3IgdG8gYC50aHJvd2AuIFNlZSB5b3VyIHRyYW5zcGlsZXInc1xuICAgKiBkb2NzIGZvciBkZXRhaWxzOlxuICAgKlxuICAgKiAtIChbQmFiZWxdKGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL3VzYWdlL2NhdmVhdHMvI2NsYXNzZXMpKVxuICAgKiAtIChbVHlwZVNjcmlwdF0oaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvQnJlYWtpbmctQ2hhbmdlcyNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmspKVxuICAgKlxuICAgKiBCZXdhcmUgb2Ygc29tZSBjb21tb24gbWlzdGFrZXMgd2hlbiB1c2luZyB0aGUgYHRocm93YCBhc3NlcnRpb24uIE9uZSBjb21tb25cbiAgICogbWlzdGFrZSBpcyB0byBhY2NpZGVudGFsbHkgaW52b2tlIHRoZSBmdW5jdGlvbiB5b3Vyc2VsZiBpbnN0ZWFkIG9mIGxldHRpbmdcbiAgICogdGhlIGB0aHJvd2AgYXNzZXJ0aW9uIGludm9rZSB0aGUgZnVuY3Rpb24gZm9yIHlvdS4gRm9yIGV4YW1wbGUsIHdoZW5cbiAgICogdGVzdGluZyBpZiBhIGZ1bmN0aW9uIG5hbWVkIGBmbmAgdGhyb3dzLCBwcm92aWRlIGBmbmAgaW5zdGVhZCBvZiBgZm4oKWAgYXNcbiAgICogdGhlIHRhcmdldCBmb3IgdGhlIGFzc2VydGlvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coKTsgICAgIC8vIEdvb2QhIFRlc3RzIGBmbmAgYXMgZGVzaXJlZFxuICAgKiAgICAgZXhwZWN0KGZuKCkpLnRvLnRocm93KCk7ICAgLy8gQmFkISBUZXN0cyByZXN1bHQgb2YgYGZuKClgLCBub3QgYGZuYFxuICAgKlxuICAgKiBJZiB5b3UgbmVlZCB0byBhc3NlcnQgdGhhdCB5b3VyIGZ1bmN0aW9uIGBmbmAgdGhyb3dzIHdoZW4gcGFzc2VkIGNlcnRhaW5cbiAgICogYXJndW1lbnRzLCB0aGVuIHdyYXAgYSBjYWxsIHRvIGBmbmAgaW5zaWRlIG9mIGFub3RoZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoZnVuY3Rpb24gKCkgeyBmbig0Mik7IH0pLnRvLnRocm93KCk7ICAvLyBGdW5jdGlvbiBleHByZXNzaW9uXG4gICAqICAgICBleHBlY3QoKCkgPT4gZm4oNDIpKS50by50aHJvdygpOyAgICAgICAgICAgICAvLyBFUzYgYXJyb3cgZnVuY3Rpb25cbiAgICpcbiAgICogQW5vdGhlciBjb21tb24gbWlzdGFrZSBpcyB0byBwcm92aWRlIGFuIG9iamVjdCBtZXRob2QgKG9yIGFueSBzdGFuZC1hbG9uZVxuICAgKiBmdW5jdGlvbiB0aGF0IHJlbGllcyBvbiBgdGhpc2ApIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGFzc2VydGlvbi4gRG9pbmcgc28gaXNcbiAgICogcHJvYmxlbWF0aWMgYmVjYXVzZSB0aGUgYHRoaXNgIGNvbnRleHQgd2lsbCBiZSBsb3N0IHdoZW4gdGhlIGZ1bmN0aW9uIGlzXG4gICAqIGludm9rZWQgYnkgYC50aHJvd2A7IHRoZXJlJ3Mgbm8gd2F5IGZvciBpdCB0byBrbm93IHdoYXQgYHRoaXNgIGlzIHN1cHBvc2VkXG4gICAqIHRvIGJlLiBUaGVyZSBhcmUgdHdvIHdheXMgYXJvdW5kIHRoaXMgcHJvYmxlbS4gT25lIHNvbHV0aW9uIGlzIHRvIHdyYXAgdGhlXG4gICAqIG1ldGhvZCBvciBmdW5jdGlvbiBjYWxsIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uLiBBbm90aGVyIHNvbHV0aW9uIGlzIHRvXG4gICAqIHVzZSBgYmluZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZnVuY3Rpb24gKCkgeyBjYXQubWVvdygpOyB9KS50by50aHJvdygpOyAgLy8gRnVuY3Rpb24gZXhwcmVzc2lvblxuICAgKiAgICAgZXhwZWN0KCgpID0+IGNhdC5tZW93KCkpLnRvLnRocm93KCk7ICAgICAgICAgICAgIC8vIEVTNiBhcnJvdyBmdW5jdGlvblxuICAgKiAgICAgZXhwZWN0KGNhdC5tZW93LmJpbmQoY2F0KSkudG8udGhyb3coKTsgICAgICAgICAgIC8vIEJpbmRcbiAgICpcbiAgICogRmluYWxseSwgaXQncyB3b3J0aCBtZW50aW9uaW5nIHRoYXQgaXQncyBhIGJlc3QgcHJhY3RpY2UgaW4gSmF2YVNjcmlwdCB0b1xuICAgKiBvbmx5IHRocm93IGBFcnJvcmAgYW5kIGRlcml2YXRpdmVzIG9mIGBFcnJvcmAgc3VjaCBhcyBgUmVmZXJlbmNlRXJyb3JgLFxuICAgKiBgVHlwZUVycm9yYCwgYW5kIHVzZXItZGVmaW5lZCBvYmplY3RzIHRoYXQgZXh0ZW5kIGBFcnJvcmAuIE5vIG90aGVyIHR5cGUgb2ZcbiAgICogdmFsdWUgd2lsbCBnZW5lcmF0ZSBhIHN0YWNrIHRyYWNlIHdoZW4gaW5pdGlhbGl6ZWQuIFdpdGggdGhhdCBzYWlkLCB0aGVcbiAgICogYHRocm93YCBhc3NlcnRpb24gZG9lcyB0ZWNobmljYWxseSBzdXBwb3J0IGFueSB0eXBlIG9mIHZhbHVlIGJlaW5nIHRocm93bixcbiAgICogbm90IGp1c3QgYEVycm9yYCBhbmQgaXRzIGRlcml2YXRpdmVzLlxuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLnRocm93c2AgYW5kIGAuVGhyb3dgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAudGhyb3dgLlxuICAgKlxuICAgKiBAbmFtZSB0aHJvd1xuICAgKiBAYWxpYXMgdGhyb3dzXG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGVyck1zZ01hdGNoZXIgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAcmV0dXJucyBlcnJvciBmb3IgY2hhaW5pbmcgKG51bGwgaWYgbm8gZXJyb3IpXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydFRocm93cyAoZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpIHx8IGZhbHNlO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0eXBlb2YgZXJyb3JMaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyTXNnTWF0Y2hlciA9IGVycm9yTGlrZTtcbiAgICAgIGVycm9yTGlrZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNhdWdodEVycjtcbiAgICB0cnkge1xuICAgICAgb2JqKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYXVnaHRFcnIgPSBlcnI7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB0aGUgbmVnYXRlIGZsYWcgZW5hYmxlZCBhbmQgYXQgbGVhc3Qgb25lIHZhbGlkIGFyZ3VtZW50IGl0IG1lYW5zIHdlIGRvIGV4cGVjdCBhbiBlcnJvclxuICAgIC8vIGJ1dCB3ZSB3YW50IGl0IHRvIG1hdGNoIGEgZ2l2ZW4gc2V0IG9mIGNyaXRlcmlhXG4gICAgdmFyIGV2ZXJ5QXJnSXNVbmRlZmluZWQgPSBlcnJvckxpa2UgPT09IHVuZGVmaW5lZCAmJiBlcnJNc2dNYXRjaGVyID09PSB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB3ZSd2ZSBnb3QgdGhlIG5lZ2F0ZSBmbGFnIGVuYWJsZWQgYW5kIGJvdGggYXJncywgd2Ugc2hvdWxkIG9ubHkgZmFpbCBpZiBib3RoIGFyZW4ndCBjb21wYXRpYmxlXG4gICAgLy8gU2VlIElzc3VlICM1NTEgYW5kIFBSICM2ODNAR2l0SHViXG4gICAgdmFyIGV2ZXJ5QXJnSXNEZWZpbmVkID0gQm9vbGVhbihlcnJvckxpa2UgJiYgZXJyTXNnTWF0Y2hlcik7XG4gICAgdmFyIGVycm9yTGlrZUZhaWwgPSBmYWxzZTtcbiAgICB2YXIgZXJyTXNnTWF0Y2hlckZhaWwgPSBmYWxzZTtcblxuICAgIC8vIENoZWNraW5nIGlmIGVycm9yIHdhcyB0aHJvd25cbiAgICBpZiAoZXZlcnlBcmdJc1VuZGVmaW5lZCB8fCAhZXZlcnlBcmdJc1VuZGVmaW5lZCAmJiAhbmVnYXRlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRoaXMgdG8gZGlzcGxheSByZXN1bHRzIGNvcnJlY3RseSBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZXNcbiAgICAgIHZhciBlcnJvckxpa2VTdHJpbmcgPSAnYW4gZXJyb3InO1xuICAgICAgaWYgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVycm9yTGlrZVN0cmluZyA9ICcje2V4cH0nO1xuICAgICAgfSBlbHNlIGlmIChlcnJvckxpa2UpIHtcbiAgICAgICAgZXJyb3JMaWtlU3RyaW5nID0gXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShlcnJvckxpa2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBjYXVnaHRFcnJcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAnICsgZXJyb3JMaWtlU3RyaW5nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93IGFuIGVycm9yIGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgLCBlcnJvckxpa2UgJiYgZXJyb3JMaWtlLnRvU3RyaW5nKClcbiAgICAgICAgLCAoY2F1Z2h0RXJyIGluc3RhbmNlb2YgRXJyb3IgP1xuICAgICAgICAgICAgY2F1Z2h0RXJyLnRvU3RyaW5nKCkgOiAodHlwZW9mIGNhdWdodEVyciA9PT0gJ3N0cmluZycgPyBjYXVnaHRFcnIgOiBjYXVnaHRFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoY2F1Z2h0RXJyKSkpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlcnJvckxpa2UgJiYgY2F1Z2h0RXJyKSB7XG4gICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSBpbnN0YW5jZXMgb25seSBpZiBgZXJyb3JMaWtlYCBpcyBhbiBpbnN0YW5jZSBvZiBgRXJyb3JgXG4gICAgICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdmFyIGlzQ29tcGF0aWJsZUluc3RhbmNlID0gXy5jaGVja0Vycm9yLmNvbXBhdGlibGVJbnN0YW5jZShjYXVnaHRFcnIsIGVycm9yTGlrZSk7XG5cbiAgICAgICAgaWYgKGlzQ29tcGF0aWJsZUluc3RhbmNlID09PSBuZWdhdGUpIHtcbiAgICAgICAgICAvLyBUaGVzZSBjaGVja3Mgd2VyZSBjcmVhdGVkIHRvIGVuc3VyZSB3ZSB3b24ndCBmYWlsIHRvbyBzb29uIHdoZW4gd2UndmUgZ290IGJvdGggYXJncyBhbmQgYSBuZWdhdGVcbiAgICAgICAgICAvLyBTZWUgSXNzdWUgIzU1MSBhbmQgUFIgIzY4M0BHaXRIdWJcbiAgICAgICAgICBpZiAoZXZlcnlBcmdJc0RlZmluZWQgJiYgbmVnYXRlKSB7XG4gICAgICAgICAgICBlcnJvckxpa2VGYWlsID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICAgICAgbmVnYXRlXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9JyArIChjYXVnaHRFcnIgJiYgIW5lZ2F0ZSA/ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJyA6ICcnKVxuICAgICAgICAgICAgICAsIGVycm9yTGlrZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICwgY2F1Z2h0RXJyLnRvU3RyaW5nKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NvbXBhdGlibGVDb25zdHJ1Y3RvciA9IF8uY2hlY2tFcnJvci5jb21wYXRpYmxlQ29uc3RydWN0b3IoY2F1Z2h0RXJyLCBlcnJvckxpa2UpO1xuICAgICAgaWYgKGlzQ29tcGF0aWJsZUNvbnN0cnVjdG9yID09PSBuZWdhdGUpIHtcbiAgICAgICAgaWYgKGV2ZXJ5QXJnSXNEZWZpbmVkICYmIG5lZ2F0ZSkge1xuICAgICAgICAgICAgZXJyb3JMaWtlRmFpbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICAgIG5lZ2F0ZVxuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9JyArIChjYXVnaHRFcnIgPyAnIGJ1dCAje2FjdH0gd2FzIHRocm93bicgOiAnJylcbiAgICAgICAgICAgICwgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3JMaWtlLnRvU3RyaW5nKCkgOiBlcnJvckxpa2UgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShlcnJvckxpa2UpKVxuICAgICAgICAgICAgLCAoY2F1Z2h0RXJyIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVnaHRFcnIudG9TdHJpbmcoKSA6IGNhdWdodEVyciAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGNhdWdodEVycikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYXVnaHRFcnIgJiYgZXJyTXNnTWF0Y2hlciAhPT0gdW5kZWZpbmVkICYmIGVyck1zZ01hdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIEhlcmUgd2UgY2hlY2sgY29tcGF0aWJsZSBtZXNzYWdlc1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gJ2luY2x1ZGluZyc7XG4gICAgICBpZiAoZXJyTXNnTWF0Y2hlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBwbGFjZWhvbGRlciA9ICdtYXRjaGluZydcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQ29tcGF0aWJsZU1lc3NhZ2UgPSBfLmNoZWNrRXJyb3IuY29tcGF0aWJsZU1lc3NhZ2UoY2F1Z2h0RXJyLCBlcnJNc2dNYXRjaGVyKTtcbiAgICAgIGlmIChpc0NvbXBhdGlibGVNZXNzYWdlID09PSBuZWdhdGUpIHtcbiAgICAgICAgaWYgKGV2ZXJ5QXJnSXNEZWZpbmVkICYmIG5lZ2F0ZSkge1xuICAgICAgICAgICAgZXJyTXNnTWF0Y2hlckZhaWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgbmVnYXRlXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yICcgKyBwbGFjZWhvbGRlciArICcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBub3QgJyArIHBsYWNlaG9sZGVyICsgJyAje2V4cH0nXG4gICAgICAgICAgICAsICBlcnJNc2dNYXRjaGVyXG4gICAgICAgICAgICAsICBfLmNoZWNrRXJyb3IuZ2V0TWVzc2FnZShjYXVnaHRFcnIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGJvdGggYXNzZXJ0aW9ucyBmYWlsZWQgYW5kIGJvdGggc2hvdWxkJ3ZlIG1hdGNoZWQgd2UgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoZXJyb3JMaWtlRmFpbCAmJiBlcnJNc2dNYXRjaGVyRmFpbCkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG5lZ2F0ZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfScgKyAoY2F1Z2h0RXJyID8gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nIDogJycpXG4gICAgICAgICwgKGVycm9yTGlrZSBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3JMaWtlLnRvU3RyaW5nKCkgOiBlcnJvckxpa2UgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShlcnJvckxpa2UpKVxuICAgICAgICAsIChjYXVnaHRFcnIgaW5zdGFuY2VvZiBFcnJvciA/IGNhdWdodEVyci50b1N0cmluZygpIDogY2F1Z2h0RXJyICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoY2F1Z2h0RXJyKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgY2F1Z2h0RXJyKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvdycsIGFzc2VydFRocm93cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93cycsIGFzc2VydFRocm93cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ1Rocm93JywgYXNzZXJ0VGhyb3dzKTtcblxuICAvKipcbiAgICogIyMjIC5yZXNwb25kVG8obWV0aG9kWywgbXNnXSlcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgbm9uLWZ1bmN0aW9uIG9iamVjdCwgYC5yZXNwb25kVG9gIGFzc2VydHMgdGhhdCB0aGVcbiAgICogdGFyZ2V0IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGBtZXRob2RgLiBUaGUgbWV0aG9kIGNhbiBiZSBvd24gb3JcbiAgICogaW5oZXJpdGVkLCBhbmQgaXQgY2FuIGJlIGVudW1lcmFibGUgb3Igbm9uLWVudW1lcmFibGUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBDYXQoKSkudG8ucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIGZ1bmN0aW9uLCBgLnJlc3BvbmRUb2AgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQnc1xuICAgKiBgcHJvdG90eXBlYCBwcm9wZXJ0eSBoYXMgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBgbWV0aG9kYC4gQWdhaW4sIHRoZVxuICAgKiBtZXRob2QgY2FuIGJlIG93biBvciBpbmhlcml0ZWQsIGFuZCBpdCBjYW4gYmUgZW51bWVyYWJsZSBvciBub24tZW51bWVyYWJsZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2F0KS50by5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogQWRkIGAuaXRzZWxmYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBmb3JjZSBgLnJlc3BvbmRUb2AgdG8gdHJlYXQgdGhlXG4gICAqIHRhcmdldCBhcyBhIG5vbi1mdW5jdGlvbiBvYmplY3QsIGV2ZW4gaWYgaXQncyBhIGZ1bmN0aW9uLiBUaHVzLCBpdCBhc3NlcnRzXG4gICAqIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBgbWV0aG9kYCwgcmF0aGVyIHRoYW5cbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCdzIGBwcm90b3R5cGVgIHByb3BlcnR5IGhhcyBhIG1ldGhvZCB3aXRoIHRoZVxuICAgKiBnaXZlbiBuYW1lIGBtZXRob2RgLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICogICAgIENhdC5oaXNzID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2F0KS5pdHNlbGYudG8ucmVzcG9uZFRvKCdoaXNzJykuYnV0Lm5vdC5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogV2hlbiBub3QgYWRkaW5nIGAuaXRzZWxmYCwgaXQncyBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlXG4gICAqIHVzaW5nIGAucmVzcG9uZFRvYC4gU2VlIHRoZSBgLmFgIGRvYyBmb3IgaW5mbyBvbiBjaGVja2luZyBhIHRhcmdldCdzIHR5cGUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBDYXQoKSkudG8uYmUuYW4oJ29iamVjdCcpLnRoYXQucmVzcG9uZHNUbygnbWVvdycpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnJlc3BvbmRUb2AuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBEb2cgKCkge31cbiAgICogICAgIERvZy5wcm90b3R5cGUuYmFyayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5ldyBEb2coKSkudG8ubm90LnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBgLnJlc3BvbmRUb2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9KS50by5yZXNwb25kVG8oJ21lb3cnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3Qoe30sICdub29vIHdoeSBmYWlsPz8nKS50by5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAucmVzcG9uZHNUb2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5yZXNwb25kVG9gLlxuICAgKlxuICAgKiBAbmFtZSByZXNwb25kVG9cbiAgICogQGFsaWFzIHJlc3BvbmRzVG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVzcG9uZFRvIChtZXRob2QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBpdHNlbGYgPSBmbGFnKHRoaXMsICdpdHNlbGYnKVxuICAgICAgLCBjb250ZXh0ID0gKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvYmogJiYgIWl0c2VsZilcbiAgICAgICAgPyBvYmoucHJvdG90eXBlW21ldGhvZF1cbiAgICAgICAgOiBvYmpbbWV0aG9kXTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udGV4dFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZFRvJywgcmVzcG9uZFRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZHNUbycsIHJlc3BvbmRUbyk7XG5cbiAgLyoqXG4gICAqICMjIyAuaXRzZWxmXG4gICAqXG4gICAqIEZvcmNlcyBhbGwgYC5yZXNwb25kVG9gIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIGJlaGF2ZSBhcyBpZlxuICAgKiB0aGUgdGFyZ2V0IGlzIGEgbm9uLWZ1bmN0aW9uIG9iamVjdCwgZXZlbiBpZiBpdCdzIGEgZnVuY3Rpb24uIFRodXMsIGl0XG4gICAqIGNhdXNlcyBgLnJlc3BvbmRUb2AgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBoYXMgYSBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW5cbiAgICogbmFtZSwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCdzIGBwcm90b3R5cGVgIHByb3BlcnR5IGhhcyBhXG4gICAqIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICogICAgIENhdC5oaXNzID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2F0KS5pdHNlbGYudG8ucmVzcG9uZFRvKCdoaXNzJykuYnV0Lm5vdC5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogQG5hbWUgaXRzZWxmXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnaXRzZWxmJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2l0c2VsZicsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zYXRpc2Z5KG1hdGNoZXJbLCBtc2ddKVxuICAgKlxuICAgKiBJbnZva2VzIHRoZSBnaXZlbiBgbWF0Y2hlcmAgZnVuY3Rpb24gd2l0aCB0aGUgdGFyZ2V0IGJlaW5nIHBhc3NlZCBhcyB0aGVcbiAgICogZmlyc3QgYXJndW1lbnQsIGFuZCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIHJldHVybmVkIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMDtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnNhdGlzZnlgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMjtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBgLnNhdGlzZnlgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMjtcbiAgICogICAgIH0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uc2F0aXNmeShmdW5jdGlvbihudW0pIHtcbiAgICogICAgICAgcmV0dXJuIG51bSA+IDI7XG4gICAqICAgICB9KTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuc2F0aXNmaWVzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLnNhdGlzZnlgLlxuICAgKlxuICAgKiBAbmFtZSBzYXRpc2Z5XG4gICAqIEBhbGlhcyBzYXRpc2ZpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gc2F0aXNmeSAobWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciByZXN1bHQgPSBtYXRjaGVyKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIGZsYWcodGhpcywgJ25lZ2F0ZScpID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2Z5Jywgc2F0aXNmeSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZmllcycsIHNhdGlzZnkpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgdGhhdCdzIHdpdGhpbiBhIGdpdmVuICsvLSBgZGVsdGFgIHJhbmdlXG4gICAqIG9mIHRoZSBnaXZlbiBudW1iZXIgYGV4cGVjdGVkYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZVxuICAgKiB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmVxdWFsKDEuNSk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMiwgMC41KTtcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuY2xvc2VUb2AuXG4gICAqXG4gICAqICAgICBleHBlY3QoMS41KS50by5lcXVhbCgxLjUpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8ubm90LmJlLmNsb3NlVG8oMywgMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmNsb3NlVG9gIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMywgMSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEuNSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmNsb3NlVG8oMywgMSk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmFwcHJveGltYXRlbHlgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuY2xvc2VUb2AuXG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQGFsaWFzIGFwcHJveGltYXRlbHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xvc2VUbyhleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRlbHRhICE9PSAnbnVtYmVyJykge1xuICAgICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAndGhlIGFyZ3VtZW50cyB0byBjbG9zZVRvIG9yIGFwcHJveGltYXRlbHkgbXVzdCBiZSBudW1iZXJzJyxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Nsb3NlVG8nLCBjbG9zZVRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYXBwcm94aW1hdGVseScsIGNsb3NlVG8pO1xuXG4gIC8vIE5vdGU6IER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgaWYgdGVzdGluZyBmb3IgaW5jbHVzaW9uIGluc3RlYWQgb2Ygc2FtZW5lc3MuXG4gIGZ1bmN0aW9uIGlzU3Vic2V0T2Yoc3Vic2V0LCBzdXBlcnNldCwgY21wLCBjb250YWlucywgb3JkZXJlZCkge1xuICAgIGlmICghY29udGFpbnMpIHtcbiAgICAgIGlmIChzdWJzZXQubGVuZ3RoICE9PSBzdXBlcnNldC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHN1cGVyc2V0ID0gc3VwZXJzZXQuc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic2V0LmV2ZXJ5KGZ1bmN0aW9uKGVsZW0sIGlkeCkge1xuICAgICAgaWYgKG9yZGVyZWQpIHJldHVybiBjbXAgPyBjbXAoZWxlbSwgc3VwZXJzZXRbaWR4XSkgOiBlbGVtID09PSBzdXBlcnNldFtpZHhdO1xuXG4gICAgICBpZiAoIWNtcCkge1xuICAgICAgICB2YXIgbWF0Y2hJZHggPSBzdXBlcnNldC5pbmRleE9mKGVsZW0pO1xuICAgICAgICBpZiAobWF0Y2hJZHggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG1hdGNoIGZyb20gc3VwZXJzZXQgc28gbm90IGNvdW50ZWQgdHdpY2UgaWYgZHVwbGljYXRlIGluIHN1YnNldC5cbiAgICAgICAgaWYgKCFjb250YWlucykgc3VwZXJzZXQuc3BsaWNlKG1hdGNoSWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlcnNldC5zb21lKGZ1bmN0aW9uKGVsZW0yLCBtYXRjaElkeCkge1xuICAgICAgICBpZiAoIWNtcChlbGVtLCBlbGVtMikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2ggZnJvbSBzdXBlcnNldCBzbyBub3QgY291bnRlZCB0d2ljZSBpZiBkdXBsaWNhdGUgaW4gc3Vic2V0LlxuICAgICAgICBpZiAoIWNvbnRhaW5zKSBzdXBlcnNldC5zcGxpY2UobWF0Y2hJZHgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubWVtYmVycyhzZXRbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBhcnJheSBoYXMgdGhlIHNhbWUgbWVtYmVycyBhcyB0aGUgZ2l2ZW4gYXJyYXlcbiAgICogYHNldGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm1lbWJlcnMoWzIsIDEsIDNdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgMl0pLnRvLmhhdmUubWVtYmVycyhbMiwgMSwgMl0pO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBtZW1iZXJzIGFyZSBjb21wYXJlZCB1c2luZyBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eS4gQWRkIGAuZGVlcGBcbiAgICogZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlIHRoZSBgZGVlcC1lcWxgXG4gICAqIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgbWVtYmVyIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmhhdmUuZGVlcC5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8ubm90LmhhdmUubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIG9yZGVyIGRvZXNuJ3QgbWF0dGVyLiBBZGQgYC5vcmRlcmVkYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0b1xuICAgKiByZXF1aXJlIHRoYXQgbWVtYmVycyBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm9yZGVyZWQubWVtYmVycyhbMSwgMiwgM10pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCAxLCAzXSlcbiAgICogICAgICAgLmJ1dC5ub3Qub3JkZXJlZC5tZW1iZXJzKFsyLCAxLCAzXSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGJvdGggYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgc2l6ZS4gQWRkIGAuaW5jbHVkZWAgZWFybGllciBpblxuICAgKiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQncyBtZW1iZXJzIGJlIGEgc3VwZXJzZXQgb2YgdGhlXG4gICAqIGV4cGVjdGVkIG1lbWJlcnMuIE5vdGUgdGhhdCBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGluIHRoZSBzdWJzZXQgd2hlblxuICAgKiBgLmluY2x1ZGVgIGlzIGFkZGVkLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGlzIGEgc3VwZXJzZXQgb2YgWzEsIDJdIGJ1dCBub3QgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzEsIDJdKTtcbiAgICpcbiAgICogICAgIC8vIER1cGxpY2F0ZXMgaW4gdGhlIHN1YnNldCBhcmUgaWdub3JlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5tZW1iZXJzKFsxLCAyLCAyLCAyXSk7XG4gICAqXG4gICAqIGAuZGVlcGAsIGAub3JkZXJlZGAsIGFuZCBgLmluY2x1ZGVgIGNhbiBhbGwgYmUgY29tYmluZWQuIEhvd2V2ZXIsIGlmXG4gICAqIGAuaW5jbHVkZWAgYW5kIGAub3JkZXJlZGAgYXJlIGNvbWJpbmVkLCB0aGUgb3JkZXJpbmcgYmVnaW5zIGF0IHRoZSBzdGFydCBvZlxuICAgKiBib3RoIGFycmF5cy5cbiAgICpcbiAgICogICAgIGV4cGVjdChbe2E6IDF9LCB7YjogMn0sIHtjOiAzfV0pXG4gICAqICAgICAgIC50by5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKFt7YTogMX0sIHtiOiAyfV0pXG4gICAqICAgICAgIC5idXQubm90LmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoW3tiOiAyfSwge2M6IDN9XSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubWVtYmVyc2AuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0IGFycmF5IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgdGhlIHNhbWUgbWVtYmVycyBhc1xuICAgKiB0aGUgZ2l2ZW4gYXJyYXkgYHNldGAgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgc29tZSBvZiB0aGVtLiBJdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuIGFzc2VydGlvblxuICAgKiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5pbmNsdWRlKDMpLmFuZC5ub3QuaW5jbHVkZSg0KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoWzMsIDRdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubWVtYmVyc2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUubWVtYmVycyhbMSwgMiwgM10pO1xuICAgKlxuICAgKiBAbmFtZSBtZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWVtYmVycycsIGZ1bmN0aW9uIChzdWJzZXQsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG5cbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG4gICAgbmV3IEFzc2VydGlvbihzdWJzZXQsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmJlLmFuKCdhcnJheScpO1xuXG4gICAgdmFyIGNvbnRhaW5zID0gZmxhZyh0aGlzLCAnY29udGFpbnMnKTtcbiAgICB2YXIgb3JkZXJlZCA9IGZsYWcodGhpcywgJ29yZGVyZWQnKTtcblxuICAgIHZhciBzdWJqZWN0LCBmYWlsTXNnLCBmYWlsTmVnYXRlTXNnO1xuXG4gICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICBzdWJqZWN0ID0gb3JkZXJlZCA/ICdhbiBvcmRlcmVkIHN1cGVyc2V0JyA6ICdhIHN1cGVyc2V0JztcbiAgICAgIGZhaWxNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgc3ViamVjdCArICcgb2YgI3tleHB9JztcbiAgICAgIGZhaWxOZWdhdGVNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgJyArIHN1YmplY3QgKyAnIG9mICN7ZXhwfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YmplY3QgPSBvcmRlcmVkID8gJ29yZGVyZWQgbWVtYmVycycgOiAnbWVtYmVycyc7XG4gICAgICBmYWlsTXNnID0gJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSB0aGUgc2FtZSAnICsgc3ViamVjdCArICcgYXMgI3tleHB9JztcbiAgICAgIGZhaWxOZWdhdGVNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSB0aGUgc2FtZSAnICsgc3ViamVjdCArICcgYXMgI3tleHB9JztcbiAgICB9XG5cbiAgICB2YXIgY21wID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gXy5lcWwgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wLCBjb250YWlucywgb3JkZXJlZClcbiAgICAgICwgZmFpbE1zZ1xuICAgICAgLCBmYWlsTmVnYXRlTXNnXG4gICAgICAsIHN1YnNldFxuICAgICAgLCBvYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9uZU9mKGxpc3RbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG1lbWJlciBvZiB0aGUgZ2l2ZW4gYXJyYXkgYGxpc3RgLiBIb3dldmVyLFxuICAgKiBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub25lT2YoWzEsIDIsIDNdKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIENvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgdXNpbmcgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAub25lT2ZgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5vbmVPZihbMiwgMywgNF0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5vbmVPZmAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9uZU9mKFsyLCAzLCA0XSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5vbmVPZihbMiwgMywgNF0pO1xuICAgKlxuICAgKiBAbmFtZSBvbmVPZlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBsaXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBvbmVPZiAobGlzdCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24obGlzdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbGlzdC5pbmRleE9mKGV4cGVjdGVkKSA+IC0xXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG9uZSBvZiAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBvbmUgb2YgI3tleHB9J1xuICAgICAgLCBsaXN0XG4gICAgICAsIGV4cGVjdGVkXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ29uZU9mJywgb25lT2YpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNoYW5nZShzdWJqZWN0WywgcHJvcFssIG1zZ11dKVxuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYC5jaGFuZ2VgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICogYHN1YmplY3RgIHJldHVybnMgYSBkaWZmZXJlbnQgdmFsdWUgd2hlbiBpdCdzIGludm9rZWQgYmVmb3JlIHRoZSB0YXJnZXRcbiAgICogZnVuY3Rpb24gY29tcGFyZWQgdG8gd2hlbiBpdCdzIGludm9rZWQgYWZ0ZXJ3YXJkLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgYHN1YmplY3RgIGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIHZhciBkb3RzID0gJydcbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IGRvdHMgKz0gJy4nOyB9XG4gICAqICAgICAgICwgZ2V0RG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdHM7IH07XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGdldERvdHMoKSkudG8uZXF1YWwoJycpO1xuICAgKiAgICAgYWRkRG90KCk7XG4gICAqICAgICBleHBlY3QoZ2V0RG90cygpKS50by5lcXVhbCgnLicpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkRG90KS50by5jaGFuZ2UoZ2V0RG90cyk7XG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAuY2hhbmdlYCBhc3NlcnRzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QgYHN1YmplY3RgJ3MgYHByb3BgIHByb3BlcnR5IGlzIGRpZmZlcmVudCBiZWZvcmUgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byBhZnRlcndhcmQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7ZG90czogJyd9XG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBteU9iai5kb3RzICs9ICcuJzsgfTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QobXlPYmopLnRvLmhhdmUucHJvcGVydHkoJ2RvdHMnLCAnJyk7XG4gICAqICAgICBhZGREb3QoKTtcbiAgICogICAgIGV4cGVjdChteU9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZG90cycsICcuJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGREb3QpLnRvLmNoYW5nZShteU9iaiwgJ2RvdHMnKTtcbiAgICpcbiAgICogU3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZCB0byBjb21wYXJlIGJlZm9yZSBhbmQgYWZ0ZXIgdmFsdWVzLlxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmNoYW5nZWAuXG4gICAqXG4gICAqICAgICB2YXIgZG90cyA9ICcnXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0RG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdHM7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShnZXREb3RzKTtcbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtkb3RzOiAnJ31cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ2RvdHMnKTtcbiAgICpcbiAgICogYC5jaGFuZ2VgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIGFsd2F5c1xuICAgKiB1c2UgdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge2RvdHM6ICcnfVxuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgbXlPYmouZG90cyArPSAnLic7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkRG90KS50by5ub3QuY2hhbmdlKG15T2JqLCAnZG90cycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciBkb3RzID0gJydcbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IGRvdHMgKz0gJy4nOyB9XG4gICAqICAgICAgICwgZ2V0RG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvdHM7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkRG90LCAnbm9vbyB3aHkgZmFpbD8/JykudG8ubm90LmNoYW5nZShnZXREb3RzKTtcbiAgICpcbiAgICogYC5jaGFuZ2VgIGFsc28gY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0b1xuICAgKiBhc3NlcnQgaG93IG11Y2ggYSBudW1lcmljIHN1YmplY3Qgd2FzIGluY3JlYXNlZCBvciBkZWNyZWFzZWQgYnkuIEhvd2V2ZXIsXG4gICAqIGl0J3MgZGFuZ2Vyb3VzIHRvIHVzZSBgLmNoYW5nZS5ieWAuIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlc1xuICAgKiB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBpbmNyZWFzZXMgYnlcbiAgICogdGhlIGdpdmVuIGRlbHRhLCBvciB0aGF0IGl0IGRlY3JlYXNlcyBieSB0aGUgZ2l2ZW4gZGVsdGEuIEl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uXG4gICAqIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5jaGFuZ2VzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmNoYW5nZWAuXG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZVxuICAgKiBAYWxpYXMgY2hhbmdlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3ViamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydENoYW5nZXMgKHN1YmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWw7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdFtwcm9wXTtcbiAgICB9XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgLy8gVGhpcyBnZXRzIGZsYWdnZWQgYmVjYXVzZSBvZiB0aGUgLmJ5KGRlbHRhKSBhc3NlcnRpb25cbiAgICBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicsIG1zZ09iaik7XG4gICAgZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnLCBpbml0aWFsKTtcbiAgICBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnLCBmaW5hbCk7XG4gICAgZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicsICdjaGFuZ2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBmaW5hbCAhPT0gaW5pdGlhbCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGluaXRpYWwgIT09IGZpbmFsXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBjaGFuZ2UnXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgY2hhbmdlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjaGFuZ2UnLCBhc3NlcnRDaGFuZ2VzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2hhbmdlcycsIGFzc2VydENoYW5nZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmluY3JlYXNlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAqIGBzdWJqZWN0YCByZXR1cm5zIGEgZ3JlYXRlciBudW1iZXIgd2hlbiBpdCdzIGludm9rZWQgYWZ0ZXIgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byB3aGVuIGl0J3MgaW52b2tlZCBiZWZvcmVoYW5kLiBgLmluY3JlYXNlYCBhbHNvXG4gICAqIGNhdXNlcyBhbGwgYC5ieWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IGhvdyBtdWNoXG4gICAqIGdyZWF0ZXIgb2YgYSBudW1iZXIgaXMgcmV0dXJuZWQuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcmV0dXJuXG4gICAqIHZhbHVlIGluY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgaXQgaW5jcmVhc2VkXG4gICAqIGJ5IGFueSBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgdmFsICs9IDI7IH1cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShnZXRWYWwpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UoZ2V0VmFsKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAuaW5jcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCBgc3ViamVjdGAncyBgcHJvcGAgcHJvcGVydHkgaXMgZ3JlYXRlciBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGJlZm9yZWhhbmQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuaW5jcmVhc2VgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGRlY3JlYXNlcywgb3IgdGhhdCBpdCBzdGF5cyB0aGUgc2FtZS5cbiAgICogSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlblxuICAgKiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gZGVjcmVhc2UsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCBpdFxuICAgKiBkZWNyZWFzZWQgYnkgdGhlIGV4cGVjdGVkIGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5ub3QuaW5jcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHN1YmplY3QgaXMgZXhwZWN0ZWQgdG8gc3RheSB0aGUgc2FtZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKG15T2JqLCAndmFsJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmluY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmluY3JlYXNlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuIFdoZW4gbm90IHByb3ZpZGluZyB0d28gYXJndW1lbnRzLCBhbHdheXNcbiAgICogdXNlIHRoZSBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgdmFyIHZhbCA9IDFcbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cbiAgICogICAgICAgLCBnZXRWYWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWw7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmluY3JlYXNlKGdldFZhbCk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmluY3JlYXNlc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5pbmNyZWFzZWAuXG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlXG4gICAqIEBhbGlhcyBpbmNyZWFzZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRJbmNyZWFzZXMgKHN1YmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluaXRpYWw7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHN1YmplY3QsIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgICBpbml0aWFsID0gc3ViamVjdFtwcm9wXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyXG4gICAgbmV3IEFzc2VydGlvbihpbml0aWFsLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdudW1iZXInKTtcblxuICAgIGZuKCk7XG5cbiAgICB2YXIgZmluYWwgPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IHN1YmplY3QoKSA6IHN1YmplY3RbcHJvcF07XG4gICAgdmFyIG1zZ09iaiA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gaW5pdGlhbCA6ICcuJyArIHByb3A7XG5cbiAgICBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicsIG1zZ09iaik7XG4gICAgZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnLCBpbml0aWFsKTtcbiAgICBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnLCBmaW5hbCk7XG4gICAgZmxhZyh0aGlzLCAnZGVsdGFCZWhhdmlvcicsICdpbmNyZWFzZScpO1xuICAgIGZsYWcodGhpcywgJ3JlYWxEZWx0YScsIGZpbmFsIC0gaW5pdGlhbCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGZpbmFsIC0gaW5pdGlhbCA+IDBcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIGluY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90IGluY3JlYXNlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbmNyZWFzZScsIGFzc2VydEluY3JlYXNlcyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luY3JlYXNlcycsIGFzc2VydEluY3JlYXNlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2Uoc3ViamVjdFssIHByb3BbLCBtc2ddXSlcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGAuZGVjcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICogYHN1YmplY3RgIHJldHVybnMgYSBsZXNzZXIgbnVtYmVyIHdoZW4gaXQncyBpbnZva2VkIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gd2hlbiBpdCdzIGludm9rZWQgYmVmb3JlaGFuZC4gYC5kZWNyZWFzZWAgYWxzb1xuICAgKiBjYXVzZXMgYWxsIGAuYnlgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvIGFzc2VydCBob3cgbXVjaFxuICAgKiBsZXNzZXIgb2YgYSBudW1iZXIgaXMgcmV0dXJuZWQuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgcmV0dXJuXG4gICAqIHZhbHVlIGRlY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgaXQgZGVjcmVhc2VkXG4gICAqIGJ5IGFueSBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyB2YWwgLT0gMjsgfVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UoZ2V0VmFsKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UoZ2V0VmFsKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdHdvIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGAuZGVjcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCBgc3ViamVjdGAncyBgcHJvcGAgcHJvcGVydHkgaXMgbGVzc2VyIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gYmVmb3JlaGFuZC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5kZWNyZWFzZWAuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgaW5jcmVhc2VzLCBvciB0aGF0IGl0IHN0YXlzIHRoZSBzYW1lLlxuICAgKiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuXG4gICAqIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgc3ViamVjdCBpcyBleHBlY3RlZCB0byBpbmNyZWFzZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IGl0XG4gICAqIGluY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLm5vdC5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgc3ViamVjdCBpcyBleHBlY3RlZCB0byBzdGF5IHRoZSBzYW1lLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UobXlPYmosICd2YWwnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuZGVjcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuZGVjcmVhc2VgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIGFsd2F5c1xuICAgKiB1c2UgdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8uZGVjcmVhc2UobXlPYmosICd2YWwnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uZGVjcmVhc2UoZ2V0VmFsKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuZGVjcmVhc2VzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmRlY3JlYXNlYC5cbiAgICpcbiAgICogQG5hbWUgZGVjcmVhc2VcbiAgICogQGFsaWFzIGRlY3JlYXNlc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc3ViamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydERlY3JlYXNlcyAoc3ViamVjdCwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGZuID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24oZm4sIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbDtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0W3Byb3BdO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXJcbiAgICBuZXcgQXNzZXJ0aW9uKGluaXRpYWwsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ251bWJlcicpO1xuXG4gICAgZm4oKTtcblxuICAgIHZhciBmaW5hbCA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gc3ViamVjdCgpIDogc3ViamVjdFtwcm9wXTtcbiAgICB2YXIgbXNnT2JqID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBpbml0aWFsIDogJy4nICsgcHJvcDtcblxuICAgIGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJywgbXNnT2JqKTtcbiAgICBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScsIGluaXRpYWwpO1xuICAgIGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScsIGZpbmFsKTtcbiAgICBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJywgJ2RlY3JlYXNlJyk7XG4gICAgZmxhZyh0aGlzLCAncmVhbERlbHRhJywgaW5pdGlhbCAtIGZpbmFsKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZmluYWwgLSBpbml0aWFsIDwgMFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gZGVjcmVhc2UnXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgZGVjcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2RlY3JlYXNlJywgYXNzZXJ0RGVjcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZGVjcmVhc2VzJywgYXNzZXJ0RGVjcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5ieShkZWx0YVssIG1zZ10pXG4gICAqXG4gICAqIFdoZW4gZm9sbG93aW5nIGFuIGAuaW5jcmVhc2VgIGFzc2VydGlvbiBpbiB0aGUgY2hhaW4sIGAuYnlgIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgc3ViamVjdCBvZiB0aGUgYC5pbmNyZWFzZWAgYXNzZXJ0aW9uIGluY3JlYXNlZCBieSB0aGUgZ2l2ZW4gYGRlbHRhYC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7XG4gICAqXG4gICAqIFdoZW4gZm9sbG93aW5nIGEgYC5kZWNyZWFzZWAgYXNzZXJ0aW9uIGluIHRoZSBjaGFpbiwgYC5ieWAgYXNzZXJ0cyB0aGF0IHRoZVxuICAgKiBzdWJqZWN0IG9mIHRoZSBgLmRlY3JlYXNlYCBhc3NlcnRpb24gZGVjcmVhc2VkIGJ5IHRoZSBnaXZlbiBgZGVsdGFgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7XG4gICAqXG4gICAqIFdoZW4gZm9sbG93aW5nIGEgYC5jaGFuZ2VgIGFzc2VydGlvbiBpbiB0aGUgY2hhaW4sIGAuYnlgIGFzc2VydHMgdGhhdCB0aGVcbiAgICogc3ViamVjdCBvZiB0aGUgYC5jaGFuZ2VgIGFzc2VydGlvbiBlaXRoZXIgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZCBieSB0aGVcbiAgICogZ2l2ZW4gYGRlbHRhYC4gSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gdXNlIGAuY2hhbmdlLmJ5YC4gVGhlIHByb2JsZW0gaXNcbiAgICogdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMuIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGVcbiAgICogZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzXG4gICAqIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9XG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCAtPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmNoYW5nZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmJ5YC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSBzdWJqZWN0IGNoYW5nZWQgYnkgaXRzIGV4cGVjdGVkIGRlbHRhLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCBpdCBkaWRuJ3QgY2hhbmdlIGJ5IG9uZSBvZiBjb3VudGxlc3MgdW5leHBlY3RlZCBkZWx0YXMuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5idXQubm90LmJ5KDMpO1xuICAgKlxuICAgKiBgLmJ5YCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG9cbiAgICogc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmRcbiAgICogYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDMsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdChhZGRUd28sICdub29vIHdoeSBmYWlsPz8nKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDMpO1xuICAgKlxuICAgKiBAbmFtZSBieVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydERlbHRhKGRlbHRhLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBtc2dPYmogPSBmbGFnKHRoaXMsICdkZWx0YU1zZ09iaicpO1xuICAgIHZhciBpbml0aWFsID0gZmxhZyh0aGlzLCAnaW5pdGlhbERlbHRhVmFsdWUnKTtcbiAgICB2YXIgZmluYWwgPSBmbGFnKHRoaXMsICdmaW5hbERlbHRhVmFsdWUnKTtcbiAgICB2YXIgYmVoYXZpb3IgPSBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJyk7XG4gICAgdmFyIHJlYWxEZWx0YSA9IGZsYWcodGhpcywgJ3JlYWxEZWx0YScpO1xuXG4gICAgdmFyIGV4cHJlc3Npb247XG4gICAgaWYgKGJlaGF2aW9yID09PSAnY2hhbmdlJykge1xuICAgICAgZXhwcmVzc2lvbiA9IE1hdGguYWJzKGZpbmFsIC0gaW5pdGlhbCkgPT09IE1hdGguYWJzKGRlbHRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwcmVzc2lvbiA9IHJlYWxEZWx0YSA9PT0gTWF0aC5hYnMoZGVsdGEpO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZXhwcmVzc2lvblxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gJyArIGJlaGF2aW9yICsgJyBieSAnICsgZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCAnICsgYmVoYXZpb3IgKyAnIGJ5ICcgKyBkZWx0YVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdieScsIGFzc2VydERlbHRhKTtcblxuICAvKipcbiAgICogIyMjIC5leHRlbnNpYmxlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGV4dGVuc2libGUsIHdoaWNoIG1lYW5zIHRoYXQgbmV3IHByb3BlcnRpZXMgY2FuXG4gICAqIGJlIGFkZGVkIHRvIGl0LiBQcmltaXRpdmVzIGFyZSBuZXZlciBleHRlbnNpYmxlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5leHRlbnNpYmxlYC5cbiAgICpcbiAgICogICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KVxuICAgKiAgICAgICAsIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KVxuICAgKiAgICAgICAsIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vbkV4dGVuc2libGVPYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KHNlYWxlZE9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZXh0ZW5zaWJsZTtcbiAgICpcbiAgICogQG5hbWUgZXh0ZW5zaWJsZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4dGVuc2libGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBhIHByaW1pdGl2ZSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBub24tZXh0ZW5zaWJsZSBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gZmFsc2UuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRXh0ZW5zaWJsZVxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIGZvciBFUzUgZW52aXJvbm1lbnRzLlxuXG4gICAgdmFyIGlzRXh0ZW5zaWJsZSA9IG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpc0V4dGVuc2libGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZXh0ZW5zaWJsZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGV4dGVuc2libGUnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuc2VhbGVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHNlYWxlZCwgd2hpY2ggbWVhbnMgdGhhdCBuZXcgcHJvcGVydGllcyBjYW4ndCBiZVxuICAgKiBhZGRlZCB0byBpdCwgYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbid0IGJlIHJlY29uZmlndXJlZCBvciBkZWxldGVkLlxuICAgKiBIb3dldmVyLCBpdCdzIHBvc3NpYmxlIHRoYXQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2FuIHN0aWxsIGJlIHJlYXNzaWduZWRcbiAgICogdG8gZGlmZmVyZW50IHZhbHVlcy4gUHJpbWl0aXZlcyBhcmUgYWx3YXlzIHNlYWxlZC5cbiAgICpcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoc2VhbGVkT2JqZWN0KS50by5iZS5zZWFsZWQ7XG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5zZWFsZWQ7XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuc2VhbGVkO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnNlYWxlZGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuc2VhbGVkO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnNlYWxlZDtcbiAgICpcbiAgICogQG5hbWUgc2VhbGVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnc2VhbGVkJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgYSBwcmltaXRpdmUsIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgc2VhbGVkIG9yZGluYXJ5IG9iamVjdCwgc2ltcGx5IHJldHVybiB0cnVlLlxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNTZWFsZWRcbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciBmb3IgRVM1IGVudmlyb25tZW50cy5cblxuICAgIHZhciBpc1NlYWxlZCA9IG9iaiA9PT0gT2JqZWN0KG9iaikgPyBPYmplY3QuaXNTZWFsZWQob2JqKSA6IHRydWU7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzU2VhbGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHNlYWxlZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIHNlYWxlZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mcm96ZW5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZnJvemVuLCB3aGljaCBtZWFucyB0aGF0IG5ldyBwcm9wZXJ0aWVzIGNhbid0IGJlXG4gICAqIGFkZGVkIHRvIGl0LCBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2FuJ3QgYmUgcmVhc3NpZ25lZCB0byBkaWZmZXJlbnRcbiAgICogdmFsdWVzLCByZWNvbmZpZ3VyZWQsIG9yIGRlbGV0ZWQuIFByaW1pdGl2ZXMgYXJlIGFsd2F5cyBmcm96ZW4uXG4gICAqXG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoZnJvemVuT2JqZWN0KS50by5iZS5mcm96ZW47XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuZnJvemVuO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmZyb3plbmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuZnJvemVuO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmZyb3plbjtcbiAgICpcbiAgICogQG5hbWUgZnJvemVuXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZnJvemVuJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgYSBwcmltaXRpdmUsIHRoZW4gaXQgd2lsbCBjYXVzZSBhIFR5cGVFcnJvci5cbiAgICAvLyBJbiBFUzYsIGEgbm9uLW9iamVjdCBhcmd1bWVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2FzIGEgZnJvemVuIG9yZGluYXJ5IG9iamVjdCwgc2ltcGx5IHJldHVybiB0cnVlLlxuICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNGcm96ZW5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3ZpZGVzIEVTNiBiZWhhdmlvciBmb3IgRVM1IGVudmlyb25tZW50cy5cblxuICAgIHZhciBpc0Zyb3plbiA9IG9iaiA9PT0gT2JqZWN0KG9iaikgPyBPYmplY3QuaXNGcm96ZW4ob2JqKSA6IHRydWU7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzRnJvemVuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZyb3plbidcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGZyb3plbidcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5maW5pdGVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIsIGFuZCBpc24ndCBgTmFOYCBvciBwb3NpdGl2ZS9uZWdhdGl2ZVxuICAgKiBgSW5maW5pdHlgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmZpbml0ZTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5maW5pdGVgLiBIb3dldmVyLCBpdCdzXG4gICAqIGRhbmdlcm91cyB0byBkbyBzby4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnNcbiAgICogYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGlzbid0IGEgbnVtYmVyLCBvciB0aGF0IGl0J3MgYE5hTmAsIG9yXG4gICAqIHRoYXQgaXQncyBwb3NpdGl2ZSBgSW5maW5pdHlgLCBvciB0aGF0IGl0J3MgbmVnYXRpdmUgYEluZmluaXR5YC4gSXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhblxuICAgKiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpc24ndCBleHBlY3RlZCB0byBiZSBhIG51bWJlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydFxuICAgKiB0aGF0IGl0J3MgdGhlIGV4cGVjdGVkIHR5cGUsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0IGlzbid0IG9uZSBvZlxuICAgKiBtYW55IHVuZXhwZWN0ZWQgdHlwZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmJlLmEoJ3N0cmluZycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuZmluaXRlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlIGBOYU5gLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHlcbiAgICogdGhhdC5cbiAgICpcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLmJlLk5hTjsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUgcG9zaXRpdmUgaW5maW5pdHksIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KEluZmluaXR5KS50by5lcXVhbChJbmZpbml0eSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoSW5maW5pdHkpLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUgbmVnYXRpdmUgaW5maW5pdHksIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KC1JbmZpbml0eSkudG8uZXF1YWwoLUluZmluaXR5KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgtSW5maW5pdHkpLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZmluaXRlO1xuICAgKlxuICAgKiBAbmFtZSBmaW5pdGVcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmaW5pdGUnLCBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhIGZpbml0ZSBudW1iZXInXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhIGZpbml0ZSBudW1iZXInXG4gICAgKTtcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICBjaGFpLmV4cGVjdCA9IGZ1bmN0aW9uICh2YWwsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGNoYWkuQXNzZXJ0aW9uKHZhbCwgbWVzc2FnZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChbbWVzc2FnZV0pXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICpcbiAgICogICAgIGV4cGVjdC5mYWlsKCk7XG4gICAqICAgICBleHBlY3QuZmFpbChcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoMSwgMik7XG4gICAqICAgICBleHBlY3QuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgKiAgICAgZXhwZWN0LmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiLCBcIj5cIik7XG4gICAqICAgICBleHBlY3QuZmFpbCgxLCAyLCB1bmRlZmluZWQsIFwiPlwiKTtcbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGNoYWkuZXhwZWN0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICAgICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdleHBlY3QuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBjaGFpLmV4cGVjdC5mYWlsKTtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICBmdW5jdGlvbiBsb2FkU2hvdWxkICgpIHtcbiAgICAvLyBleHBsaWNpdGx5IGRlZmluZSB0aGlzIG1ldGhvZCBhcyBmdW5jdGlvbiBhcyB0byBoYXZlIGl0J3MgbmFtZSB0byBpbmNsdWRlIGFzIGBzc2ZpYFxuICAgIGZ1bmN0aW9uIHNob3VsZEdldHRlcigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nXG4gICAgICAgICAgfHwgdGhpcyBpbnN0YW5jZW9mIE51bWJlclxuICAgICAgICAgIHx8IHRoaXMgaW5zdGFuY2VvZiBCb29sZWFuXG4gICAgICAgICAgfHwgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMudmFsdWVPZigpLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcywgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0dGVyKHZhbHVlKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgLy8gYHdoYXRldmVyLnNob3VsZCA9IHNvbWVWYWx1ZWAgYWN0dWFsbHkgc2V0IGBzb21lVmFsdWVgLCB3aGljaCBpc1xuICAgICAgLy8gZXNwZWNpYWxseSB1c2VmdWwgZm9yIGBnbG9iYWwuc2hvdWxkID0gcmVxdWlyZSgnY2hhaScpLnNob3VsZCgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byB1c2UgW1tEZWZpbmVQcm9wZXJ0eV1dIGluc3RlYWQgb2YgW1tQdXRdXVxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIHdlIHdvdWxkIHRyaWdnZXIgdGhpcyB2ZXJ5IHNldHRlciFcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtb2RpZnkgT2JqZWN0LnByb3RvdHlwZSB0byBoYXZlIGBzaG91bGRgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdzaG91bGQnLCB7XG4gICAgICBzZXQ6IHNob3VsZFNldHRlclxuICAgICAgLCBnZXQ6IHNob3VsZEdldHRlclxuICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBzaG91bGQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZmFpbChbbWVzc2FnZV0pXG4gICAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICAgKlxuICAgICAqIFRocm93IGEgZmFpbHVyZS5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQuZmFpbCgpO1xuICAgICAqICAgICBzaG91bGQuZmFpbChcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgICAqICAgICBzaG91bGQuZmFpbCgxLCAyKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiLCBcIj5cIik7XG4gICAgICogICAgIHNob3VsZC5mYWlsKDEsIDIsIHVuZGVmaW5lZCwgXCI+XCIpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBAbmFtZSBmYWlsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgICAqIEBuYW1lc3BhY2UgQkREXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgICAgICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ3Nob3VsZC5mYWlsKCknO1xuICAgICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgICB9LCBzaG91bGQuZmFpbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQuZXF1YWwoMywgJzMnLCAnPT0gY29lcmNlcyB2YWx1ZXMgdG8gc3RyaW5ncycpO1xuICAgICAqXG4gICAgICogQG5hbWUgZXF1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLnRocm93KGZ1bmN0aW9uLCBbY29uc3RydWN0b3Ivc3RyaW5nL3JlZ2V4cF0sIFtzdHJpbmcvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IGBmdW5jdGlvbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuIGluc3RhbmNlIG9mXG4gICAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgICAqXG4gICAgICogQG5hbWUgdGhyb3dcbiAgICAgKiBAYWxpYXMgVGhyb3dcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8uVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZXhpc3RcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqICAgICB2YXIgZm9vID0gJ2hpJztcbiAgICAgKlxuICAgICAqICAgICBzaG91bGQuZXhpc3QoZm9vLCAnZm9vIGV4aXN0cycpO1xuICAgICAqXG4gICAgICogQG5hbWUgZXhpc3RcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmV4aXN0O1xuICAgIH1cblxuICAgIC8vIG5lZ2F0aW9uXG4gICAgc2hvdWxkLm5vdCA9IHt9XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLm5vdC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgaW5lcXVhbGl0eSAoYCE9YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC5lcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QuZXF1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLm5vdC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5ub3QuZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAudGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIF9ub3RfIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QudGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC50aHJvd1xuICAgICAqIEBhbGlhcyBub3QuVGhyb3dcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLm5vdC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5ub3QuZXhpc3RcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqICAgICB2YXIgYmFyID0gbnVsbDtcbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LmV4aXN0KGJhciwgJ2JhciBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LmV4aXN0XG4gICAgICogQG5hbWVzcGFjZSBTaG91bGRcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLm5vdC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmV4aXN0O1xuICAgIH1cblxuICAgIHNob3VsZFsndGhyb3cnXSA9IHNob3VsZFsnVGhyb3cnXTtcbiAgICBzaG91bGQubm90Wyd0aHJvdyddID0gc2hvdWxkLm5vdFsnVGhyb3cnXTtcblxuICAgIHJldHVybiBzaG91bGQ7XG4gIH07XG5cbiAgY2hhaS5zaG91bGQgPSBsb2FkU2hvdWxkO1xuICBjaGFpLlNob3VsZCA9IGxvYWRTaG91bGQ7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICAvKiFcbiAgICogQ2hhaSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyBhc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSlcbiAgICpcbiAgICogV3JpdGUgeW91ciBvd24gdGVzdCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogICAgIGFzc2VydCgnZm9vJyAhPT0gJ2JhcicsICdmb28gaXMgbm90IGJhcicpO1xuICAgKiAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoW10pLCAnZW1wdHkgYXJyYXlzIGFyZSBhcnJheXMnKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwcmVzc2lvbiB0byB0ZXN0IGZvciB0cnV0aGluZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gZXJyb3JcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydCA9IGZ1bmN0aW9uIChleHByZXNzLCBlcnJtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24obnVsbCwgbnVsbCwgY2hhaS5hc3NlcnQsIHRydWUpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHByZXNzXG4gICAgICAsIGVycm1zZ1xuICAgICAgLCAnWyBuZWdhdGlvbiBtZXNzYWdlIHVuYXZhaWxhYmxlIF0nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKFttZXNzYWdlXSlcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLiBOb2RlLmpzIGBhc3NlcnRgIG1vZHVsZS1jb21wYXRpYmxlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmZhaWwoKTtcbiAgICogICAgIGFzc2VydC5mYWlsKFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIik7XG4gICAqICAgICBhc3NlcnQuZmFpbCgxLCAyKTtcbiAgICogICAgIGFzc2VydC5mYWlsKDEsIDIsIFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIik7XG4gICAqICAgICBhc3NlcnQuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIsIFwiPlwiKTtcbiAgICogICAgIGFzc2VydC5mYWlsKDEsIDIsIHVuZGVmaW5lZCwgXCI+XCIpO1xuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgLy8gQ29tcGx5IHdpdGggTm9kZSdzIGZhaWwoW21lc3NhZ2VdKSBpbnRlcmZhY2VcblxuICAgICAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgICAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2Fzc2VydC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGFzc2VydC5mYWlsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc09rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzT2soJ2V2ZXJ5dGhpbmcnLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0LmlzT2soZmFsc2UsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09rXG4gICAqIEBhbGlhcyBva1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc09rLCB0cnVlKS5pcy5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE9rKG9iamVjdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZmFsc3kuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RPaygnZXZlcnl0aGluZycsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2soZmFsc2UsICd0aGlzIHdpbGwgcGFzcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE9rXG4gICAqIEBhbGlhcyBub3RPa1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RPayA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE9rLCB0cnVlKS5pcy5ub3Qub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZXF1YWwsIHRydWUpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCA9PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgaW5lcXVhbGl0eSAoYCE9YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RXF1YWwoMywgNCwgJ3RoZXNlIG51bWJlcnMgYXJlIG5vdCBlcXVhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5ub3RFcXVhbCwgdHJ1ZSk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwICE9IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGVxdWFsaXR5IChgPT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgdHJ1ZSwgJ3RoZXNlIGJvb2xlYW5zIGFyZSBzdHJpY3RseSBlcXVhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuc3RyaWN0RXF1YWwsIHRydWUpLnRvLmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBpbmVxdWFsaXR5IChgIT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoMywgJzMnLCAnbm8gY29lcmNpb24gZm9yIHN0cmljdCBlcXVhbGl0eScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90U3RyaWN0RXF1YWwsIHRydWUpLnRvLm5vdC5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgYWN0dWFsYCBpcyBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdncmVlbicgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFsaWFzIGRlZXBTdHJpY3RFcXVhbFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcEVxdWFsID0gYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmRlZXBFcXVhbCwgdHJ1ZSkudG8uZXFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0IHRoYXQgYGFjdHVhbGAgaXMgbm90IGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2phc21pbmUnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5ub3REZWVwRXF1YWwsIHRydWUpLnRvLm5vdC5lcWwoZXhwKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNBYm92ZSh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUFib3ZlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuICg+KSBgdmFsdWVUb0JlQWJvdmVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQWJvdmUoNSwgMiwgJzUgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIDInKTtcbiAgICpcbiAgICogQG5hbWUgaXNBYm92ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQWJvdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQWJvdmUgPSBmdW5jdGlvbiAodmFsLCBhYnYsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Fib3ZlLCB0cnVlKS50by5iZS5hYm92ZShhYnYpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0F0TGVhc3QodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBdExlYXN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICg+PSkgYHZhbHVlVG9CZUF0TGVhc3RgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQXRMZWFzdCg1LCAyLCAnNSBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIDInKTtcbiAgICogICAgIGFzc2VydC5pc0F0TGVhc3QoMywgMywgJzMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byAzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXRMZWFzdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQXRMZWFzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBdExlYXN0ID0gZnVuY3Rpb24gKHZhbCwgYXRsc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0F0TGVhc3QsIHRydWUpLnRvLmJlLmxlYXN0KGF0bHN0KTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNCZWxvdyh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUJlbG93LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgc3RyaWN0bHkgbGVzcyB0aGFuICg8KSBgdmFsdWVUb0JlQmVsb3dgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQmVsb3coMywgNiwgJzMgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIDYnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCZWxvd1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQmVsb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQmVsb3cgPSBmdW5jdGlvbiAodmFsLCBibHcsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0JlbG93LCB0cnVlKS50by5iZS5iZWxvdyhibHcpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0F0TW9zdCh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUF0TW9zdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAoPD0pIGB2YWx1ZVRvQmVBdE1vc3RgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQXRNb3N0KDMsIDYsICczIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2Jyk7XG4gICAqICAgICBhc3NlcnQuaXNBdE1vc3QoNCwgNCwgJzQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNBdE1vc3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUF0TW9zdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBdE1vc3QgPSBmdW5jdGlvbiAodmFsLCBhdG1zdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQXRNb3N0LCB0cnVlKS50by5iZS5tb3N0KGF0bXN0KTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1RydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgdHJ1ZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSB0cnVlO1xuICAgKiAgICAgYXNzZXJ0LmlzVHJ1ZSh0ZWFTZXJ2ZWQsICd0aGUgdGVhIGhhcyBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1RydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc1RydWUsIHRydWUpLmlzWyd0cnVlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RUcnVlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdFRydWUodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RUcnVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFRydWUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RUcnVlLCB0cnVlKS50by5ub3QuZXF1YWwodHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGYWxzZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICogICAgIGFzc2VydC5pc0ZhbHNlKHRlYVNlcnZlZCwgJ25vIHRlYSB5ZXQ/IGhtbS4uLicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0ZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0ZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRmFsc2UsIHRydWUpLmlzWydmYWxzZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RmFsc2UodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdEZhbHNlKHRlYSwgJ2dyZWF0LCB0aW1lIGZvciB0ZWEhJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RGYWxzZSwgdHJ1ZSkudG8ubm90LmVxdWFsKGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbnVsbC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc051bGwoZXJyLCAndGhlcmUgd2FzIG5vIGVycm9yJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTnVsbCwgdHJ1ZSkudG8uZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBudWxsLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bGwodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3ROdWxsLCB0cnVlKS50by5ub3QuZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOYU5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHZhbHVlIGlzIE5hTi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05hTihOYU4sICdOYU4gaXMgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05hTiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05hTiwgdHJ1ZSkudG8uYmUuTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TmFOXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB2YWx1ZSBpcyBub3QgTmFOLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90TmFOKDQsICc0IGlzIG5vdCBOYU4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROYU5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGFzc2VydC5pc05vdE5hTiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE5hTiwgdHJ1ZSkubm90LnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIGZvbyA9ICdoaSc7XG4gICAqXG4gICAqICAgICBhc3NlcnQuZXhpc3RzKGZvbywgJ2ZvbyBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAnKTtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5leGlzdHMgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuZXhpc3RzLCB0cnVlKS50by5leGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RFeGlzdHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZWl0aGVyIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBiYXIgPSBudWxsXG4gICAqICAgICAgICwgYmF6O1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEV4aXN0cyhiYXIpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEV4aXN0cyhiYXosICdiYXogaXMgZWl0aGVyIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEV4aXN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RXhpc3RzID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lm5vdEV4aXN0cywgdHJ1ZSkudG8ubm90LmV4aXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVW5kZWZpbmVkKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYTtcbiAgICogICAgIGFzc2VydC5pc1VuZGVmaW5lZCh0ZWEsICdubyB0ZWEgZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc1VuZGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNVbmRlZmluZWQsIHRydWUpLnRvLmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNEZWZpbmVkKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAnY3VwIG9mIGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzRGVmaW5lZCh0ZWEsICd0ZWEgaGFzIGJlZW4gZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0RlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRGVmaW5lZCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0RlZmluZWQsIHRydWUpLnRvLm5vdC5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHNlcnZlVGVhKCkgeyByZXR1cm4gJ2N1cCBvZiB0ZWEnOyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzRnVuY3Rpb24oc2VydmVUZWEsICdncmVhdCwgd2UgY2FuIGhhdmUgdGVhIG5vdycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Z1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRnVuY3Rpb24sIHRydWUpLnRvLmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgdmFyIHNlcnZlVGVhID0gWyAnaGVhdCcsICdwb3VyJywgJ3NpcCcgXTtcbiAgICogICAgIGFzc2VydC5pc05vdEZ1bmN0aW9uKHNlcnZlVGVhLCAnZ3JlYXQsIHdlIGhhdmUgbGlzdGVkIHRoZSBzdGVwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90RnVuY3Rpb24sIHRydWUpLnRvLm5vdC5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKiBfVGhlIGFzc2VydGlvbiBkb2VzIG5vdCBtYXRjaCBzdWJjbGFzc2VkIG9iamVjdHMuX1xuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9IHsgbmFtZTogJ0NoYWknLCBzZXJ2ZTogJ3dpdGggc3BpY2VzJyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzT2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc09iamVjdCwgdHJ1ZSkudG8uYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gb2JqZWN0IG9mIHR5cGUgJ09iamVjdCcgKGFzIHJldmVhbGVkIGJ5IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCkuXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0gJ2NoYWknXG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3QobnVsbCwgJ251bGwgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE9iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RPYmplY3QsIHRydWUpLnRvLm5vdC5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0FycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSBbICdncmVlbicsICdjaGFpJywgJ29vbG9uZycgXTtcbiAgICogICAgIGFzc2VydC5pc0FycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBcnJheSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gJ2dyZWVufGNoYWl8b29sb25nJztcbiAgICogICAgIGFzc2VydC5pc05vdEFycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90QXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90QXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RBcnJheSwgdHJ1ZSkudG8ubm90LmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gJ2NoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzU3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzU3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc1N0cmluZywgdHJ1ZSkudG8uYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSA0O1xuICAgKiAgICAgYXNzZXJ0LmlzTm90U3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFN0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdFN0cmluZywgdHJ1ZSkudG8ubm90LmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAyO1xuICAgKiAgICAgYXNzZXJ0LmlzTnVtYmVyKGN1cHMsICdob3cgbWFueSBjdXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVtYmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOdW1iZXIsIHRydWUpLnRvLmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAnMiBjdXBzIHBsZWFzZSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdW1iZXJcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90TnVtYmVyLCB0cnVlKS50by5ub3QuYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzRmluaXRlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlci4gVW5saWtlIGAuaXNOdW1iZXJgLCB0aGlzIHdpbGwgZmFpbCBmb3IgYE5hTmAgYW5kIGBJbmZpbml0eWAuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9IDI7XG4gICAqICAgICBhc3NlcnQuaXNGaW5pdGUoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Zpbml0ZShOYU4pOyAvLyB0aHJvd3NcbiAgICpcbiAgICogQG5hbWUgaXNGaW5pdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0Zpbml0ZSwgdHJ1ZSkudG8uYmUuZmluaXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSB0cnVlXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQm9vbGVhbiwgdHJ1ZSkudG8uYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90Qm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSAneWVwJ1xuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9ICdub3BlJztcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEJvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RCb29sZWFuLCB0cnVlKS50by5ub3QuYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50eXBlT2YoeyB0ZWE6ICdjaGFpJyB9LCAnb2JqZWN0JywgJ3dlIGhhdmUgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKFsnY2hhaScsICdqYXNtaW5lJ10sICdhcnJheScsICd3ZSBoYXZlIGFuIGFycmF5Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKCd0ZWEnLCAnc3RyaW5nJywgJ3dlIGhhdmUgYSBzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoL3RlYS8sICdyZWdleHAnLCAnd2UgaGF2ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihudWxsLCAnbnVsbCcsICd3ZSBoYXZlIGEgbnVsbCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih1bmRlZmluZWQsICd1bmRlZmluZWQnLCAnd2UgaGF2ZSBhbiB1bmRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgdHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50eXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQudHlwZU9mLCB0cnVlKS50by5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgX25vdF8gYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RUeXBlT2YoJ3RlYScsICdudW1iZXInLCAnc3RyaW5ncyBhcmUgbm90IG51bWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90VHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlb2YgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90VHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lm5vdFR5cGVPZiwgdHJ1ZSkudG8ubm90LmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaW5zdGFuY2VPZiwgdHJ1ZSkudG8uYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgLlxuICAgKlxuICAgKiAgICAgdmFyIFRlYSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMubmFtZSA9IG5hbWU7IH1cbiAgICogICAgICAgLCBjaGFpID0gbmV3IFN0cmluZygnY2hhaScpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YoY2hhaSwgVGVhLCAnY2hhaSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5ub3RJbnN0YW5jZU9mLCB0cnVlKVxuICAgICAgLnRvLm5vdC5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBpbmNsdWRlcyBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZVxuICAgKiBpbmNsdXNpb24gb2YgYSB2YWx1ZSBpbiBhbiBhcnJheSwgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmcsIG9yIGEgc3Vic2V0IG9mXG4gICAqIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoWzEsMiwzXSwgMiwgJ2FycmF5IGNvbnRhaW5zIHZhbHVlJyk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSgnZm9vYmFyJywgJ2ZvbycsICdzdHJpbmcgY29udGFpbnMgc3Vic3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSh7IGZvbzogJ2JhcicsIGhlbGxvOiAndW5pdmVyc2UnIH0sIHsgZm9vOiAnYmFyJyB9LCAnb2JqZWN0IGNvbnRhaW5zIHByb3BlcnR5Jyk7XG4gICAqXG4gICAqIFN0cmljdCBlcXVhbGl0eSAoPT09KSBpcyB1c2VkLiBXaGVuIGFzc2VydGluZyB0aGUgaW5jbHVzaW9uIG9mIGEgdmFsdWUgaW5cbiAgICogYW4gYXJyYXksIHRoZSBhcnJheSBpcyBzZWFyY2hlZCBmb3IgYW4gZWxlbWVudCB0aGF0J3Mgc3RyaWN0bHkgZXF1YWwgdG8gdGhlXG4gICAqIGdpdmVuIHZhbHVlLiBXaGVuIGFzc2VydGluZyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdCwgdGhlIG9iamVjdFxuICAgKiBpcyBzZWFyY2hlZCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IGtleXMsIGNoZWNraW5nIHRoYXQgZWFjaCBvbmUgaXMgcHJlc2VudFxuICAgKiBhbmQgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbb2JqMSwgb2JqMl0sIG9iajEpO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzogb2JqMX0pO1xuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzogb2JqMSwgYmFyOiBvYmoyfSk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmluY2x1ZGUsIHRydWUpLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0XG4gICAqIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXksIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLCBvciBhIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFsxLDIsM10sIDQsIFwiYXJyYXkgZG9lc24ndCBjb250YWluIHZhbHVlXCIpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoJ2Zvb2JhcicsICdiYXonLCBcInN0cmluZyBkb2Vzbid0IGNvbnRhaW4gc3Vic3RyaW5nXCIpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9LCB7IGZvbzogJ2JheicgfSwgJ29iamVjdCBkb2Vzbid0IGNvbnRhaW4gcHJvcGVydHknKTtcbiAgICpcbiAgICogU3RyaWN0IGVxdWFsaXR5ICg9PT0pIGlzIHVzZWQuIFdoZW4gYXNzZXJ0aW5nIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWUgaW4gYW5cbiAgICogYXJyYXksIHRoZSBhcnJheSBpcyBzZWFyY2hlZCB0byBjb25maXJtIHRoZSBhYnNlbmNlIG9mIGFuIGVsZW1lbnQgdGhhdCdzXG4gICAqIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBnaXZlbiB2YWx1ZS4gV2hlbiBhc3NlcnRpbmcgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpblxuICAgKiBhbiBvYmplY3QsIHRoZSBvYmplY3QgaXMgc2VhcmNoZWQgdG8gY29uZmlybSB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW5cbiAgICogcHJvcGVydHkga2V5cyBpcyBlaXRoZXIgbm90IHByZXNlbnQgb3Igbm90IHN0cmljdGx5IGVxdWFsIHRvIHRoZSBnaXZlblxuICAgKiBwcm9wZXJ0eSB2YWx1ZS4gRm9yIGluc3RhbmNlOlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoW29iajEsIG9iajJdLCB7YTogMX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9fSk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiBvYmoxLCBiYXI6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RJbmNsdWRlLCB0cnVlKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGVcbiAgICogaW5jbHVzaW9uIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXkgb3IgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqIERlZXAgZXF1YWxpdHkgaXMgdXNlZC5cbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5kZWVwSW5jbHVkZShbb2JqMSwgb2JqMl0sIHthOiAxfSk7XG4gICAqICAgICBhc3NlcnQuZGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9fSk7XG4gICAqICAgICBhc3NlcnQuZGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9LCBiYXI6IHtiOiAyfX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwSW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwSW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmRlZXBJbmNsdWRlLCB0cnVlKS5kZWVwLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGRvZXMgbm90IGluY2x1ZGUgYG5lZWRsZWAuIENhbiBiZSB1c2VkIHRvIGFzc2VydFxuICAgKiB0aGUgYWJzZW5jZSBvZiBhIHZhbHVlIGluIGFuIGFycmF5IG9yIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgKiBEZWVwIGVxdWFsaXR5IGlzIHVzZWQuXG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQubm90RGVlcEluY2x1ZGUoW29iajEsIG9iajJdLCB7YTogOX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiA5fX0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IHthOiAxfSwgYmFyOiB7YjogOX19KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwSW5jbHVkZSwgdHJ1ZSkubm90LmRlZXAuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3QuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWRcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5uZXN0ZWRJbmNsdWRlKHsnLmEnOiB7J2InOiAneCd9fSwgeydcXFxcLmEuW2JdJzogJ3gnfSk7XG4gICAqICAgICBhc3NlcnQubmVzdGVkSW5jbHVkZSh7J2EnOiB7J1tiXSc6ICd4J319LCB7J2EuXFxcXFtiXFxcXF0nOiAneCd9KTtcbiAgICpcbiAgICogQG5hbWUgbmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubmVzdGVkSW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUsIHRydWUpLm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGRvZXMgbm90IGluY2x1ZGUgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdC5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUoeycuYSc6IHsnYic6ICd4J319LCB7J1xcXFwuYS5iJzogJ3knfSk7XG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkSW5jbHVkZSh7J2EnOiB7J1tiXSc6ICd4J319LCB7J2EuXFxcXFtiXFxcXF0nOiAneSd9KTtcbiAgICpcbiAgICogQG5hbWUgbm90TmVzdGVkSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TmVzdGVkSW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdE5lc3RlZEluY2x1ZGUsIHRydWUpXG4gICAgICAubm90Lm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgY2hlY2tpbmcgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWRcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSh7YToge2I6IFt7eDogMX1dfX0sIHsnYS5iWzBdJzoge3g6IDF9fSk7XG4gICAqICAgICBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUoeycuYSc6IHsnW2JdJzoge3g6IDF9fX0sIHsnXFxcXC5hLlxcXFxbYlxcXFxdJzoge3g6IDF9fSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBOZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuZGVlcE5lc3RlZEluY2x1ZGUsIHRydWUpXG4gICAgICAuZGVlcC5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBOZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgZG9lcyBub3QgaW5jbHVkZSAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBhYnNlbmNlIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUoe2E6IHtiOiBbe3g6IDF9XX19LCB7J2EuYlswXSc6IHt5OiAxfX0pXG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUoeycuYSc6IHsnW2JdJzoge3g6IDF9fX0sIHsnXFxcXC5hLlxcXFxbYlxcXFxdJzoge3k6IDJ9fSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBOZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90RGVlcE5lc3RlZEluY2x1ZGUsIHRydWUpXG4gICAgICAubm90LmRlZXAubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm93bkluY2x1ZGUoeyBhOiAxIH0sIHsgYTogMSB9KTtcbiAgICpcbiAgICogQG5hbWUgb3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQub3duSW5jbHVkZSwgdHJ1ZSkub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIE9iamVjdC5wcm90b3R5cGUuYiA9IDI7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90T3duSW5jbHVkZSh7IGE6IDEgfSwgeyBiOiAyIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3RPd25JbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RPd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RPd25JbmNsdWRlLCB0cnVlKS5ub3Qub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwT3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcyBhbmQgY2hlY2tpbmcgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAqXG4gICAqICAgICAgYXNzZXJ0LmRlZXBPd25JbmNsdWRlKHthOiB7YjogMn19LCB7YToge2I6IDJ9fSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBPd25JbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwT3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuZGVlcE93bkluY2x1ZGUsIHRydWUpXG4gICAgICAuZGVlcC5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5ub3REZWVwT3duSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMgYW5kIGNoZWNraW5nIGZvciBkZWVwIGVxdWFsaXR5LlxuICAgKlxuICAgKiAgICAgIGFzc2VydC5ub3REZWVwT3duSW5jbHVkZSh7YToge2I6IDJ9fSwge2E6IHtjOiAzfX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwT3duSW5jbHVkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcE93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdERlZXBPd25JbmNsdWRlLCB0cnVlKVxuICAgICAgLm5vdC5kZWVwLm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBtYXRjaGVzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubWF0Y2goJ2Zvb2JhcicsIC9eZm9vLywgJ3JlZ2V4cCBtYXRjaGVzJyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm1hdGNoID0gZnVuY3Rpb24gKGV4cCwgcmUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5tYXRjaCwgdHJ1ZSkudG8ubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgZG9lcyBub3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RNYXRjaCgnZm9vYmFyJywgL15mb28vLCAncmVnZXhwIGRvZXMgbm90IG1hdGNoJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE1hdGNoXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE1hdGNoID0gZnVuY3Rpb24gKGV4cCwgcmUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RNYXRjaCwgdHJ1ZSkudG8ubm90Lm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhJyk7XG4gICAqICAgICBhc3NlcnQucHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndG9TdHJpbmcnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LnByb3BlcnR5LCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWRcbiAgICogYnkgYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUnKTtcbiAgICpcbiAgICogQG5hbWUgbm90UHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdFByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAgd2l0aCBhIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICogKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQucHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkXG4gICAqIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAqICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBiYWQnKTtcbiAgICogICAgIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICdjb2ZmZWUnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90UHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgIHdpdGggYSB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgZ3JlZW46ICdtYXRjaGEnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWRcbiAgICogYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBibGFjazogJ21hdGNoYScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGdyZWVuOiAnb29sb25nJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ2NvZmZlZScsIHsgZ3JlZW46ICdtYXRjaGEnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuIEluaGVyaXRlZFxuICAgKiBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm93blByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3duUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQub3duUHJvcGVydHksIHRydWUpXG4gICAgICAudG8uaGF2ZS5vd24ucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90T3duUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAuIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE93blByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ2NvZmZlZScpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE93blByb3BlcnR5KHt9LCAndG9TdHJpbmcnKTtcbiAgICpcbiAgICogQG5hbWUgbm90T3duUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE93blByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE93blByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm93bi5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgYW5kIGEgdmFsdWVcbiAgICogZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqIEluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm93blByb3BlcnR5VmFsKHsgY29mZmVlOiAnaXMgZ29vZCd9LCAnY29mZmVlJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5vd25Qcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm93bi5wcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90T3duUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgXG4gICAqIHdpdGggYSB2YWx1ZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgKiAoPT09KS4gSW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBiZXR0ZXInfSwgJ3RlYScsICdpcyB3b3JzZScpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsKHt9LCAndG9TdHJpbmcnLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgICpcbiAgICogQG5hbWUgbm90T3duUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBPd25Qcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgYW5kIGEgdmFsdWVcbiAgICogZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLiBJbmhlcml0ZWRcbiAgICogcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgZ3JlZW46ICdtYXRjaGEnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwT3duUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBPd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZGVlcE93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuZGVlcC5vd24ucHJvcGVydHkocHJvcCwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBPd25Qcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWBcbiAgICogd2l0aCBhIHZhbHVlIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICogSW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGJsYWNrOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgZ3JlZW46ICdvb2xvbmcnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAnY29mZmVlJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHt9LCAndG9TdHJpbmcnLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcE93blByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5kZWVwLm93bi5wcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubmVzdGVkUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZCBieVxuICAgKiBgcHJvcGVydHlgLCB3aGljaCBjYW4gYmUgYSBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3JcbiAgICogbmVzdGVkIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nKTtcbiAgICpcbiAgICogQG5hbWUgbmVzdGVkUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5LCB0cnVlKVxuICAgICAgLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE5lc3RlZFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIHdoaWNoXG4gICAqIGNhbiBiZSBhIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBuZXN0ZWQgcmVmZXJlbmNlLiBUaGVcbiAgICogcHJvcGVydHkgY2Fubm90IGV4aXN0IG9uIHRoZSBvYmplY3Qgbm9yIGFueXdoZXJlIGluIGl0cyBwcm90b3R5cGUgY2hhaW4uXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLm9vbG9uZycpO1xuICAgKlxuICAgKiBAbmFtZSBub3ROZXN0ZWRQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90TmVzdGVkUHJvcGVydHksIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUubmVzdGVkLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIG5lc3RlZFxuICAgKiByZWZlcmVuY2UuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBuZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE5lc3RlZFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGhcbiAgICogdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yXG4gICAqIG5lc3RlZCByZWZlcmVuY2UuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ2tvbmFjaGEnKTtcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICdjb2ZmZWUuZ3JlZW4nLCAnbWF0Y2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBOZXN0ZWRQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIGEgdmFsdWUgZ2l2ZW5cbiAgICogYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIG5lc3RlZFxuICAgKiByZWZlcmVuY2UuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBOZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogeyBtYXRjaGE6ICd5dW0nIH0gfSB9LCAndGVhLmdyZWVuJywgeyBtYXRjaGE6ICd5dW0nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwTmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBOZXN0ZWRQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRlZXBOZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmRlZXAubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGhcbiAgICogdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yXG4gICAqIG5lc3RlZCByZWZlcmVuY2UuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogeyBtYXRjaGE6ICd5dW0nIH0gfSB9LCAndGVhLmdyZWVuJywgeyBvb2xvbmc6ICd5dW0nIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogeyBtYXRjaGE6ICd5dW0nIH0gfSB9LCAndGVhLmdyZWVuJywgeyBtYXRjaGE6ICd5dWNrJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46IHsgbWF0Y2hhOiAneXVtJyB9IH0gfSwgJ3RlYS5ibGFjaycsIHsgbWF0Y2hhOiAneXVtJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcE5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuZGVlcC5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG9iamVjdCwgbGVuZ3RoLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBgbGVuZ3RoYCBvciBgc2l6ZWAgd2l0aCB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoWzEsMiwzXSwgMywgJ2FycmF5IGhhcyBsZW5ndGggb2YgMycpO1xuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKCdmb29iYXInLCA2LCAnc3RyaW5nIGhhcyBsZW5ndGggb2YgNicpO1xuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKG5ldyBTZXQoWzEsMiwzXSksIDMsICdzZXQgaGFzIHNpemUgb2YgMycpO1xuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKG5ldyBNYXAoW1snYScsMV0sWydiJywyXSxbJ2MnLDNdXSksIDMsICdtYXAgaGFzIHNpemUgb2YgMycpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubGVuZ3RoT2YgPSBmdW5jdGlvbiAoZXhwLCBsZW4sIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5sZW5ndGhPZiwgdHJ1ZSkudG8uaGF2ZS5sZW5ndGhPZihsZW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmhhc0FueUtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2lEb250RXhpc3QnLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7Zm9vOiAzMCwgaURvbnRFeGlzdDogOTksIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9LCAna2V5J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueUtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKSwgW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSk7XG4gICAqXG4gICAqIEBuYW1lIGhhc0FueUtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbnlLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lmhhc0FueUtleXMsIHRydWUpLnRvLmhhdmUuYW55LmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5oYXNBbGxLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIGFuZCBvbmx5IGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmFyJywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhcjogOTksIGJhejogMTMzN10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9LCAna2V5J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaGFzQWxsS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbGxLZXlzLCB0cnVlKS50by5oYXZlLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuY29udGFpbnNBbGxLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQgYnV0IG1heSBoYXZlIG1vcmUga2V5cyBub3QgbGlzdGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnYmFyJywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7Zm9vOiAzMCwgYmF6OiAxMzM3fSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge2ZvbzogMzAsIGJhcjogOTksIGJhejogMTMzN30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe2ZvbzogMX1dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tmb286IDF9LCAna2V5J10pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7Zm9vOiAnYmFyJ31dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKTtcbiAgICpcbiAgICogQG5hbWUgY29udGFpbnNBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jb250YWluc0FsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuY29udGFpbnNBbGxLZXlzLCB0cnVlKVxuICAgICAgLnRvLmNvbnRhaW4uYWxsLmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90SGF2ZUFueUtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBub25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnb25lJywgJ3R3bycsICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtvbmU6IDEsIHR3bzogMiwgZXhhbXBsZTogJ2Zvbyd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMobmV3IE1hcChbW3tmb286IDF9LCAnYmFyJ10sIFsna2V5JywgJ3ZhbHVlJ11dKSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tvbmU6ICd0d28nfSwgJ2V4YW1wbGUnXSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQW55S2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbnkua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQWxsS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydvbmUnLCAndHdvJywgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge29uZTogMSwgdHdvOiAyLCBleGFtcGxlOiAnZm9vJ30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe29uZTogJ3R3byd9LCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe29uZTogJ3R3byd9LCAnZXhhbXBsZSddKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFsbC5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaGFzQW55RGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFt7dHdvOiAndHdvJ30sICd2YWx1ZVR3byddXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3RocmVlOiAndGhyZWUnfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbnlEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbnlEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmFueS5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmhhc0FsbERlZXBLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYWxsIGFuZCBvbmx5IGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ31dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbGxEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5oYXNBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmNvbnRhaW5zQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGNvbnRhaW5zIGFsbCBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbMSwgMl1dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICpcbiAgICogQG5hbWUgY29udGFpbnNBbGxEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5jb250YWluLmFsbC5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQW55RGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBub25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7dGhpc0RvZXNOb3Q6ICdleGlzdCd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCB7dHdlbnR5OiAndHdlbnR5J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3t0d2VudHk6ICd0d2VudHknfSwge2ZpZnR5OiAnZmlmdHknfV0pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFueURlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFueS5kZWVwLmtleXMoa2V5cyk7XG4gIH1cblxuIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7dGhpc0RvZXNOb3Q6ICdleGlzdCd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddLCBbe3R3bzogJ3R3byd9LCAndmFsdWVUd28nXV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7b25lOiAnb25lJ31dKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHt0d2VudHk6ICd0d2VudHknfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsRGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYWxsLmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAudGhyb3dzKGZuLCBbZXJyb3JMaWtlL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBjb25zdHJ1Y3RvciwgYXNzZXJ0cyB0aGF0IGBmbmAgd2lsbCB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuXG4gICAqIGluc3RhbmNlIG9mIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGluc3RhbmNlLCBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biBpcyB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZSBhcyBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVyck1zZ01hdGNoZXJgIGlzIHByb3ZpZGVkLCBpdCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIHdpbGwgaGF2ZSBhXG4gICAqIG1lc3NhZ2UgbWF0Y2hpbmcgYGVyck1zZ01hdGNoZXJgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgJ0Vycm9yIHRocm93biBtdXN0IGhhdmUgdGhpcyBtc2cnKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIC9FcnJvciB0aHJvd24gbXVzdCBoYXZlIGEgbXNnIHRoYXQgbWF0Y2hlcyB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBSZWZlcmVuY2VFcnJvcik7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBlcnJvckluc3RhbmNlKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yLCAnRXJyb3IgdGhyb3duIG11c3QgYmUgYSBSZWZlcmVuY2VFcnJvciBhbmQgaGF2ZSB0aGlzIG1zZycpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgZXJyb3JJbnN0YW5jZSwgJ0Vycm9yIHRocm93biBtdXN0IGJlIHRoZSBzYW1lIGVycm9ySW5zdGFuY2UgYW5kIGhhdmUgdGhpcyBtc2cnKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yLCAvRXJyb3IgdGhyb3duIG11c3QgYmUgYSBSZWZlcmVuY2VFcnJvciBhbmQgbWF0Y2ggdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgZXJyb3JJbnN0YW5jZSwgL0Vycm9yIHRocm93biBtdXN0IGJlIHRoZSBzYW1lIGVycm9ySW5zdGFuY2UgYW5kIG1hdGNoIHRoaXMvKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dzXG4gICAqIEBhbGlhcyB0aHJvd1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfEVycm9yfSBlcnJvckxpa2VcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBlcnJNc2dNYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIChmbiwgZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBlcnJvckxpa2UgfHwgZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBlcnJNc2dNYXRjaGVyID0gZXJyb3JMaWtlO1xuICAgICAgZXJyb3JMaWtlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQudGhyb3dzLCB0cnVlKVxuICAgICAgLnRvLnRocm93KGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlcik7XG4gICAgcmV0dXJuIGZsYWcoYXNzZXJ0RXJyLCAnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdFRocm93KGZuLCBbZXJyb3JMaWtlL3N0cmluZy9yZWdleHBdLCBbc3RyaW5nL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICpcbiAgICogSWYgYGVycm9yTGlrZWAgaXMgYW4gYEVycm9yYCBjb25zdHJ1Y3RvciwgYXNzZXJ0cyB0aGF0IGBmbmAgd2lsbCBfbm90XyB0aHJvdyBhbiBlcnJvciB0aGF0IGlzIGFuXG4gICAqIGluc3RhbmNlIG9mIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGluc3RhbmNlLCBhc3NlcnRzIHRoYXQgdGhlIGVycm9yIHRocm93biBpcyBfbm90XyB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZSBhcyBgZXJyb3JMaWtlYC5cbiAgICogSWYgYGVyck1zZ01hdGNoZXJgIGlzIHByb3ZpZGVkLCBpdCBhbHNvIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIHdpbGwgX25vdF8gaGF2ZSBhXG4gICAqIG1lc3NhZ2UgbWF0Y2hpbmcgYGVyck1zZ01hdGNoZXJgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgJ0FueSBFcnJvciB0aHJvd24gbXVzdCBub3QgaGF2ZSB0aGlzIG1lc3NhZ2UnKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIC9BbnkgRXJyb3IgdGhyb3duIG11c3Qgbm90IG1hdGNoIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIGVycm9ySW5zdGFuY2UpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IsICdFcnJvciBtdXN0IG5vdCBoYXZlIHRoaXMgbWVzc2FnZScpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgZXJyb3JJbnN0YW5jZSwgJ0Vycm9yIG11c3Qgbm90IGhhdmUgdGhpcyBtZXNzYWdlJyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvciwgL0Vycm9yIG11c3Qgbm90IG1hdGNoIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIGVycm9ySW5zdGFuY2UsIC9FcnJvciBtdXN0IG5vdCBtYXRjaCB0aGlzLyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZVxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGVyck1zZ01hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycm9yTGlrZSB8fCBlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3RUaHJvdywgdHJ1ZSlcbiAgICAgIC50by5ub3QudGhyb3coZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIHZhciBvaztcbiAgICBzd2l0Y2gob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgb2sgPSB2YWwgPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgICBvayA9IHZhbCA9PT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc+JzpcbiAgICAgICAgb2sgPSB2YWwgPiB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgb2sgPSB2YWwgPj0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgb2sgPSB2YWwgPCB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgb2sgPSB2YWwgPD0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPSc6XG4gICAgICAgIG9rID0gdmFsICE9IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgb2sgPSB2YWwgIT09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbXNnID0gbXNnID8gbXNnICsgJzogJyA6IG1zZztcbiAgICAgICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgbXNnICsgJ0ludmFsaWQgb3BlcmF0b3IgXCInICsgb3BlcmF0b3IgKyAnXCInLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBhc3NlcnQub3BlcmF0b3JcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG9rLCBtc2csIGFzc2VydC5vcGVyYXRvciwgdHJ1ZSk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBub3QgYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5jbG9zZVRvKDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNsb3NlVG8gPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuY2xvc2VUbywgdHJ1ZSkudG8uYmUuY2xvc2VUbyhleHAsIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5hcHByb3hpbWF0ZWx5KGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmFwcHJveGltYXRlbHkoMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBhcHByb3hpbWF0ZWx5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuYXBwcm94aW1hdGVseSA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5hcHByb3hpbWF0ZWx5LCB0cnVlKVxuICAgICAgLnRvLmJlLmFwcHJveGltYXRlbHkoZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuc2FtZU1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZU1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci5cbiAgICogVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyA1LCAxLCAzIF0sICdub3Qgc2FtZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZU1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lRGVlcE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbeyBiOiAyIH0sIHsgYTogMSB9LCB7IGM6IDMgfV0sICdzYW1lIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLmRlZXAubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVEZWVwTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLlxuICAgKiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTYW1lRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFt7IGI6IDIgfSwgeyBhOiAxIH0sIHsgZjogNSB9XSwgJ25vdCBzYW1lIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5kZWVwLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAxLCAyLCAzIF0sICdzYW1lIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWVcbiAgICogb3JkZXIuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U2FtZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDMgXSwgJ25vdCBzYW1lIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICogVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqIGFzc2VydC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgJ3NhbWUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5zYW1lRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuc2FtZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgZG9uJ3QgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lXG4gICAqIG9yZGVyLiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IHo6IDUgfSBdLCAnbm90IHNhbWUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYTogMSB9LCB7IGM6IDMgfSBdLCAnbm90IHNhbWUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2csIGFzc2VydC5ub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS4gRHVwbGljYXRlcyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAyIF0sICdpbmNsdWRlIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDUsIDEgXSwgJ25vdCBpbmNsdWRlIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlRGVlcE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYSBkZWVwXG4gICAqIGVxdWFsaXR5IGNoZWNrLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBhOiAxIH0sIHsgYjogMiB9IF0sICdpbmNsdWRlIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUuZGVlcC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBkZWVwIGVxdWFsaXR5IGNoZWNrLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBmOiA1IH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZURlZXBNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLmRlZXAubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZU9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMSwgMiBdLCAnaW5jbHVkZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZU9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZU9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSBdLCAnbm90IGluY2x1ZGUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDMgXSwgJ25vdCBpbmNsdWRlIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5XG4gICAqIGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgYjogMiB9IF0sICdpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIHRoZSBzYW1lIG9yZGVyXG4gICAqIGJlZ2lubmluZyB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IGluIGBzdXBlcnNldGAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5XG4gICAqIGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgZjogNSB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYTogMSB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBiOiAyIH0sIHsgYzogMyB9IF0sICdub3QgaW5jbHVkZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1cGVyc2V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN1YnNldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5vbmVPZihpbkxpc3QsIGxpc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IG5vbi1vYmplY3QsIG5vbi1hcnJheSB2YWx1ZSBgaW5MaXN0YCBhcHBlYXJzIGluIHRoZSBmbGF0IGFycmF5IGBsaXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vbmVPZigxLCBbIDIsIDEgXSwgJ05vdCBmb3VuZCBpbiBsaXN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIG9uZU9mXG4gICAqIEBwYXJhbSB7Kn0gaW5MaXN0XG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGxpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9uZU9mID0gZnVuY3Rpb24gKGluTGlzdCwgbGlzdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihpbkxpc3QsIG1zZywgYXNzZXJ0Lm9uZU9mLCB0cnVlKS50by5iZS5vbmVPZihsaXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNoYW5nZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMjIgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmNoYW5nZXMsIHRydWUpLnRvLmNoYW5nZShvYmosIHByb3ApO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmNoYW5nZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBieSBhbiBhbW91bnQgKGRlbHRhKS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsICs9IDIgfTtcbiAgICogICAgIGFzc2VydC5jaGFuZ2VzQnkoZm4sIG9iaiwgJ3ZhbCcsIDIpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNoYW5nZXNCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuY2hhbmdlc0J5LCB0cnVlKVxuICAgICAgLnRvLmNoYW5nZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gICAvKipcbiAgICogIyMjIC5kb2VzTm90Q2hhbmdlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnZm9vJyk7IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdENoYW5nZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RDaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90Q2hhbmdlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdENoYW5nZSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2VzQnV0Tm90QnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBvciBvZiBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAxMCB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXNCdXROb3RCeShmbiwgb2JqLCAndmFsJywgNSk7XG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZXNCdXROb3RCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlc0J1dE5vdEJ5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5jaGFuZ2VzQnV0Tm90QnksIHRydWUpXG4gICAgICAudG8uY2hhbmdlKG9iaiwgcHJvcCkuYnV0Lm5vdC5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gaW5jcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDEzIH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jcmVhc2VzID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuaW5jcmVhc2VzLCB0cnVlKVxuICAgICAgLnRvLmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXNCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gaW5jcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsICs9IDEwIH07XG4gICAqICAgICBhc3NlcnQuaW5jcmVhc2VzQnkoZm4sIG9iaiwgJ3ZhbCcsIDEwKTtcbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VzQnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlIGFtb3VudCAoZGVsdGEpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY3JlYXNlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXNCeSwgdHJ1ZSlcbiAgICAgIC50by5pbmNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RJbmNyZWFzZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBpbmNyZWFzZSBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA4IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEluY3JlYXNlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEluY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdEluY3JlYXNlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdEluY3JlYXNlLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2VzQnV0Tm90QnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgaW5jcmVhc2UgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTUgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXNCdXROb3RCeShmbiwgb2JqLCAndmFsJywgMTApO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNCdXROb3RCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jcmVhc2VzQnV0Tm90QnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmluY3JlYXNlc0J1dE5vdEJ5LCB0cnVlKVxuICAgICAgLnRvLmluY3JlYXNlKG9iaiwgcHJvcCkuYnV0Lm5vdC5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kZWNyZWFzZXMsIHRydWUpXG4gICAgICAudG8uZGVjcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlc0J5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCAtPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzQnkoZm4sIG9iaiwgJ3ZhbCcsIDUpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZXNCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRlY3JlYXNlc0J5LCB0cnVlKVxuICAgICAgLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdERlY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3REZWNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuZGVjcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3REZWNyZWFzZUJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDUgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90RGVjcmVhc2VCeShmbiwgb2JqLCAndmFsJywgMSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3REZWNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdERlY3JlYXNlQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90RGVjcmVhc2VCeSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuZGVjcmVhc2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZXNCdXROb3RCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkgb3IgYSBmdW5jdGlvbidzIHJldHVybiB2YWx1ZSBieSBhbiBhbW91bnQgKGRlbHRhKVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBhc3NlcnQuZGVjcmVhc2VzQnV0Tm90QnkoZm4sIG9iaiwgJ3ZhbCcsIDEpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZXNCdXROb3RCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVjcmVhc2VzQnV0Tm90QnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRlY3JlYXNlc0J1dE5vdEJ5LCB0cnVlKVxuICAgICAgLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCkuYnV0Lm5vdC5ieShkZWx0YSk7XG4gIH1cblxuICAvKiFcbiAgICogIyMjIC5pZkVycm9yKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyBpZiB2YWx1ZSBpcyBub3QgYSBmYWxzZSB2YWx1ZSwgYW5kIHRocm93cyBpZiBpdCBpcyBhIHRydWUgdmFsdWUuXG4gICAqIFRoaXMgaXMgYWRkZWQgdG8gYWxsb3cgZm9yIGNoYWkgdG8gYmUgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciBOb2RlJ3NcbiAgICogYXNzZXJ0IGNsYXNzLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignSSBhbSBhIGN1c3RvbSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LmlmRXJyb3IoZXJyKTsgLy8gUmV0aHJvd3MgZXJyIVxuICAgKlxuICAgKiBAbmFtZSBpZkVycm9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhyb3codmFsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGV4dGVuc2libGUgKGNhbiBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0V4dGVuc2libGUoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc0V4dGVuc2libGVcbiAgICogQGFsaWFzIGV4dGVuc2libGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0V4dGVuc2libGUgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNFeHRlbnNpYmxlLCB0cnVlKS50by5iZS5leHRlbnNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RXh0ZW5zaWJsZShvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBleHRlbnNpYmxlLlxuICAgKlxuICAgKiAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUobm9uRXh0ZW5zaWJsZU9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKHNlYWxlZE9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgbm90RXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc05vdEV4dGVuc2libGUsIHRydWUpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU2VhbGVkKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHNlYWxlZCAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSByZW1vdmVkKS5cbiAgICpcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzU2VhbGVkKHNlYWxlZE9iamVjdCk7XG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNTZWFsZWRcbiAgICogQGFsaWFzIHNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzU2VhbGVkLCB0cnVlKS50by5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gc2VhbGVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90U2VhbGVkKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTZWFsZWRcbiAgICogQGFsaWFzIG5vdFNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzTm90U2VhbGVkLCB0cnVlKS50by5ub3QuYmUuc2VhbGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRnJvemVuKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZyb3plbiAoY2Fubm90IGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXRcbiAgICogYW5kIGl0cyBleGlzdGluZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBtb2RpZmllZCkuXG4gICAqXG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqICAgICBhc3NlcnQuZnJvemVuKGZyb3plbk9iamVjdCk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnJvemVuXG4gICAqIEBhbGlhcyBmcm96ZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Zyb3plbiA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc0Zyb3plbiwgdHJ1ZSkudG8uYmUuZnJvemVuO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnJvemVuKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGZyb3plbi5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEZyb3plbih7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RnJvemVuXG4gICAqIEBhbGlhcyBub3RGcm96ZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZyb3plbiA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc05vdEZyb3plbiwgdHJ1ZSkudG8ubm90LmJlLmZyb3plbjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0VtcHR5KHRhcmdldClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgZG9lcyBub3QgY29udGFpbiBhbnkgdmFsdWVzLlxuICAgKiBGb3IgYXJyYXlzIGFuZCBzdHJpbmdzLCBpdCBjaGVja3MgdGhlIGBsZW5ndGhgIHByb3BlcnR5LlxuICAgKiBGb3IgYE1hcGAgYW5kIGBTZXRgIGluc3RhbmNlcywgaXQgY2hlY2tzIHRoZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAqIEZvciBub24tZnVuY3Rpb24gb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2Ygb3duXG4gICAqIGVudW1lcmFibGUgc3RyaW5nIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNFbXB0eShbXSk7XG4gICAqICAgICBhc3NlcnQuaXNFbXB0eSgnJyk7XG4gICAqICAgICBhc3NlcnQuaXNFbXB0eShuZXcgTWFwKTtcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNFbXB0eVxuICAgKiBAYWxpYXMgZW1wdHlcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfE1hcHxTZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0VtcHR5ID0gZnVuY3Rpb24odmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNFbXB0eSwgdHJ1ZSkudG8uYmUuZW1wdHk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RFbXB0eSh0YXJnZXQpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGNvbnRhaW5zIHZhbHVlcy5cbiAgICogRm9yIGFycmF5cyBhbmQgc3RyaW5ncywgaXQgY2hlY2tzIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICogRm9yIGBNYXBgIGFuZCBgU2V0YCBpbnN0YW5jZXMsIGl0IGNoZWNrcyB0aGUgYHNpemVgIHByb3BlcnR5LlxuICAgKiBGb3Igbm9uLWZ1bmN0aW9uIG9iamVjdHMsIGl0IGdldHMgdGhlIGNvdW50IG9mIG93blxuICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkoWzEsIDJdKTtcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KCczNCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkobmV3IFNldChbNSwgNl0pKTtcbiAgICogICAgIGFzc2VydC5pc05vdEVtcHR5KHsga2V5OiA3IH0pO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEVtcHR5XG4gICAqIEBhbGlhcyBub3RFbXB0eVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8TWFwfFNldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RW1wdHkgPSBmdW5jdGlvbih2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEVtcHR5LCB0cnVlKS50by5ub3QuYmUuZW1wdHk7XG4gIH07XG5cbiAgLyohXG4gICAqIEFsaWFzZXMuXG4gICAqL1xuXG4gIChmdW5jdGlvbiBhbGlhcyhuYW1lLCBhcyl7XG4gICAgYXNzZXJ0W2FzXSA9IGFzc2VydFtuYW1lXTtcbiAgICByZXR1cm4gYWxpYXM7XG4gIH0pXG4gICgnaXNPaycsICdvaycpXG4gICgnaXNOb3RPaycsICdub3RPaycpXG4gICgndGhyb3dzJywgJ3Rocm93JylcbiAgKCd0aHJvd3MnLCAnVGhyb3cnKVxuICAoJ2lzRXh0ZW5zaWJsZScsICdleHRlbnNpYmxlJylcbiAgKCdpc05vdEV4dGVuc2libGUnLCAnbm90RXh0ZW5zaWJsZScpXG4gICgnaXNTZWFsZWQnLCAnc2VhbGVkJylcbiAgKCdpc05vdFNlYWxlZCcsICdub3RTZWFsZWQnKVxuICAoJ2lzRnJvemVuJywgJ2Zyb3plbicpXG4gICgnaXNOb3RGcm96ZW4nLCAnbm90RnJvemVuJylcbiAgKCdpc0VtcHR5JywgJ2VtcHR5JylcbiAgKCdpc05vdEVtcHR5JywgJ25vdEVtcHR5Jyk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHVzZWQgPSBbXTtcblxuLyohXG4gKiBDaGFpIHZlcnNpb25cbiAqL1xuXG5leHBvcnRzLnZlcnNpb24gPSAnNC4yLjAnO1xuXG4vKiFcbiAqIEFzc2VydGlvbiBFcnJvclxuICovXG5cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCdhc3NlcnRpb24tZXJyb3InKTtcblxuLyohXG4gKiBVdGlscyBmb3IgcGx1Z2lucyAobm90IGV4cG9ydGVkKVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi9jaGFpL3V0aWxzJyk7XG5cbi8qKlxuICogIyAudXNlKGZ1bmN0aW9uKVxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGV4dGVuZCB0aGUgaW50ZXJuYWxzIG9mIENoYWkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEByZXR1cm5zIHt0aGlzfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51c2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCF+dXNlZC5pbmRleE9mKGZuKSkge1xuICAgIGZuKGV4cG9ydHMsIHV0aWwpO1xuICAgIHVzZWQucHVzaChmbik7XG4gIH1cblxuICByZXR1cm4gZXhwb3J0cztcbn07XG5cbi8qIVxuICogVXRpbGl0eSBGdW5jdGlvbnNcbiAqL1xuXG5leHBvcnRzLnV0aWwgPSB1dGlsO1xuXG4vKiFcbiAqIENvbmZpZ3VyYXRpb25cbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jaGFpL2NvbmZpZycpO1xuZXhwb3J0cy5jb25maWcgPSBjb25maWc7XG5cbi8qIVxuICogUHJpbWFyeSBgQXNzZXJ0aW9uYCBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9jaGFpL2Fzc2VydGlvbicpO1xuZXhwb3J0cy51c2UoYXNzZXJ0aW9uKTtcblxuLyohXG4gKiBDb3JlIEFzc2VydGlvbnNcbiAqL1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY2hhaS9jb3JlL2Fzc2VydGlvbnMnKTtcbmV4cG9ydHMudXNlKGNvcmUpO1xuXG4vKiFcbiAqIEV4cGVjdCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgZXhwZWN0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9leHBlY3QnKTtcbmV4cG9ydHMudXNlKGV4cGVjdCk7XG5cbi8qIVxuICogU2hvdWxkIGludGVyZmFjZVxuICovXG5cbnZhciBzaG91bGQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL3Nob3VsZCcpO1xuZXhwb3J0cy51c2Uoc2hvdWxkKTtcblxuLyohXG4gKiBBc3NlcnQgaW50ZXJmYWNlXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvYXNzZXJ0Jyk7XG5leHBvcnRzLnVzZShhc3NlcnQpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaGFpJyk7XG4iLCIoZnVuY3Rpb24oY2hhaURvbSkge1xuICBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjaGFpRG9tXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNoYWlEb21cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNoYWkudXNlKGNoYWlEb20pXG4gIH1cbn0oZnVuY3Rpb24oY2hhaSwgdXRpbHMpIHtcbiAgdmFyIGZsYWcgPSB1dGlscy5mbGFnLFxuXG4gIGVsVG9TdHJpbmcgPSBmdW5jdGlvbihlbCkge1xuICAgIHZhciBkZXNjXG4gICAgaWYgKGlzTm9kZUxpc3QoZWwpKSB7XG4gICAgICBpZiAoZWwubGVuZ3RoID09PSAwKSByZXR1cm4gJ2VtcHR5IE5vZGVMaXN0J1xuICAgICAgZGVzYyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsLCAwLCA1KS5tYXAoZWxUb1N0cmluZykuam9pbignLCAnKVxuICAgICAgcmV0dXJuIGVsLmxlbmd0aCA+IDUgPyBkZXNjICsgJy4uLiAoKycgKyAoZWwubGVuZ3RoIC0gNSkgKyAnIG1vcmUpJyA6IGRlc2NcbiAgICB9XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsKSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhlbClcbiAgICB9XG5cbiAgICBkZXNjID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVsLmlkKSB7XG4gICAgICBkZXNjICs9ICcjJyArIGVsLmlkXG4gICAgfVxuICAgIGlmIChlbC5jbGFzc05hbWUpIHtcbiAgICAgIGRlc2MgKz0gJy4nICsgU3RyaW5nKGVsLmNsYXNzTmFtZSkucmVwbGFjZSgvXFxzKy9nLCAnLicpXG4gICAgfVxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwuYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIubmFtZSAhPT0gJ2NsYXNzJyAmJiBhdHRyLm5hbWUgIT09ICdpZCcpIHtcbiAgICAgICAgZGVzYyArPSAnWycgKyBhdHRyLm5hbWUgKyAoYXR0ci52YWx1ZSA/ICc9XCInICsgYXR0ci52YWx1ZSArICdcIl0nIDogJ10nKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGRlc2NcbiAgfSxcblxuICBhdHRyQXNzZXJ0ID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGFjdHVhbCA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKVxuXG4gICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICEhZWwuYXR0cmlidXRlc1tuYW1lXVxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgYW4gYXR0cmlidXRlICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBhbiBhdHRyaWJ1dGUgI3tleHB9J1xuICAgICAgICAsIG5hbWVcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB2YWwgPT09IGFjdHVhbFxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgYW4gYXR0cmlidXRlICcgKyB1dGlscy5pbnNwZWN0KG5hbWUpICsgJyB3aXRoIHRoZSB2YWx1ZSAje2V4cH0sIGJ1dCB0aGUgdmFsdWUgd2FzICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBhbiBhdHRyaWJ1dGUgJyArIHV0aWxzLmluc3BlY3QobmFtZSkgKyAnIHdpdGggdGhlIHZhbHVlICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWwpXG4gIH0sXG5cbiAgaXNIVE1MRWxlbWVudCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGVsLm5vZGVUeXBlID09PSAxIC8vIHdpbmRvdy5Ob2RlLkVMRU1FTlRfTk9ERVxuICB9LFxuXG4gIGlzTm9kZUxpc3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE5vZGVMaXN0XSdcbiAgfVxuXG4gIHV0aWxzLmVsVG9TdHJpbmcgPSBlbFRvU3RyaW5nXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYXR0cicsIGF0dHJBc3NlcnQpXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYXR0cmlidXRlJywgYXR0ckFzc2VydClcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2NsYXNzJywgZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgY2xhc3MgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyBub3QgdG8gaGF2ZSBjbGFzcyAje2V4cH0nXG4gICAgICAsIGNsYXNzTmFtZVxuICAgIClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2lkJywgZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZWwuaWQgPT0gaWRcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBpZCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIGlkICN7ZXhwfSdcbiAgICAgICwgaWRcbiAgICApXG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdodG1sJywgZnVuY3Rpb24oaHRtbCkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBhY3R1YWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKS5pbm5lckhUTUxcblxuICAgIGlmIChmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgYWN0dWFsLmluZGV4T2YoaHRtbCkgPj0gMFxuICAgICAgICAsICdleHBlY3RlZCAje2FjdH0gdG8gY29udGFpbiBIVE1MICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3thY3R9IG5vdCB0byBjb250YWluIEhUTUwgI3tleHB9J1xuICAgICAgICAsIGh0bWxcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGFjdHVhbCA9PT0gaHRtbFxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgSFRNTCAje2V4cH0sIGJ1dCB0aGUgSFRNTCB3YXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIEhUTUwgI3tleHB9J1xuICAgICAgICAsIGh0bWxcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCd0cmltbWVkJywgbnVsbCwgZnVuY3Rpb24oKSB7XG4gICAgZmxhZyh0aGlzLCAndHJpbS10ZXh0JywgdHJ1ZSlcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ3RleHQnLCBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBjb250YWlucyA9IGZsYWcodGhpcywgJ2NvbnRhaW5zJyksXG4gICAgICAgIHRyaW0gPSBmbGFnKHRoaXMsICd0cmltLXRleHQnKSwgYWN0dWFsLCByZXN1bHRcblxuICAgIGlmIChpc05vZGVMaXN0KG9iaikpIHtcbiAgICAgIGFjdHVhbCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvYmosIGZ1bmN0aW9uKGVsKSB7IHJldHVybiB0cmltID8gZWwudGV4dENvbnRlbnQudHJpbSgpIDogZWwudGV4dENvbnRlbnQgfSlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IGNvbnRhaW5zID9cbiAgICAgICAgICB0ZXh0W2ZsYWcodGhpcywgJ25lZ2F0ZScpID8gJ3NvbWUnIDogJ2V2ZXJ5J10oZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwob2JqLCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICByZXR1cm4gKHRyaW0gPyBlbC50ZXh0Q29udGVudC50cmltKCkgOiBlbC50ZXh0Q29udGVudCkgPT09IHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICA6XG4gICAgICAgICAgdXRpbHMuZXFsKGFjdHVhbCwgdGV4dClcblxuICAgICAgICBhY3R1YWwgPSBhY3R1YWwuam9pbigpXG4gICAgICAgIHRleHQgPSB0ZXh0LmpvaW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsID0gYWN0dWFsLmpvaW4oJycpXG4gICAgICAgIHJlc3VsdCA9IGNvbnRhaW5zID8gYWN0dWFsLmluZGV4T2YodGV4dCkgPj0gMCA6IGFjdHVhbCA9PT0gdGV4dFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhY3R1YWwgPSB0cmltID8gb2JqLnRleHRDb250ZW50LnRyaW0oKSA6IG9iai50ZXh0Q29udGVudFxuICAgICAgcmVzdWx0ID0gY29udGFpbnMgPyBhY3R1YWwuaW5kZXhPZih0ZXh0KSA+PSAwIDogYWN0dWFsID09PSB0ZXh0XG4gICAgfVxuXG4gICAgdmFyIG9iakRlc2MgPSBlbFRvU3RyaW5nKG9iaiksIHRleHRNc2cgPSB0cmltID8gJ3RyaW1tZWQgdGV4dCcgOiAndGV4dCdcbiAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZXN1bHRcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIG9iakRlc2MgKyAnIHRvIGNvbnRhaW4gI3tleHB9LCBidXQgdGhlICcgKyB0ZXh0TXNnICsgJyB3YXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgbm90IHRvIGNvbnRhaW4gI3tleHB9LCBidXQgdGhlICcgKyB0ZXh0TXNnICsgJyB3YXMgI3thY3R9J1xuICAgICAgICAsIHRleHRcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgdG8gaGF2ZSAnICsgdGV4dE1zZyArICcgI3tleHB9LCBidXQgdGhlICcgKyB0ZXh0TXNnICsgJyB3YXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgbm90IHRvIGhhdmUgJyArIHRleHRNc2cgKyAnICN7ZXhwfSdcbiAgICAgICAgLCB0ZXh0XG4gICAgICAgICwgYWN0dWFsXG4gICAgICApXG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBhY3R1YWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKS52YWx1ZVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JykudmFsdWUgPT09IHZhbHVlXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGhhdmUgdmFsdWUgI3tleHB9LCBidXQgdGhlIHZhbHVlIHdhcyAje2FjdH0nXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIHZhbHVlICN7ZXhwfSdcbiAgICAgICwgdmFsdWVcbiAgICAgICwgYWN0dWFsXG4gICAgKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgaWYgKGlzTm9kZUxpc3Qob2JqKSkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmoubGVuZ3RoID4gMFxuICAgICAgICAgICwgJ2V4cGVjdGVkIGFuIGVtcHR5IE5vZGVMaXN0IHRvIGhhdmUgbm9kZXMnXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGV4aXN0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdlbXB0eScsIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQob2JqKSkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmouY2hpbGRyZW4ubGVuZ3RoID09PSAwXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gYmUgZW1wdHknXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgIH0gZWxzZSBpZiAoaXNOb2RlTGlzdChvYmopKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iai5sZW5ndGggPT09IDBcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBiZSBlbXB0eSdcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgYmUgZW1wdHknKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLFxuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICAgaWYgKGlzTm9kZUxpc3Qob2JqKSB8fCBpc0hUTUxFbGVtZW50KG9iaikpIHtcbiAgICAgICAgICB2YXIgYWN0dWFsTGVuZ3RoID0gb2JqLmNoaWxkcmVuID8gb2JqLmNoaWxkcmVuLmxlbmd0aCA6IG9iai5sZW5ndGhcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgYWN0dWFsTGVuZ3RoID09PSBsZW5ndGhcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGhhdmUgI3tleHB9IGNoaWxkcmVuIGJ1dCBpdCBoYWQgI3thY3R9IGNoaWxkcmVuJ1xuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGhhdmUgI3tleHB9IGNoaWxkcmVuJ1xuICAgICAgICAgICAgLCBsZW5ndGhcbiAgICAgICAgICAgICwgYWN0dWFsTGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdtYXRjaCcsIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChvYmopKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iai5tYXRjaGVzKHNlbGVjdG9yKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG1hdGNoICN7ZXhwfSdcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgbWF0Y2ggI3tleHB9J1xuICAgICAgICAgICwgc2VsZWN0b3JcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChpc05vZGVMaXN0KG9iaikpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgKCEhb2JqLmxlbmd0aCAmJiBBcnJheS5wcm90b3R5cGUuZXZlcnkuY2FsbChvYmosIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbC5tYXRjaGVzKHNlbGVjdG9yKSB9KSlcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBtYXRjaCAje2V4cH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IG1hdGNoICN7ZXhwfSdcbiAgICAgICAgICAsIHNlbGVjdG9yXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCgnY29udGFpbicsXG4gICAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3ViaXRlbSkge1xuICAgICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQob2JqKSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3ViaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICAhIW9iai5xdWVyeVNlbGVjdG9yKHN1Yml0ZW0pXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGNvbnRhaW4gI3tleHB9J1xuICAgICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgY29udGFpbiAje2V4cH0nXG4gICAgICAgICAgICAgICwgc3ViaXRlbSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICAgIG9iai5jb250YWlucyhzdWJpdGVtKVxuICAgICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBjb250YWluICcgKyBlbFRvU3RyaW5nKHN1Yml0ZW0pXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBjb250YWluICcgKyBlbFRvU3RyaW5nKHN1Yml0ZW0pKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcylcbiAgICAgIH1cbiAgICB9XG4gIClcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2Rlc2NlbmRhbnQnLCBmdW5jdGlvbihzdWJpdGVtKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpLCBhY3R1YWwgPSBzdWJpdGVtXG5cbiAgICBpZiAodHlwZW9mIHN1Yml0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBhY3R1YWwgPSBvYmoucXVlcnlTZWxlY3RvcihzdWJpdGVtKVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICEhYWN0dWFsXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGhhdmUgZGVzY2VuZGFudCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBoYXZlIGRlc2NlbmRhbnQgI3tleHB9J1xuICAgICAgICAsIHN1Yml0ZW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBvYmouY29udGFpbnMoc3ViaXRlbSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gY29udGFpbiAnICsgZWxUb1N0cmluZyhzdWJpdGVtKVxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgY29udGFpbiAnICsgZWxUb1N0cmluZyhzdWJpdGVtKSlcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWwpXG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdkZXNjZW5kYW50cycsIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpLFxuICAgICAgICBhY3R1YWwgPSBvYmoucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcilcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICEhYWN0dWFsLmxlbmd0aFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gaGF2ZSBkZXNjZW5kYW50cyAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgaGF2ZSBkZXNjZW5kYW50cyAje2V4cH0nXG4gICAgICAsIHNlbGVjdG9yKVxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGFjdHVhbClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZGlzcGxheWVkJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksXG4gICAgICAgIGFjdHVhbCA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXkgOiBlbC5zdHlsZS5kaXNwbGF5XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGFjdHVhbCAhPT0gJ25vbmUnXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIGJlIGRpc3BsYXllZCwgYnV0IGl0IHdhcyBub3QnXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIG5vdCBiZSBkaXNwbGF5ZWQsIGJ1dCBpdCB3YXMgYXMgJyArIGFjdHVhbFxuICAgICAgLCBhY3R1YWxcbiAgICApXG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ3Zpc2libGUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSxcbiAgICAgICAgYWN0dWFsID0gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCkgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkudmlzaWJpbGl0eSA6IGVsLnN0eWxlLnZpc2liaWxpdHlcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgYWN0dWFsICE9PSAnaGlkZGVuJyAmJiBhY3R1YWwgIT09ICdjb2xsYXBzZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gYmUgdmlzaWJsZSwgYnV0IGl0IHdhcyAnICsgKGFjdHVhbCA9PT0gJ2hpZGRlbicgPyAnaGlkZGVuJyA6ICdjb2xsYXBzZWQnKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBub3QgYmUgdmlzaWJsZSwgYnV0IGl0IHdhcydcbiAgICAgICwgYWN0dWFsXG4gICAgKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGFnTmFtZScsIGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSxcbiAgICAgICAgYWN0dWFsID0gZWwudGFnTmFtZTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgYWN0dWFsLnRvVXBwZXJDYXNlKCkgPT09IHRhZ05hbWUudG9VcHBlckNhc2UoKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIHRhZ05hbWUgJyArIHRhZ05hbWUgKyAnLCBidXQgaXQgd2FzICcgKyBhY3R1YWxcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gbm90IGhhdmUgdGFnTmFtZSAnICsgdGFnTmFtZSArICcsIGJ1dCBpdCB3YXMgJyArIGFjdHVhbFxuICAgICAgLCBhY3R1YWxcbiAgICApXG4gIH0pXG59KSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNoYWlTdHlsZVxuXG5mdW5jdGlvbiBjaGFpU3R5bGUoY2hhaSwgdXRpbHMpIHtcbiAgY29uc3Qge0Fzc2VydGlvbn0gPSBjaGFpXG4gIGNvbnN0IHtmbGFnfSA9IHV0aWxzXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3R5bGUnLCBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUgPSAnJykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgY29uc3QgaXNOb25Db2xvcnMgPSBzdHlsZVtwcm9wZXJ0eV0gPT09ICdyZ2JhKDAsIDAsIDAsIDApJyAvLyB3ZWJraXRcbiAgICAgIHx8IHN0eWxlW3Byb3BlcnR5XSA9PT0gJ3RyYW5zcGFyZW50JyAvLyBmaXJlZm94XG5cbiAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gaXNOb25Db2xvcnNcbiAgICAgID8gJydcbiAgICAgIDogc3R5bGVbcHJvcGVydHldXG5cbiAgICBjb25zdCBhc3NlcnRpb24gPSB2YWx1ZVxuICAgICAgPyBjb21wYXJlQ1NTVmFsdWUocHJvcGVydHlWYWx1ZSwgdmFsdWUpXG4gICAgICA6IEJvb2xlYW4ocHJvcGVydHlWYWx1ZSlcblxuICAgIGNvbnN0IGVsZW1lbnRUYWcgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgY29uc3QgdGhyb3dNZXNzYWdlID0gYGV4cGVjdCAke2VsZW1lbnRUYWd9IHRvIGhhdmUgeyR7cHJvcGVydHl9OiAke3ZhbHVlfX0sIGlzIHJlY2VpdmluZyB7JHtwcm9wZXJ0eX06ICR7cHJvcGVydHlWYWx1ZX19YFxuICAgIGNvbnN0IHRocm93TWVzc2FnZU5lZ2F0aXZlID0gYGV4cGVjdCAke2VsZW1lbnRUYWd9IHRvIG5vdCBoYXZlIHske3Byb3BlcnR5fTogJHt2YWx1ZX19LCBpcyByZWNlaXZpbmcgeyR7cHJvcGVydHl9OiAke3Byb3BlcnR5VmFsdWV9fWBcblxuICAgIHRoaXMuYXNzZXJ0KGFzc2VydGlvbiwgdGhyb3dNZXNzYWdlLCB0aHJvd01lc3NhZ2VOZWdhdGl2ZSwgdmFsdWUpXG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQ1NTVmFsdWUoY29tcHV0ZWQsIGV4cGVjdGVkKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eUhpZmVuQ2FzZSA9IHByb3BlcnR5LnJlcGxhY2UoL1tBLVpdL2csIChtYXRjaCkgPT4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKSlcbiAgICAgIGNvbnN0IGZha2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZmFrZS5zdHlsZS5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplXG4gICAgICBmYWtlLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5SGlmZW5DYXNlLCBleHBlY3RlZCwgJ2ltcG9ydGFudCcpXG4gICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgICAgaWZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG4gICAgICBpZnJhbWUuYXBwZW5kQ2hpbGQoZmFrZSlcbiAgICAgIGNvbnN0IGZha2VTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGZha2UpXG4gICAgICBjb25zdCB2YWx1ZSA9IGZha2VTdHlsZVtwcm9wZXJ0eV1cblxuICAgICAgY29uc3QgaGFzQXV0b1ZhbHVlID0gdmFsdWUuaW5jbHVkZXMoJ2F1dG8nKVxuICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodmFsdWUpLnJlcGxhY2UoL2F1dG8vZywgJyhcXFxcZCsoLlxcXFxkKyk/cHh8YXV0byknKSlcblxuICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGhhc0F1dG9WYWx1ZVxuICAgICAgICA/IHJlZy50ZXN0KGNvbXB1dGVkKVxuICAgICAgICA6IGNvbXB1dGVkID09PSB2YWx1ZVxuXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSlcblxuICAgICAgcmV0dXJuIGNvbXBhcmlzb25SZXN1bHRcbiAgICB9XG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JlZ0V4cC5lc2NhcGUvYmxvYi9tYXN0ZXIvcG9seWZpbGwuanNcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qICFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgZ2V0UHJvdG90eXBlT2ZFeGlzdHMgPSB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nO1xudmFyIHByb21pc2VFeGlzdHMgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogc2VsZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIGlzRG9tID0gJ2xvY2F0aW9uJyBpbiBnbG9iYWxPYmplY3QgJiYgJ2RvY3VtZW50JyBpbiBnbG9iYWxPYmplY3Q7XG52YXIgaHRtbEVsZW1lbnRFeGlzdHMgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGlzQXJyYXlFeGlzdHMgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcbnZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFeGlzdHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrTWFwRXhpc3RzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZGF0YVZpZXdFeGlzdHMgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbEl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEVudHJpZXNFeGlzdHMgPSBzZXRFeGlzdHMgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBtYXBFbnRyaWVzRXhpc3RzID0gbWFwRXhpc3RzICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZkV4aXN0cyAmJiBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbnZhciBtYXBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mRXhpc3RzICYmIG1hcEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBNYXAoKS5lbnRyaWVzKCkpO1xudmFyIGFycmF5SXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgc3RyaW5nSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciB0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCA9IDg7XG52YXIgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoID0gLTE7XG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2VzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LFxuICogbm9ybWFsaXNpbmcgYmVoYXZpb3VyIGFjcm9zcyBlbmdpbmUgdmVyc2lvbnMgJiB3ZWxsIG9wdGltaXNlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZURldGVjdChvYmopIHtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDMsMDM5LDAzNSBvcHMvc2VjIMKxMS42MiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAxLDQyNCwxMzggb3BzL3NlYyDCsTQuNTQlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMSw2NTMsMTUzIG9wcy9zZWMgwrExLjkxJSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDksOTc4LDY2MCBvcHMvc2VjIMKxMS45MiUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAyLDU1Niw3Njkgb3BzL3NlYyDCsTEuNzMlICg3NyBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMzgsNTY0LDc5NiBvcHMvc2VjIMKxMS4xNSUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAzMSwxNDgsOTQwIG9wcy9zZWMgwrExLjEwJSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDMyLDY3OSwzMzAgb3BzL3NlYyDCsTEuOTAlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggMzIsMzYzLDM2OCBvcHMvc2VjIMKxMS4wNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAzMSwyOTYsODcwIG9wcy9zZWMgwrEwLjk2JSAoODMgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgdmFyIHR5cGVvZk9iaiA9IHR5cGVvZiBvYmo7XG4gIGlmICh0eXBlb2ZPYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGVvZk9iajtcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAyOCw2NDUsNzY1IG9wcy9zZWMgwrExLjE3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDM2LDQyOCw5NjIgb3BzL3NlYyDCsTEuMzclICg4NCBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdylgYFxuICAgKiAgLSBOb2RlID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFBoYW50b21KUyA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgRWRnZSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpYGBcbiAgICogIC0gQ2hyb21lIFdvcmtlciA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94IFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIFNhZmFyaSBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSAxMSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSBFZGdlIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqL1xuICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QpIHtcbiAgICByZXR1cm4gJ2dsb2JhbCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMiw4ODgsMzUyIG9wcy9zZWMgwrEwLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIyLDQ3OSw2NTAgb3BzL3NlYyDCsTAuOTYlICg4MSBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAoaXNBcnJheUV4aXN0cyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gJ0FycmF5JztcbiAgfVxuXG4gIGlmIChpc0RvbSkge1xuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2xvY2F0aW9uKVxuICAgICAqIFdoYXRXRyBIVE1MJDcuNy4zIC0gVGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cubG9jYXRpb24pYGBcbiAgICAgKiAgLSBJRSA8PTExID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG9jdW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkMy4xLjEgLSBUaGUgYERvY3VtZW50YCBvYmplY3RcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTI2ODA5MjY4KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiAgICAgICBXaGF0V0cgSFRNTCBzdGF0ZXM6XG4gICAgICogICAgICAgICA+IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIFdpbmRvdyBvYmplY3RzIG11c3QgYWxzbyBoYXZlIGFcbiAgICAgKiAgICAgICAgID4gd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWRcbiAgICAgKiAgICAgICAgID4gSFRNTERvY3VtZW50IHdob3NlIHZhbHVlIGlzIHRoZSBEb2N1bWVudCBpbnRlcmZhY2Ugb2JqZWN0LlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpYGBcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjbWltZXR5cGVhcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBNaW1lVHlwZUFycmF5XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IubWltZVR5cGVzKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TTWltZVR5cGVzQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5taW1lVHlwZXMpIHtcbiAgICAgIHJldHVybiAnTWltZVR5cGVBcnJheSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBQbHVnaW5BcnJheVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLnBsdWdpbnMpYGBcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNQbHVnaW5zQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5wbHVnaW5zKSB7XG4gICAgICByZXR1cm4gJ1BsdWdpbkFycmF5JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuNC40IC0gVGhlIGBibG9ja3F1b3RlYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MUXVvdGVFbGVtZW50YFxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IEhUTUxCbG9ja0VsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdCTE9DS1FVT1RFJykge1xuICAgICAgcmV0dXJuICdIVE1MUXVvdGVFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlZGF0YWNlbGxlbGVtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50YFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKVxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgIHJldHVybiAnSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlaGVhZGVyY2VsbGVsZW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudGBcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSlcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKGh0bWxFbGVtZW50RXhpc3RzICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnVEgnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JztcbiAgICB9XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDYyNSw2NDQgb3BzL3NlYyDCsTEuNTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCAxLDI3OSw4NTIgb3BzL3NlYyDCsTIuOTElICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCAxLDE3OCwxODUgb3BzL3NlYyDCsTEuOTUlICg4MyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCAxLDAwOCwzODAgb3BzL3NlYyDCsTIuMjUlICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCAxLDEyOCwwNDAgb3BzL3NlYyDCsTIuMTElICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCAxLDE3MCwxMTkgb3BzL3NlYyDCsTIuODglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCAxLDE3NiwzNDggb3BzL3NlYyDCsTUuNzklICg4NiBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCAxLDA1OCw3MDcgb3BzL3NlYyDCsTQuOTQlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCAxLDExMCw2MzMgb3BzL3NlYyDCsTQuMjAlICg4MCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDcsMTA1LDY3MSBvcHMvc2VjIMKxMTMuNDclICg2NCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCA1LDg4Nyw5MTIgb3BzL3NlYyDCsTEuNDYlICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCA2LDQ5MSw2NjEgb3BzL3NlYyDCsTEuNzYlICg3OSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCA2LDU1OSw3OTUgb3BzL3NlYyDCsTEuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCA2LDQ2Myw5NjYgb3BzL3NlYyDCsTEuNDMlICg4NSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCA1LDY0MSw4NDEgb3BzL3NlYyDCsTMuNDklICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCA2LDU4Myw1MTEgb3BzL3NlYyDCsTEuOTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCA2LDYwNiwwNzggb3BzL3NlYyDCsTEuNzQlICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCA2LDYwMiwyMjQgb3BzL3NlYyDCsTEuNzclICg4MyBydW5zIHNhbXBsZWQpXG4gICovXG4gIHZhciBzdHJpbmdUYWcgPSAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICBpZiAodHlwZW9mIHN0cmluZ1RhZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nVGFnO1xuICB9XG5cbiAgaWYgKGdldFByb3RvdHlwZU9mRXhpc3RzKSB7XG4gICAgdmFyIG9ialByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDEsNzcyLDM4NSBvcHMvc2VjIMKxMS44NSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMiwxNDMsNjM0IG9wcy9zZWMgwrEyLjQ2JSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMyw5MjgsMDA5IG9wcy9zZWMgwrEwLjY1JSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAzLDkzMSwxMDggb3BzL3NlYyDCsTAuNTglICg4NCBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAob2JqUHJvdG90eXBlID09PSBSZWdFeHAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1JlZ0V4cCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMiwxMzAsMDc0IG9wcy9zZWMgwrE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMyw5NTMsNzc5IG9wcy9zZWMgwrExLjM1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gRGF0ZS5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtcHJvbWlzZS5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjUuNC41LjQgLSBQcm9taXNlLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJQcm9taXNlXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQcm9taXNlLnJlc29sdmUoKSlgYFxuICAgICAqICAtIENocm9tZSA8PTQ3ID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gRWRnZSA8PTIwID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gRmlyZWZveCAyOS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAgICogIC0gU2FmYXJpIDcuMS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAgICovXG4gICAgaWYgKHByb21pc2VFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBQcm9taXNlLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdQcm9taXNlJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICBzZXQgICAgICAgICAgICAgICAgeCAyLDIyMiwxODYgb3BzL3NlYyDCsTEuMzElICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICBzZXQgICAgICAgICAgICAgICAgeCA0LDU0NSw4Nzkgb3BzL3NlYyDCsTEuMTMlICg4MyBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gU2V0LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdTZXQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIMKxMS41OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDQsMTgzLDk0NSBvcHMvc2VjIMKxNi41OSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBNYXAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ01hcCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgd2Vha3NldCAgICAgICAgICAgIHggMSwzMjMsMjIwIG9wcy9zZWMgwrEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgd2Vha3NldCAgICAgICAgICAgIHggNCwyMzcsNTEwIG9wcy9zZWMgwrEyLjAxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKHdlYWtTZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrU2V0LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdXZWFrU2V0JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICB3ZWFrbWFwICAgICAgICAgICAgeCAxLDUwMCwyNjAgb3BzL3NlYyDCsTIuMDIlICg3OCBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICB3ZWFrbWFwICAgICAgICAgICAgeCAzLDg4MSwzODQgb3BzL3NlYyDCsTEuNDUlICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAod2Vha01hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtNYXAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1dlYWtNYXAnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLWRhdGF2aWV3LnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKGRhdGFWaWV3RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ0RhdGFWaWV3JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lbWFwaXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpLmVudHJpZXMoKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBtYXBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdNYXAgSXRlcmF0b3InO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzZXRpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgU2V0KCkuZW50cmllcygpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHNldEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1NldCBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChhcnJheUl0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gYXJyYXlJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdBcnJheSBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1N0cmluZyBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgwrExLjY3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggNSw4MzgsMDAwIG9wcy9zZWMgwrEwLjk5JSAoODQgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3RcbiAgICAucHJvdG90eXBlXG4gICAgLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqKVxuICAgIC5zbGljZSh0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCwgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnR5cGVEZXRlY3QgPSBtb2R1bGUuZXhwb3J0cztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbHMgU3ltYm9sOiB0cnVlLCBVaW50OEFycmF5OiB0cnVlLCBXZWFrTWFwOiB0cnVlICovXG4vKiFcbiAqIGRlZXAtZXFsXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcbmZ1bmN0aW9uIEZha2VNYXAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbn1cbkZha2VNYXAucHJvdG90eXBlID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXJNYXAoKSB7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXRNYXAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldE1hcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gZGVsZXRlTWFwKGtleSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdCh0aGlzLnZhbHVlcy5zbGljZShpbmRleCArIDEpKTtcbiAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cy5zbGljZSgwLCBpbmRleCkuY29uY2F0KHRoaXMua2V5cy5zbGljZShpbmRleCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG52YXIgTWVtb2l6ZU1hcCA9IG51bGw7XG5pZiAodHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgTWVtb2l6ZU1hcCA9IFdlYWtNYXA7XG59IGVsc2Uge1xuICBNZW1vaXplTWFwID0gRmFrZU1hcDtcbn1cblxuLyohXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIE1lbW9pemVNYXAgaGFzIHJlY29yZGVkIGEgcmVzdWx0IG9mIHRoZSB0d28gb3BlcmFuZHNcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwKSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gbGVmdEhhbmRNYXAuZ2V0KHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFNldCB0aGUgcmVzdWx0IG9mIHRoZSBlcXVhbGl0eSBpbnRvIHRoZSBNZW1vaXplTWFwXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXAsIHJlc3VsdCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGxlZnRIYW5kTWFwID0gbmV3IE1lbW9pemVNYXAoKTtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgICBtZW1vaXplTWFwLnNldChsZWZ0SGFuZE9wZXJhbmQsIGxlZnRIYW5kTWFwKTtcbiAgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5tb2R1bGUuZXhwb3J0cy5NZW1vaXplTWFwID0gTWVtb2l6ZU1hcDtcblxuLyoqXG4gKiBBc3NlcnQgZGVlcGx5IG5lc3RlZCBzYW1lVmFsdWUgZXF1YWxpdHkgYmV0d2VlbiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElmIHdlIGhhdmUgYSBjb21wYXJhdG9yLCB3ZSBjYW4ndCBhc3N1bWUgYW55dGhpbmc7IHNvIGJhaWwgdG8gaXRzIGNoZWNrIGZpcnN0LlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gIH1cblxuICAvLyBEZWVwZXIgY29tcGFyaXNvbnMgYXJlIHB1c2hlZCB0aHJvdWdoIHRvIGEgbGFyZ2VyIGZ1bmN0aW9uXG4gIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBNYW55IGNvbXBhcmlzb25zIGNhbiBiZSBjYW5jZWxlZCBvdXQgZWFybHkgdmlhIHNpbXBsZSBlcXVhbGl0eSBvciBwcmltaXRpdmUgY2hlY2tzLlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufG51bGx9IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICAvLyBFcXVhbCByZWZlcmVuY2VzIChleGNlcHQgZm9yIE51bWJlcnMpIGNhbiBiZSByZXR1cm5lZCBlYXJseVxuICBpZiAobGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kKSB7XG4gICAgLy8gSGFuZGxlICstMCBjYXNlc1xuICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgIT09IDAgfHwgMSAvIGxlZnRIYW5kT3BlcmFuZCA9PT0gMSAvIHJpZ2h0SGFuZE9wZXJhbmQ7XG4gIH1cblxuICAvLyBoYW5kbGUgTmFOIGNhc2VzXG4gIGlmIChcbiAgICBsZWZ0SGFuZE9wZXJhbmQgIT09IGxlZnRIYW5kT3BlcmFuZCAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJpZ2h0SGFuZE9wZXJhbmQgIT09IHJpZ2h0SGFuZE9wZXJhbmQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBBbnl0aGluZyB0aGF0IGlzIG5vdCBhbiAnb2JqZWN0JywgaS5lLiBzeW1ib2xzLCBmdW5jdGlvbnMsIGJvb2xlYW5zLCBudW1iZXJzLFxuICAvLyBzdHJpbmdzLCBhbmQgdW5kZWZpbmVkLCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLlxuICBpZiAoaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIC8vIEVhc3kgb3V0IGIvYyBpdCB3b3VsZCBoYXZlIHBhc3NlZCB0aGUgZmlyc3QgZXF1YWxpdHkgY2hlY2tcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogVGhlIG1haW4gbG9naWMgb2YgdGhlIGBkZWVwRXF1YWxgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4qL1xuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tZW1vaXplID0gb3B0aW9ucy5tZW1vaXplID09PSBmYWxzZSA/IGZhbHNlIDogb3B0aW9ucy5tZW1vaXplIHx8IG5ldyBNZW1vaXplTWFwKCk7XG4gIHZhciBjb21wYXJhdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3I7XG5cbiAgLy8gQ2hlY2sgaWYgYSBtZW1vaXplZCByZXN1bHQgZXhpc3RzLlxuICB2YXIgbWVtb2l6ZVJlc3VsdExlZnQgPSBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0TGVmdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0TGVmdDtcbiAgfVxuICB2YXIgbWVtb2l6ZVJlc3VsdFJpZ2h0ID0gbWVtb2l6ZUNvbXBhcmUocmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdFJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRSaWdodDtcbiAgfVxuXG4gIC8vIElmIGEgY29tcGFyYXRvciBpcyBwcmVzZW50LCB1c2UgaXQuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JSZXN1bHQgPSBjb21wYXJhdG9yKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgLy8gQ29tcGFyYXRvcnMgbWF5IHJldHVybiBudWxsLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gZ28gYmFjayB0byBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIGlmIChjb21wYXJhdG9yUmVzdWx0ID09PSBmYWxzZSB8fCBjb21wYXJhdG9yUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBjb21wYXJhdG9yUmVzdWx0KTtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yUmVzdWx0O1xuICAgIH1cbiAgICAvLyBUbyBhbGxvdyBjb21wYXJhdG9ycyB0byBvdmVycmlkZSAqYW55KiBiZWhhdmlvciwgd2UgcmFuIHRoZW0gZmlyc3QuIFNpbmNlIGl0IGRpZG4ndCBkZWNpZGVcbiAgICAvLyB3aGF0IHRvIGRvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIGJhc2ljIHRlc3RzIGZpcnN0IGJlZm9yZSB3ZSBtb3ZlIG9uLlxuICAgIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IG1lbW9pemUgdGhpcywgaXQgdGFrZXMgbG9uZ2VyIHRvIHNldC9yZXRyaWV2ZSB0aGFuIHRvIGp1c3QgY29tcGFyZS5cbiAgICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlZnRIYW5kVHlwZSA9IHR5cGUobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kVHlwZSAhPT0gdHlwZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIG9wZXJhbmRzIGluIHRoZSBtZW1vaXplIG9iamVjdCB0byBwcmV2ZW50IGJsb3dpbmcgdGhlIHN0YWNrXG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHRydWUpO1xuXG4gIHZhciByZXN1bHQgPSBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpO1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChsZWZ0SGFuZFR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICAvLyBJZiB0aGVzZSB0eXBlcyBhcmUgdGhlaXIgaW5zdGFuY2UgdHlwZXMgKGUuZy4gYG5ldyBOdW1iZXJgKSB0aGVuIHJlLWRlZXBFcXVhbCBhZ2FpbnN0IHRoZWlyIHZhbHVlc1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQudmFsdWVPZigpLCByaWdodEhhbmRPcGVyYW5kLnZhbHVlT2YoKSk7XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZDtcbiAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIHJldHVybiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGNhc2UgJ0dlbmVyYXRvcic6XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdEYXRhVmlldyc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQuYnVmZmVyKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZC5idWZmZXIpLCBvcHRpb25zKTtcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdNYXAnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7UmVnRXhwfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZC50b1N0cmluZygpID09PSByaWdodEhhbmRPcGVyYW5kLnRvU3RyaW5nKCk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gU2V0cy9NYXBzIGZvciBlcXVhbGl0eS4gRmFzdGVyIHRoYW4gb3RoZXIgZXF1YWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U2V0fSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7U2V0fSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgU2V0I2VudHJpZXMgb3IgU2V0I0BAaXRlcmF0b3IsIHNvIHdlIG5lZWQgbWFudWFsbHkgcG9wdWxhdGUgdXNpbmcgU2V0I2ZvckVhY2hcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplICE9PSByaWdodEhhbmRPcGVyYW5kLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGxlZnRIYW5kSXRlbXMgPSBbXTtcbiAgdmFyIHJpZ2h0SGFuZEl0ZW1zID0gW107XG4gIGxlZnRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIGxlZnRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByaWdodEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgcmlnaHRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEl0ZW1zLnNvcnQoKSwgcmlnaHRIYW5kSXRlbXMuc29ydCgpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0cyBzdWNoIGFzIEFycmF5cywgVHlwZWRBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0gbGVmdEhhbmRPcGVyYW5kLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAhPT0gcmlnaHRIYW5kT3BlcmFuZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2luZGV4XSwgcmlnaHRIYW5kT3BlcmFuZFtpbmRleF0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGdlbmVyYXRvciBvYmplY3RzIHN1Y2ggYXMgdGhvc2UgcmV0dXJuZWQgYnkgZ2VuZXJhdG9yIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGdldEdlbmVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKSwgZ2V0R2VuZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgaXRlcmF0b3IgZW50cmllcyBmcm9tIHRoZSBnaXZlbiBPYmplY3QuIElmIHRoZSBPYmplY3QgaGFzIG5vIEBAaXRlcmF0b3IgZnVuY3Rpb24sIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG4gKiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgaXRlcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIEBAaXRlcmF0b3IgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEBAaXRlcmF0b3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JFbnRyaWVzKHRhcmdldCkge1xuICBpZiAoaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXRHZW5lcmF0b3JFbnRyaWVzKHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgIH0gY2F0Y2ggKGl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGVudHJpZXMgZnJvbSBhIEdlbmVyYXRvci4gVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGdlbmVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzLlxuICpcbiAqIEBwYXJhbSB7R2VuZXJhdG9yfSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBHZW5lcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyYXRvckVudHJpZXMoZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICB2YXIgYWNjdW11bGF0b3IgPSBbIGdlbmVyYXRvclJlc3VsdC52YWx1ZSBdO1xuICB3aGlsZSAoZ2VuZXJhdG9yUmVzdWx0LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgICBhY2N1bXVsYXRvci5wdXNoKGdlbmVyYXRvclJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gdGhlIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZUtleXModGFyZ2V0KSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuLyohXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBvYmplY3RzIGhhdmUgbWF0Y2hpbmcgdmFsdWVzLCBnaXZlbiBhIHNldCBvZiBrZXlzLiBEZWZlcnMgdG8gZGVlcEVxdWFsIGZvciB0aGUgZXF1YWxpdHkgY2hlY2sgb2ZcbiAqIGVhY2gga2V5LiBJZiBhbnkgdmFsdWUgb2YgdGhlIGdpdmVuIGtleSBpcyBub3QgZXF1YWwsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZSAoZWFybHkpLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBBbiBhcnJheSBvZiBrZXlzIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBvZiBsZWZ0SGFuZE9wZXJhbmQgYW5kIHJpZ2h0SGFuZE9wZXJhbmQgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRba2V5c1tpXV0sIHJpZ2h0SGFuZE9wZXJhbmRba2V5c1tpXV0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIE9iamVjdHMuIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbCBkZWZlciB0byBgZGVlcEVxdWFsYFxuICogZm9yIGVhY2ggZW51bWVyYWJsZSBrZXkgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZWZ0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCAmJiBsZWZ0SGFuZEtleXMubGVuZ3RoID09PSByaWdodEhhbmRLZXlzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kS2V5cy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kS2V5cy5zb3J0KCk7XG4gICAgaWYgKGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRLZXlzLCByaWdodEhhbmRLZXlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kS2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgbGVmdEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRFbnRyaWVzLmxlbmd0aCAmJiBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRFbnRyaWVzLCByaWdodEhhbmRFbnRyaWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyohXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgcHJpbWl0aXZlLlxuICpcbiAqIFRoaXMgaW50ZW50aW9uYWxseSByZXR1cm5zIHRydWUgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZSxcbiAqIGluY2x1ZGluZyBmdW5jdGlvbnMgYW5kIHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jztcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKVxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpXG5cbnZhciBERUZBVUxUX1RPTEVSQU5DRSA9IDFlLTZcblxuLyoqXG4gKiBzbWFsbCB1dGlsaXR5IGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiBpc051bWJlciAodmFsKSB7XG4gIHJldHVybiB0eXBlKHZhbCkgPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIGJvdGhOdW1iZXJzIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gaXNOdW1iZXIocmlnaHQpICYmIGlzTnVtYmVyKGxlZnQpXG59XG5cbmZ1bmN0aW9uIGFsbW9zdEVxdWFsIChsZWZ0LCByaWdodCwgdG9sKSB7XG4gIHJldHVybiBNYXRoLmFicyhsZWZ0IC0gcmlnaHQpIDw9IHRvbFxufVxuXG4vKipcbiAqIE1ha2VzIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gZGVlcEVxdWFsLlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIG51bGwgaWYgYm90aCBhcmd1bWVudHMgYXJlIG5vdCBudW1iZXJzLFxuICogaW5kaWNhdGluZyB0aGF0IGRlZXBFcXVhbCBzaG91bGQgcHJvY2VlZCB3aXRoIG90aGVyIGVxdWFsaXR5IGNoZWNrc1xuICovXG5mdW5jdGlvbiBjb21wYXJhdG9yICh0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChib3RoTnVtYmVycyhsZWZ0LCByaWdodCkpIHtcbiAgICAgIHJldHVybiBhbG1vc3RFcXVhbChsZWZ0LCByaWdodCwgdG9sZXJhbmNlKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogU2V0cyBnbG9iYWwgdG9sZXJhbmNlIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIGNoYWkudXNlXG4gKiBAc2VlIGh0dHA6Ly9jaGFpanMuY29tL2d1aWRlL3BsdWdpbnMvXG4gKi9cbmZ1bmN0aW9uIGNoYWlBbG1vc3QgKGN1c3RvbVRvbGVyYW5jZSkge1xuICB2YXIgc3RhbmRhcmRUb2xlcmFuY2UgPSBjdXN0b21Ub2xlcmFuY2UgfHwgREVGQVVMVF9UT0xFUkFOQ0VcblxuICByZXR1cm4gZnVuY3Rpb24gKGNoYWksIHV0aWxzKSB7XG4gICAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgdmFyIGZsYWcgPSB1dGlscy5mbGFnXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNoYWxsb3cgZXF1YWxpdHkgZnVuY3Rpb24gdG8gb3ZlcnJpZGVcbiAgICAgKiAuZXF1YWwsIC5lcXVhbHMsIC5lcSB0aGF0IHRlc3RzICdhbG1vc3QnIGVxdWFsaXR5XG4gICAgICogaWYgYm90aCB2YWx1ZXMgYXJlIG51bWJlcnMgYW5kIGEgJ3RvbGVyYW5jZScgZmxhZyBpcyBzZXQuXG4gICAgICogU2VuZHMgdG8gZGVlcCBlcXVhbGl0eSBjaGVjayBpZiBkZWVwIGZsYWcgaXMgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcnJpZGVBc3NlcnRFcXVhbCAoX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXNzZXJ0RXF1YWwgKHZhbCwgbXNnKSB7XG4gICAgICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpXG5cbiAgICAgICAgdmFyIGRlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGZsYWcodGhpcywgJ3RvbGVyYW5jZScpXG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcWwodmFsKVxuICAgICAgICB9IGVsc2UgaWYgKHRvbGVyYW5jZSAmJiBib3RoTnVtYmVycyh2YWwsIHRoaXMuX29iaikpIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChhbG1vc3RFcXVhbCh2YWwsIHRoaXMuX29iaiwgdG9sZXJhbmNlKSxcbiAgICAgICAgICAgICdleHBlY3RlZCAje3RoaXN9IHRvIGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGhpcy5fb2JqLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZGVlcCBlcXVhbGl0eSBmdW5jdGlvbiB0byBvdmVycmlkZVxuICAgICAqIC5lcWwsIC5lcWxzIHRoYXQgdGVzdHMgJ2FsbW9zdCcgZXF1YWxpdHkgaWYgYm90aCBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWVzIGFyZSBudW1iZXJzIGFuZCB0b2xlcmFuY2UgZmxhZyBpcyBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVycmlkZUFzc2VydEVxbCAoX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXNzZXJ0RXFsICh2YWwsIG1zZykge1xuICAgICAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKVxuXG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSBmbGFnKHRoaXMsICd0b2xlcmFuY2UnKVxuXG4gICAgICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGRlZXBFcXVhbCh2YWwsIHRoaXMuX29iaiwgeyBjb21wYXJhdG9yOiBjb21wYXJhdG9yKHRvbGVyYW5jZSkgfSksXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgYWxtb3N0IGVxdWFsICN7ZXhwfScsXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGhpcy5fb2JqLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC5hbG1vc3QoKSBtZXRob2QuIFRvIGJlIHVzZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2hhaW4gbGlrZTpcbiAgICAgKiBleHBlY3QoNCkudG8ubm90LmJlLmFsbW9zdCg1LCAxLjUpLiBTaW1wbHkgYWRkcyB0b2xlcmFuY2UgZmxhZyB0aGVuIGNhbGxzXG4gICAgICogLmVxdWFsLiBUaGlzIHdpbGwgcmVkaXJlY3QgdG8gLmVxbCBpZiBkZWVwIGZsYWcgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWV0aG9kICh2YWwsIHRvbGVyYW5jZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdG9sZXJhbmNlID0gdG9sZXJhbmNlT3ZlcnJpZGUgfHwgc3RhbmRhcmRUb2xlcmFuY2VcblxuICAgICAgZmxhZyh0aGlzLCAndG9sZXJhbmNlJywgdG9sZXJhbmNlKVxuXG4gICAgICByZXR1cm4gdGhpcy5lcXVhbCh2YWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLmFsbW9zdCBjaGFpbmFibGUgcHJvcGVydHkgdG8gYmUgdXNlZCBsaWtlOlxuICAgICAqIGV4cGVjdCgzLjk5OTk5OTk5KS50by5hbG1vc3QuZXF1YWwoNCkuIFNpbXBseSBhZGRzXG4gICAgICogdG9sZXJhbmNlIGZsYWcgdG8gYmUgcmVhZCBieSBlcXVhbGl0eSBjaGVja2luZyBtZXRob2RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgICBmbGFnKHRoaXMsICd0b2xlcmFuY2UnLCBzdGFuZGFyZFRvbGVyYW5jZSlcbiAgICB9XG5cbiAgICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbG1vc3QnLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG5cbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcXVhbCcsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXF1YWxzJywgb3ZlcnJpZGVBc3NlcnRFcXVhbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcScsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG5cbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWwnLCBvdmVycmlkZUFzc2VydEVxbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWxzJywgb3ZlcnJpZGVBc3NlcnRFcWwpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGFpQWxtb3N0XG4iLCIvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIFN5bWJvbCAqL1xuLypqc2hpbnQgLVcwNTYgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgc3RyaW5ncywgbWVzc2FnZXMsIHByZWRpY2F0ZXMsIGZ1bmN0aW9ucywgYXNzZXJ0LCBub3QsIG1heWJlLFxuICAgICAgY29sbGVjdGlvbnMsIHNsaWNlLCBuZWdpbmYsIHBvc2luZiwgaXNBcnJheSwgaGF2ZVN5bWJvbHM7XG5cbiAgc3RyaW5ncyA9IHtcbiAgICB2OiAndmFsdWUnLFxuICAgIG46ICdudW1iZXInLFxuICAgIHM6ICdzdHJpbmcnLFxuICAgIGI6ICdib29sZWFuJyxcbiAgICBvOiAnb2JqZWN0JyxcbiAgICB0OiAndHlwZScsXG4gICAgYTogJ2FycmF5JyxcbiAgICBhbDogJ2FycmF5LWxpa2UnLFxuICAgIGk6ICdpdGVyYWJsZScsXG4gICAgZDogJ2RhdGUnLFxuICAgIGY6ICdmdW5jdGlvbicsXG4gICAgbDogJ2xlbmd0aCdcbiAgfTtcblxuICBtZXNzYWdlcyA9IHt9O1xuICBwcmVkaWNhdGVzID0ge307XG5cbiAgW1xuICAgIHsgbjogJ2VxdWFsJywgZjogZXF1YWwsIHM6ICd2JyB9LFxuICAgIHsgbjogJ3VuZGVmaW5lZCcsIGY6IGlzVW5kZWZpbmVkLCBzOiAndicgfSxcbiAgICB7IG46ICdudWxsJywgZjogaXNOdWxsLCBzOiAndicgfSxcbiAgICB7IG46ICdhc3NpZ25lZCcsIGY6IGFzc2lnbmVkLCBzOiAndicgfSxcbiAgICB7IG46ICdwcmltaXRpdmUnLCBmOiBwcmltaXRpdmUsIHM6ICd2JyB9LFxuICAgIHsgbjogJ2luY2x1ZGVzJywgZjogaW5jbHVkZXMsIHM6ICd2JyB9LFxuICAgIHsgbjogJ3plcm8nLCBmOiB6ZXJvIH0sXG4gICAgeyBuOiAnaW5maW5pdHknLCBmOiBpbmZpbml0eSB9LFxuICAgIHsgbjogJ251bWJlcicsIGY6IG51bWJlciB9LFxuICAgIHsgbjogJ2ludGVnZXInLCBmOiBpbnRlZ2VyIH0sXG4gICAgeyBuOiAnZXZlbicsIGY6IGV2ZW4gfSxcbiAgICB7IG46ICdvZGQnLCBmOiBvZGQgfSxcbiAgICB7IG46ICdncmVhdGVyJywgZjogZ3JlYXRlciB9LFxuICAgIHsgbjogJ2xlc3MnLCBmOiBsZXNzIH0sXG4gICAgeyBuOiAnYmV0d2VlbicsIGY6IGJldHdlZW4gfSxcbiAgICB7IG46ICdncmVhdGVyT3JFcXVhbCcsIGY6IGdyZWF0ZXJPckVxdWFsIH0sXG4gICAgeyBuOiAnbGVzc09yRXF1YWwnLCBmOiBsZXNzT3JFcXVhbCB9LFxuICAgIHsgbjogJ2luUmFuZ2UnLCBmOiBpblJhbmdlIH0sXG4gICAgeyBuOiAncG9zaXRpdmUnLCBmOiBwb3NpdGl2ZSB9LFxuICAgIHsgbjogJ25lZ2F0aXZlJywgZjogbmVnYXRpdmUgfSxcbiAgICB7IG46ICdzdHJpbmcnLCBmOiBzdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2VtcHR5U3RyaW5nJywgZjogZW1wdHlTdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5U3RyaW5nJywgZjogbm9uRW1wdHlTdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2NvbnRhaW5zJywgZjogY29udGFpbnMsIHM6ICdzJyB9LFxuICAgIHsgbjogJ21hdGNoJywgZjogbWF0Y2gsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2Jvb2xlYW4nLCBmOiBib29sZWFuLCBzOiAnYicgfSxcbiAgICB7IG46ICdvYmplY3QnLCBmOiBvYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ2VtcHR5T2JqZWN0JywgZjogZW1wdHlPYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5T2JqZWN0JywgZjogbm9uRW1wdHlPYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ2luc3RhbmNlU3RyaWN0JywgZjogaW5zdGFuY2VTdHJpY3QsIHM6ICd0JyB9LFxuICAgIHsgbjogJ2luc3RhbmNlJywgZjogaW5zdGFuY2UsIHM6ICd0JyB9LFxuICAgIHsgbjogJ2xpa2UnLCBmOiBsaWtlLCBzOiAndCcgfSxcbiAgICB7IG46ICdhcnJheScsIGY6IGFycmF5LCBzOiAnYScgfSxcbiAgICB7IG46ICdlbXB0eUFycmF5JywgZjogZW1wdHlBcnJheSwgczogJ2EnIH0sXG4gICAgeyBuOiAnbm9uRW1wdHlBcnJheScsIGY6IG5vbkVtcHR5QXJyYXksIHM6ICdhJyB9LFxuICAgIHsgbjogJ2FycmF5TGlrZScsIGY6IGFycmF5TGlrZSwgczogJ2FsJyB9LFxuICAgIHsgbjogJ2l0ZXJhYmxlJywgZjogaXRlcmFibGUsIHM6ICdpJyB9LFxuICAgIHsgbjogJ2RhdGUnLCBmOiBkYXRlLCBzOiAnZCcgfSxcbiAgICB7IG46ICdmdW5jdGlvbicsIGY6IGlzRnVuY3Rpb24sIHM6ICdmJyB9LFxuICAgIHsgbjogJ2hhc0xlbmd0aCcsIGY6IGhhc0xlbmd0aCwgczogJ2wnIH0sXG4gIF0ubWFwKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG4gPSBkYXRhLm47XG4gICAgbWVzc2FnZXNbbl0gPSAnSW52YWxpZCAnICsgc3RyaW5nc1tkYXRhLnMgfHwgJ24nXTtcbiAgICBwcmVkaWNhdGVzW25dID0gZGF0YS5mO1xuICB9KTtcblxuICBmdW5jdGlvbnMgPSB7XG4gICAgYXBwbHk6IGFwcGx5LFxuICAgIG1hcDogbWFwLFxuICAgIGFsbDogYWxsLFxuICAgIGFueTogYW55XG4gIH07XG5cbiAgY29sbGVjdGlvbnMgPSBbICdhcnJheScsICdhcnJheUxpa2UnLCAnaXRlcmFibGUnLCAnb2JqZWN0JyBdO1xuICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgbmVnaW5mID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBwb3NpbmYgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICBoYXZlU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7XG5cbiAgZnVuY3Rpb25zID0gbWl4aW4oZnVuY3Rpb25zLCBwcmVkaWNhdGVzKTtcbiAgYXNzZXJ0ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKGFzc2VydE1vZGlmaWVyLCBhc3NlcnRJbXBsKTtcbiAgbm90ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKG5vdE1vZGlmaWVyLCBub3RJbXBsKTtcbiAgbWF5YmUgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMobWF5YmVNb2RpZmllciwgbWF5YmVJbXBsKTtcbiAgYXNzZXJ0Lm5vdCA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG5vdCk7XG4gIGFzc2VydC5tYXliZSA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlKTtcblxuICBjb2xsZWN0aW9ucy5mb3JFYWNoKGNyZWF0ZU9mUHJlZGljYXRlcyk7XG4gIGNyZWF0ZU9mTW9kaWZpZXJzKGFzc2VydCwgYXNzZXJ0TW9kaWZpZXIpO1xuICBjcmVhdGVPZk1vZGlmaWVycyhub3QsIG5vdE1vZGlmaWVyKTtcbiAgY29sbGVjdGlvbnMuZm9yRWFjaChjcmVhdGVNYXliZU9mTW9kaWZpZXJzKTtcblxuICBleHBvcnRGdW5jdGlvbnMobWl4aW4oZnVuY3Rpb25zLCB7XG4gICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgbm90OiBub3QsXG4gICAgbWF5YmU6IG1heWJlXG4gIH0pKTtcblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlcXVhbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBhbmQgYHJoc2AgYXJlIHN0cmljdGx5IGVxdWFsLCB3aXRob3V0IGNvZXJjaW9uLlxuICAgKiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGVxdWFsIChsaHMsIHJocykge1xuICAgIHJldHVybiBsaHMgPT09IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgdW5kZWZpbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBudWxsYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBudWxsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc051bGwgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFzc2lnbmVkYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2lnbmVkIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgcHJpbWl0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHByaW1pdGl2ZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBwcmltaXRpdmUgKGRhdGEpIHtcbiAgICB2YXIgdHlwZTtcblxuICAgIHN3aXRjaCAoZGF0YSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gdHlwZW9mIGRhdGE7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IChoYXZlU3ltYm9scyAmJiB0eXBlID09PSAnc3ltYm9sJyk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGB6ZXJvYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyB6ZXJvLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiB6ZXJvIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbmZpbml0eWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW5maW5pdHksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluZmluaXR5IChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IG5lZ2luZiB8fCBkYXRhID09PSBwb3NpbmY7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBudW1iZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBudW1iZXIgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgPiBuZWdpbmYgJiYgZGF0YSA8IHBvc2luZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGludGVnZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGludGVnZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGludGVnZXIgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAxID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZXZlbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZXZlbiBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGV2ZW4gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAyID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgb2RkYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBvZGQgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBvZGQgKGRhdGEpIHtcbiAgICByZXR1cm4gaW50ZWdlcihkYXRhKSAmJiBkYXRhICUgMiAhPT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGdyZWF0ZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIGByaHNgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBncmVhdGVyIChsaHMsIHJocykge1xuICAgIHJldHVybiBudW1iZXIobGhzKSAmJiBsaHMgPiByaHM7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBsZXNzYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBsaHNgIGlzIGEgbnVtYmVyIGxlc3MgdGhhbiBgcmhzYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGVzcyAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzIDwgcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYmV0d2VlbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBudW1iZXIgYmV0d2VlbiBgeGAgYW5kIGB5YCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmV0d2VlbiAoZGF0YSwgeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIGdyZWF0ZXIoZGF0YSwgeCkgJiYgZGF0YSA8IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3MoZGF0YSwgeCkgJiYgZGF0YSA+IHk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBncmVhdGVyT3JFcXVhbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBpcyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHJoc2AsIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdyZWF0ZXJPckVxdWFsIChsaHMsIHJocykge1xuICAgIHJldHVybiBudW1iZXIobGhzKSAmJiBsaHMgPj0gcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGVzc09yRXF1YWxgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGByaHNgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBsZXNzT3JFcXVhbCAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzIDw9IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGluUmFuZ2VgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyIGluIHRoZSByYW5nZSBgeC4ueWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluUmFuZ2UgKGRhdGEsIHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiBncmVhdGVyT3JFcXVhbChkYXRhLCB4KSAmJiBkYXRhIDw9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3NPckVxdWFsKGRhdGEsIHgpICYmIGRhdGEgPj0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHBvc2l0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHBvc2l0aXZlIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcG9zaXRpdmUgKGRhdGEpIHtcbiAgICByZXR1cm4gZ3JlYXRlcihkYXRhLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5lZ2F0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG5lZ2F0aXZlIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVnYXRpdmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbGVzcyhkYXRhLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZyAoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eVN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgdGhlIGVtcHR5IHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlTdHJpbmcgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gJyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBub25FbXB0eVN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBub24tZW1wdHkgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBub25FbXB0eVN0cmluZyAoZGF0YSkge1xuICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YSAhPT0gJyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBjb250YWluc2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgdGhhdCBjb250YWlucyBgc3Vic3RyaW5nYCwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29udGFpbnMgKGRhdGEsIHN1YnN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YS5pbmRleE9mKHN1YnN0cmluZykgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbWF0Y2hgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIHRoYXQgbWF0Y2hlcyBgcmVnZXhgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaCAoZGF0YSwgcmVnZXgpIHtcbiAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmICEhIGRhdGEubWF0Y2gocmVnZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYm9vbGVhbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBib29sZWFuIHZhbHVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBib29sZWFuIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IGZhbHNlIHx8IGRhdGEgPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBvYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgcGxhaW4tb2xkIEpTIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JqZWN0IChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eU9iamVjdGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBlbXB0eU9iamVjdCAoZGF0YSkge1xuICAgIHJldHVybiBvYmplY3QoZGF0YSkgJiYgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbm9uRW1wdHlPYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9uRW1wdHlPYmplY3QgKGRhdGEpIHtcbiAgICByZXR1cm4gb2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZVN0cmljdGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaW5zdGFuY2Ugb2YgYHByb3RvdHlwZWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluc3RhbmNlU3RyaWN0IChkYXRhLCBwcm90b3R5cGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBwcm90b3R5cGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaW5zdGFuY2Ugb2YgYHByb3RvdHlwZWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogRmFsbHMgYmFjayB0byB0ZXN0aW5nIGNvbnN0cnVjdG9yLm5hbWUgYW5kIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICogaWYgdGhlIGluaXRpYWwgaW5zdGFuY2VvZiB0ZXN0IGZhaWxzLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zdGFuY2UgKGRhdGEsIHByb3RvdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VTdHJpY3QoZGF0YSwgcHJvdG90eXBlKSB8fFxuICAgICAgICBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09IHByb3RvdHlwZS5uYW1lIHx8XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgJyArIHByb3RvdHlwZS5uYW1lICsgJ10nO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGlrZWAuXG4gICAqXG4gICAqIFRlc3RzIHdoZXRoZXIgYGRhdGFgICdxdWFja3MgbGlrZSBhIGR1Y2snLiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGhhcyBhbGxcbiAgICogb2YgdGhlIHByb3BlcnRpZXMgb2YgYGFyY2hldHlwZWAgKHRoZSAnZHVjaycpLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBsaWtlIChkYXRhLCBhcmNoZXR5cGUpIHtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhcmNoZXR5cGUpIHtcbiAgICAgIGlmIChhcmNoZXR5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IGZhbHNlIHx8IHR5cGVvZiBkYXRhW25hbWVdICE9PSB0eXBlb2YgYXJjaGV0eXBlW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdChkYXRhW25hbWVdKSAmJiBsaWtlKGRhdGFbbmFtZV0sIGFyY2hldHlwZVtuYW1lXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhcnJheWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5IChkYXRhKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eUFycmF5YC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBlbXB0eSBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlBcnJheSAoZGF0YSkge1xuICAgIHJldHVybiBhcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5vbkVtcHR5QXJyYXlgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBub25FbXB0eUFycmF5IChkYXRhKSB7XG4gICAgcmV0dXJuIGFycmF5KGRhdGEpICYmIGdyZWF0ZXIoZGF0YS5sZW5ndGgsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYXJyYXlMaWtlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlMaWtlIChkYXRhKSB7XG4gICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGdyZWF0ZXJPckVxdWFsKGRhdGEubGVuZ3RoLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGl0ZXJhYmxlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBpdGVyYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmFibGUgKGRhdGEpIHtcbiAgICBpZiAoISBoYXZlU3ltYm9scykge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGBhcnJheUxpa2VgIHByZWRpY2F0ZSBpbiBwcmUtRVM2IGVudmlyb25tZW50cy5cbiAgICAgIHJldHVybiBhcnJheUxpa2UoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGlzRnVuY3Rpb24oZGF0YVtTeW1ib2wuaXRlcmF0b3JdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGluY2x1ZGVzYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBjb250YWlucyBgdmFsdWVgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbmNsdWRlcyAoZGF0YSwgdmFsdWUpIHtcbiAgICB2YXIgaXRlcmF0b3IsIGl0ZXJhdGlvbiwga2V5cywgbGVuZ3RoLCBpO1xuXG4gICAgaWYgKCEgYXNzaWduZWQoZGF0YSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZVN5bWJvbHMgJiYgZGF0YVtTeW1ib2wuaXRlcmF0b3JdICYmIGlzRnVuY3Rpb24oZGF0YS52YWx1ZXMpKSB7XG4gICAgICBpdGVyYXRvciA9IGRhdGEudmFsdWVzKCk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaXRlcmF0aW9uID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb24udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCEgaXRlcmF0aW9uLmRvbmUpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGRhdGFba2V5c1tpXV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGhhc0xlbmd0aGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaGFzIGEgbGVuZ3RoIHByb3BlcnR5IHRoYXQgZXF1YWxzIGBsZW5ndGhgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNMZW5ndGggKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiBhc3NpZ25lZChkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gbGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZGF0ZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSB2YWxpZCBkYXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBkYXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyaWN0KGRhdGEsIERhdGUpICYmIGludGVnZXIoZGF0YS5nZXRUaW1lKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZnVuY3Rpb25gLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhcHBseWAuXG4gICAqXG4gICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBgZGF0YWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJlZGljYXRlIGFuZCByZXR1cm5zXG4gICAqIHRoZSByZXN1bHQgYXJyYXkuIElmIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICogZGF0YSwgYSBzaW5nbGUgcHJlZGljYXRlIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseSAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgIGFzc2VydC5hcnJheShkYXRhKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZXMpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzc2VydC5hcnJheShwcmVkaWNhdGVzKTtcbiAgICBhc3NlcnQuaGFzTGVuZ3RoKGRhdGEsIHByZWRpY2F0ZXMubGVuZ3RoKTtcblxuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcHJlZGljYXRlc1tpbmRleF0odmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbWFwYC5cbiAgICpcbiAgICogTWFwcyBlYWNoIHZhbHVlIGZyb20gdGhlIGBkYXRhYCB0byB0aGUgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUgYW5kIHJldHVybnNcbiAgICogdGhlIHJlc3VsdCBvYmplY3QuIFN1cHBvcnRzIG5lc3RlZCBvYmplY3RzLiBJZiB0aGUgYGRhdGFgIGlzIG5vdCBuZXN0ZWQgYW5kXG4gICAqIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiBpdCwgYSBzaW5nbGUgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBtYXAgKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlcykpIHtcbiAgICAgIHJldHVybiBtYXBTaW1wbGUoZGF0YSwgcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0Lm9iamVjdChwcmVkaWNhdGVzKTtcblxuICAgIHJldHVybiBtYXBDb21wbGV4KGRhdGEsIHByZWRpY2F0ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwU2ltcGxlIChkYXRhLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwQ29tcGxleCAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNba2V5XTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgICAgICBpZiAobm90LmFzc2lnbmVkKGRhdGEpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSAhIXByZWRpY2F0ZS5tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0KHByZWRpY2F0ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtYXBDb21wbGV4KGRhdGFba2V5XSwgcHJlZGljYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhbGxgXG4gICAqXG4gICAqIENoZWNrIHRoYXQgYWxsIGJvb2xlYW4gdmFsdWVzIGFyZSB0cnVlXG4gICAqIGluIGFuIGFycmF5IChyZXR1cm5lZCBmcm9tIGBhcHBseWApXG4gICAqIG9yIG9iamVjdCAocmV0dXJuZWQgZnJvbSBgbWFwYCkuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhbGwgKGRhdGEpIHtcbiAgICBpZiAoYXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiB0ZXN0QXJyYXkoZGF0YSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QoZGF0YSk7XG5cbiAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0QXJyYXkgKGRhdGEsIHJlc3VsdCkge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gIXJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RPYmplY3QgKGRhdGEsIHJlc3VsdCkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgICBpZiAob2JqZWN0KHZhbHVlKSAmJiB0ZXN0T2JqZWN0KHZhbHVlLCByZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhbnlgXG4gICAqXG4gICAqIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGJvb2xlYW4gdmFsdWUgaXMgdHJ1ZVxuICAgKiBpbiBhbiBhcnJheSAocmV0dXJuZWQgZnJvbSBgYXBwbHlgKVxuICAgKiBvciBvYmplY3QgKHJldHVybmVkIGZyb20gYG1hcGApLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gYW55IChkYXRhKSB7XG4gICAgaWYgKGFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gdGVzdEFycmF5KGRhdGEsIHRydWUpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QoZGF0YSk7XG5cbiAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1peGluICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgbW9kaWZpZXIgYGFzc2VydGAuXG4gICAqXG4gICAqIFRocm93cyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0TW9kaWZpZXIgKHByZWRpY2F0ZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFzc2VydFByZWRpY2F0ZShwcmVkaWNhdGUsIGFyZ3VtZW50cywgZGVmYXVsdE1lc3NhZ2UpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRQcmVkaWNhdGUgKHByZWRpY2F0ZSwgYXJncywgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICB2YXIgYXJnQ291bnQgPSBwcmVkaWNhdGUubCB8fCBwcmVkaWNhdGUubGVuZ3RoO1xuICAgIHZhciBtZXNzYWdlID0gYXJnc1thcmdDb3VudF07XG4gICAgdmFyIEVycm9yVHlwZSA9IGFyZ3NbYXJnQ291bnQgKyAxXTtcbiAgICBhc3NlcnRJbXBsKFxuICAgICAgcHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3MpLFxuICAgICAgbm9uRW1wdHlTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UsXG4gICAgICBpc0Z1bmN0aW9uKEVycm9yVHlwZSkgPyBFcnJvclR5cGUgOiBUeXBlRXJyb3JcbiAgICApO1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW1wbCAodmFsdWUsIG1lc3NhZ2UsIEVycm9yVHlwZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgKEVycm9yVHlwZSB8fCBFcnJvcikobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgbm90YC5cbiAgICpcbiAgICogTmVnYXRlcyBgcHJlZGljYXRlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vdE1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm90SW1wbChwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbXBsICh2YWx1ZSkge1xuICAgIHJldHVybiAhdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIG1vZGlmaWVyIGBtYXliZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBwcmVkaWNhdGUgYXJndW1lbnQgaXMgIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgKiBvdGhlcndpc2UgcHJvcGFnYXRlcyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gYHByZWRpY2F0ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBtYXliZU1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobm90LmFzc2lnbmVkKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIG1vZGlmaWVkUHJlZGljYXRlLmwgPSBwcmVkaWNhdGUubGVuZ3RoO1xuXG4gICAgLy8gSGFja2lzaGx5IGluZGljYXRlIHRoYXQgdGhpcyBpcyBhIG1heWJlLnh4eCBwcmVkaWNhdGUuXG4gICAgLy8gV2l0aG91dCB0aGlzIGZsYWcsIHRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBpdGVyYXRlXG4gICAgLy8gdGhyb3VnaCB0aGUgbWF5YmUgcHJlZGljYXRlcyBvciB1c2UgaW5kZXhPZiB0byBjaGVjayxcbiAgICAvLyB3aGljaCB3b3VsZCBiZSB0aW1lLWNvbnN1bWluZy5cbiAgICBtb2RpZmllZFByZWRpY2F0ZS5tID0gdHJ1ZTtcblxuICAgIHJldHVybiBtb2RpZmllZFByZWRpY2F0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW1wbCAodmFsdWUpIHtcbiAgICBpZiAoYXNzaWduZWQodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgb2ZgLlxuICAgKlxuICAgKiBBcHBsaWVzIHRoZSBjaGFpbmVkIHByZWRpY2F0ZSB0byBtZW1iZXJzIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb2ZNb2RpZmllciAodGFyZ2V0LCB0eXBlLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiwgYXJncztcblxuICAgICAgY29sbGVjdGlvbiA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKHRhcmdldCA9PT0gJ21heWJlJyAmJiBub3QuYXNzaWduZWQoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbGxlY3Rpb24gPSBjb2VyY2VDb2xsZWN0aW9uKHR5cGUsIGNvbGxlY3Rpb24pO1xuICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHRhcmdldCAhPT0gJ21heWJlJyB8fCBhc3NpZ25lZChpdGVtKSkgJiZcbiAgICAgICAgICAgICFwcmVkaWNhdGUuYXBwbHkobnVsbCwgWyBpdGVtIF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIGZvci4uLm9mIHdoZW4gRVM2IGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgdGhyb3cgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2VyY2VDb2xsZWN0aW9uICh0eXBlLCBjb2xsZWN0aW9uKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGFycmF5TGlrZTpcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoY29sbGVjdGlvbik7XG4gICAgICBjYXNlIG9iamVjdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMgKG1vZGlmaWVyLCBvYmplY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoWyBtb2RpZmllciwgcHJlZGljYXRlcywgb2JqZWN0IF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMgKGFyZ3MpIHtcbiAgICB2YXIgbW9kaWZpZXIsIG9iamVjdCwgZnVuY3Rpb25zLCByZXN1bHQ7XG5cbiAgICBtb2RpZmllciA9IGFyZ3Muc2hpZnQoKTtcbiAgICBvYmplY3QgPSBhcmdzLnBvcCgpO1xuICAgIGZ1bmN0aW9ucyA9IGFyZ3MucG9wKCk7XG5cbiAgICByZXN1bHQgPSBvYmplY3QgfHwge307XG5cbiAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG1vZGlmaWVyLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGZ1bmN0aW9uc1trZXldLCBtZXNzYWdlc1trZXldKSlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIgKG1vZGlmaWVyLCBtb2RpZmllZCkge1xuICAgIHJldHVybiBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhbIG1vZGlmaWVyLCBtb2RpZmllZCwgbnVsbCBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9mUHJlZGljYXRlcyAoa2V5KSB7XG4gICAgcHJlZGljYXRlc1trZXldLm9mID0gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoXG4gICAgICBbIG9mTW9kaWZpZXIuYmluZChudWxsLCBudWxsKSwgcHJlZGljYXRlc1trZXldLCBwcmVkaWNhdGVzLCBudWxsIF1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2ZNb2RpZmllcnMgKGJhc2UsIG1vZGlmaWVyKSB7XG4gICAgY29sbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBiYXNlW2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKG1vZGlmaWVyLCBwcmVkaWNhdGVzW2tleV0ub2YpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWF5YmVPZk1vZGlmaWVycyAoa2V5KSB7XG4gICAgbWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFxuICAgICAgWyBvZk1vZGlmaWVyLmJpbmQobnVsbCwgJ21heWJlJyksIHByZWRpY2F0ZXNba2V5XSwgcHJlZGljYXRlcywgbnVsbCBdXG4gICAgKTtcbiAgICBhc3NlcnQubWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlW2tleV0ub2YpO1xuICAgIGFzc2VydC5ub3Rba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG5vdFtrZXldLm9mKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9ydEZ1bmN0aW9ucyAoZnVuY3Rpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICE9PSBudWxsICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFscy5jaGVjayA9IGZ1bmN0aW9ucztcbiAgICB9XG4gIH1cbn0odGhpcykpO1xuIiwiY29uc3QgY2hlY2sgPSByZXF1aXJlKCdjaGVjay10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjaGFpKSA9PiB7XG5cbiAgY29uc3QgdHlwZXMgPSBbJ251bWJlcicsICdzdHJpbmcnLCAnYm9vbGVhbicsICdvYmplY3QnLCAnYXJyYXknLCAnZGF0ZScsICdmdW5jdGlvbiddO1xuXG4gIHR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QodHlwZSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgY2hlY2tbdHlwZV0odGhpcy5fb2JqKSxcbiAgICAgICAgYGV4cGVjdGVkICN7dGhpc30gdG8gYmUgJHt0eXBlfWAsXG4gICAgICAgIGBleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSAke3R5cGV9YFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbn07IiwiZnVuY3Rpb24gcGx1Z2luKGNoYWksIHV0aWxzKSB7XG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBlbnRyeSBpcyBhbiBldmVudCBlbWl0dGVyLlxuICAgKiBVc2VzIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCBpZiBhdmFpbGFibGUgdG8gcXVpY2tseSBjaGVjayBgaW5zdGFuY2VvZmAuICBPdGhlcndpc2UsIGNoZWNrcyB0aGF0IGNvbW1vbiBtZXRob2RzXG4gICAqIHRvIGV2ZW50IGVtaXR0ZXJzIGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEdyYWNlZnVsbHkgaGFuZGxlcyBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIGV2ZW50IGVtaXR0ZXJzIGV2ZW4gaWYgRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0IGFyZSBhdmFpbGFibGUsXG4gICAqIGNoZWNraW5nIG1ldGhvZHMgaWYgdGhlIGVtaXR0ZXIgZG9lc24ndCBpbmhlcml0IGZyb20gdGhlIGdsb2JhbCBlbWl0dGVyLlxuICAqL1xuICBmdW5jdGlvbiBpc0VtaXR0ZXIoKSB7XG4gICAgLy8gRWFzeSBjaGVjazogaWYgTm9kZSdzIEV2ZW50RW1pdHRlciBvciB3aW5kb3cuRXZlbnRFbWl0dGVyIGV4aXN0LCBjaGVjayBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGl0LlxuICAgIGlmKHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyICE9PSBudWxsICYmIHRoaXMuX29iaiBpbnN0YW5jZW9mIEV2ZW50RW1pdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRFbWl0dGVyXCIpO1xuICAgIH1cblxuICAgIC8vIEVhc3kgY2hlY2s6IGlmIHRoZSBicm93c2VyJ3MgRXZlbnRUYXJnZXQgZXhpc3RzLCBjaGVjayBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGl0LlxuICAgIGlmKHR5cGVvZiBFdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudFRhcmdldCAhPT0gbnVsbCAmJiB0aGlzLl9vYmogaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRUYXJnZXRcIik7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHRoaXMuX29iajtcblxuICAgIC8vIENoZWNrIGZvciBOb2RlLmpzIHN0eWxlIGV2ZW50IGVtaXR0ZXJzIHdpdGggXCJvblwiLCBcImVtaXRcIiwgZXRjLlxuICAgIHZhciBub2RlID0gW1wib25cIiwgXCJlbWl0XCJdLmV2ZXJ5KGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0pO1xuXG4gICAgaWYobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRFbWl0dGVyXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBCcm93c2VyLWJhc2VkIGV2ZW50IGVtaXR0ZXJzIHdpdGggXCJhZGRFdmVudExpc3RlbmVyXCIsIGV0Yy5cbiAgICB2YXIgYnJvd3NlciA9IFtcImFkZEV2ZW50TGlzdGVuZXJcIiwgXCJkaXNwYXRjaEV2ZW50XCIsIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiXS5ldmVyeShmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcblxuICAgIGlmKGJyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0cnVlLCBcIlwiLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIEV2ZW50RW1pdHRlclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChmYWxzZSwgXCJleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIEV2ZW50RW1pdHRlclwiLCBcIlwiKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoXCJlbWl0dGVyXCIsIGlzRW1pdHRlcik7XG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eShcInRhcmdldFwiLCBpc0VtaXR0ZXIpO1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoXCJlbWl0XCIsIGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICBjb25zdCB0aW1lb3V0ID0gdHlwZW9mIGFyZ3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGFyZ3MudGltZW91dCA9PT0gXCJudW1iZXJcIiA/IGFyZ3MudGltZW91dCA6IDE1MDA7XG4gICAgY29uc3Qgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCBcIm9iamVjdFwiKTtcblxuICAgIG5ldyBBc3NlcnRpb24odGhpcy5fb2JqKS50by5iZS5hbi5lbWl0dGVyO1xuXG4gICAgbmV3IEFzc2VydGlvbihuYW1lKS50by5zYXRpc2Z5KGZ1bmN0aW9uKF9uYW1lKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgX25hbWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBfbmFtZSA9PT0gJ3N5bWJvbCc7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhc3NlcnRFbWlzc2lvbiA9IGV4cHIgPT4gdGhpcy5hc3NlcnQoXG4gICAgICBleHByLFxuICAgICAgYGV4cGVjdGVkICN7dGhpc30gdG8gZW1pdCBtZXNzYWdlIHdpdGgga2V5ICcke25hbWUudG9TdHJpbmcoKX0nYCxcbiAgICAgIGBleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlbWl0IG1lc3NhZ2Ugd2l0aCBrZXkgJyR7bmFtZS50b1N0cmluZygpfSdgXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuXG4gICAgICBvYmoub25jZShuYW1lLCAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZihkb25lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXNzZXJ0RW1pc3Npb24odHJ1ZSk7IC8vIFdpbGwgdGhyb3cgZXJyb3IgaWYgYWN0aW9uIGlzIHVuZXhwZWN0ZWQuXG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYoZG9uZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGFzc2VydEVtaXNzaW9uKGZhbHNlKTsgLy8gV2lsbCB0aHJvdyBlcnJvciBpZiBhY3Rpb24gaXMgdW5leHBlY3RlZC5cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KTtcbiAgfSk7XG5cbn1cblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcbn1cbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfSk7XG59XG5lbHNlIHtcbiAgLy8gT3RoZXIgZW52aXJvbm1lbnQgKHVzdWFsbHkgPHNjcmlwdD4gdGFnKTogcGx1ZyBpbiB0byBnbG9iYWwgY2hhaSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgY2hhaS51c2UocGx1Z2luKTtcbn1cbiIsIiMgQFBvcHVwID0gd2luZG93LnF1aWNrcG9wdXBcbmltcG9ydCBQb3B1cCBmcm9tICcuLi9idWlsZC9xdWlja3BvcHVwLmVzbS5qcydcbmltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7dmVyc2lvbiBhcyBwYWNrYWdlVmVyc2lvbn0gZnJvbSAnLi4vcGFja2FnZS5qc29uJ1xuaW1wb3J0IGNoYWkgZnJvbSAnY2hhaSdcbmltcG9ydCBjaGFpRG9tIGZyb20gJ2NoYWktZG9tJ1xuaW1wb3J0IGNoYWlTdHlsZSBmcm9tICdjaGFpLXN0eWxlJ1xuaW1wb3J0IGNoYWlBbG1vc3QgZnJvbSAnY2hhaS1hbG1vc3QnXG5pbXBvcnQgY2hhaUFzc2VydHR5cGUgZnJvbSAnY2hhaS1hc3NlcnR0eXBlJ1xuaW1wb3J0IGNoYWlFdmVudHMgZnJvbSAnY2hhaS1ldmVudHMnXG5jaGFpLnVzZShjaGFpRG9tKVxuY2hhaS51c2UoY2hhaVN0eWxlKVxuY2hhaS51c2UoY2hhaUFsbW9zdClcbmNoYWkudXNlKGNoYWlBc3NlcnR0eXBlKVxuY2hhaS51c2UoY2hhaUV2ZW50cylcbm1vY2hhLnNldHVwKCd0ZGQnKVxubW9jaGEuc2xvdyg0MDApXG5tb2NoYS50aW1lb3V0KDYwMDApXG5tb2NoYS5iYWlsKCkgdW5sZXNzIHdpbmRvdy5fX2thcm1hX19cbmV4cGVjdCA9IGNoYWkuZXhwZWN0XG5hc3NlcnQgPSBjaGFpLmFzc2VydFxud2luZG93LnNhbmRib3ggPSBudWxsXG5cblxuXG5zdWl0ZSBcIlF1aWNrUG9wdXBcIiwgKCktPlxuXHRzZXR1cChoZWxwZXJzLnJlc3RhcnRTYW5kYm94KVxuXHR0ZWFyZG93bihQb3B1cC5kZXN0cm95QWxsKVxuXG5cdHRlc3QgXCJWZXJzaW9uIFByb3BlcnR5XCIsICgpLT5cblx0XHRleHBlY3QoUG9wdXAudmVyc2lvbikudG8uZXF1YWwocGFja2FnZVZlcnNpb24pXG5cblxuXHRzdWl0ZSBcImluc3RhbmNlXCIsICgpLT5cblx0XHR0ZXN0IFwic2hvdWxkIGJlIGFuIGV2ZW50IGVtaXR0ZXJcIiwgKCktPlxuXHRcdFx0cG9wdXAgPSBQb3B1cCgpXG5cdFx0XHRhc3NlcnQuZXF1YWwgdHlwZW9mIHBvcHVwLm9uLCAnZnVuY3Rpb24nXG5cdFx0XHRhc3NlcnQuZXF1YWwgdHlwZW9mIHBvcHVwLm9mZiwgJ2Z1bmN0aW9uJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBwb3B1cC5lbWl0LCAnZnVuY3Rpb24nXG5cdFx0XHRQcm9taXNlLmRlbGF5KCkudGhlbiAoKS0+IHBvcHVwLmVtaXQgJ3NvbWVFdmVudCdcblx0XHRcdGV4cGVjdChwb3B1cCkudG8uZW1pdCAnc29tZUV2ZW50J1xuXG5cblx0XHRzdWl0ZSBcImFyZ3NcIiwgKCktPlxuXHRcdFx0dGVzdCBcInVzaW5nIG5vIGFyZ3NcIiwgKCktPlxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKClcblx0XHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAoKVxuXHRcdFx0XHRhc3NlcnQgcG9wdXAgbm90IGluc3RhbmNlb2YgUG9wdXBcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBwb3B1cCwgJ29iamVjdCdcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBwb3B1cC5vcGVuLCAnZnVuY3Rpb24nXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBwb3B1cC5lbC50ZXh0LCAnJ1xuXG5cblx0XHRcdHRlc3QgXCJ3aXRoIHN0cmluZyBhcmdcIiwgKCktPlxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKCdwcm92aWRlZCBzdHJpbmcnKVxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXAuZWwudGV4dCwgJ3Byb3ZpZGVkIHN0cmluZydcblxuXG5cdFx0XHR0ZXN0IFwid2l0aCBodG1sIHN0cmluZyBhcmdcIiwgKCktPlxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKCc8YiBjbGFzcz1cInRoZUJvbGRPbmVcIj5wcm92aWRlZCBzdHJpbmc8L2I+PGkgY2xhc3M9XCJ0aGVTbGFudGVkT25lXCI+IGlzIHNsYW50ZWQ8L2I+Jylcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwLmVsLnRleHQsICdwcm92aWRlZCBzdHJpbmcgaXMgc2xhbnRlZCdcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnRlbnRzID0gcG9wdXAuZWwuY2hpbGQuY29udGVudC5sYXN0Q2hpbGQuY2hpbGRyZW5cblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzLmxlbmd0aCwgMlxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMF0udHlwZSwgJ2InXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1sxXS50eXBlLCAnaSdcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLnJhdy5jbGFzc05hbWUsICd0aGVCb2xkT25lJ1xuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMV0ucmF3LmNsYXNzTmFtZSwgJ3RoZVNsYW50ZWRPbmUnXG5cblxuXHRcdFx0dGVzdCBcIndpdGggRE9NIGVsZW1lbnQgYXJnXCIsICgpLT5cblx0XHRcdFx0c3BhbiA9IERPTS5zcGFuKGNsYXNzOidhYmMxMjMtY2hpbGQnLCAncHJvdmlkZWQgZWwnKVxuXHRcdFx0XHRkaXYgPSBET00uZGl2KGNsYXNzOidhYmMxMjMnLCBzcGFuKVxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKGRpdi5yYXcpXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBwb3B1cC5lbC50ZXh0LCAncHJvdmlkZWQgZWwnXG5cdFx0XHRcdFxuXHRcdFx0XHRjb250ZW50cyA9IHBvcHVwLmVsLmNoaWxkLmNvbnRlbnQuY2hpbGRyZW5cblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzLmxlbmd0aCwgMVxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMF0udHlwZSwgJ2Rpdidcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLnJhdy5jbGFzc05hbWUsICdhYmMxMjMnXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1swXSwgZGl2XG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1swXS5jaGlsZHJlblswXSwgc3BhblxuXG5cblx0XHRcdHRlc3QgXCJ3aXRoIFF1aWNrRE9NIGVsZW1lbnQgYXJnXCIsICgpLT5cblx0XHRcdFx0c3BhbiA9IERPTS5zcGFuKGNsYXNzOidhYmMxMjMtY2hpbGQnLCAncHJvdmlkZWQgZWwnKVxuXHRcdFx0XHRkaXYgPSBET00uZGl2KGNsYXNzOidhYmMxMjMnLCBzcGFuKVxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKGRpdilcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwLmVsLnRleHQsICdwcm92aWRlZCBlbCdcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnRlbnRzID0gcG9wdXAuZWwuY2hpbGQuY29udGVudC5jaGlsZHJlblxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHMubGVuZ3RoLCAxXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1swXS50eXBlLCAnZGl2J1xuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMF0ucmF3LmNsYXNzTmFtZSwgJ2FiYzEyMydcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLCBkaXZcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLmNoaWxkcmVuWzBdLCBzcGFuXG5cblxuXHRcdFx0dGVzdCBcIndpdGggc2V0dGluZ3MgYXJnXCIsICgpLT5cblx0XHRcdFx0cG9wdXBBID0gUG9wdXAoe30pXG5cdFx0XHRcdHBvcHVwQiA9IFBvcHVwKHtwbGFjZW1lbnQ6J2JvdHRvbSd9KVxuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnNldHRpbmdzLnBsYWNlbWVudCwgJ2NlbnRlcidcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zZXR0aW5ncy5wbGFjZW1lbnQsICdib3R0b20nXG5cblxuXHRzdWl0ZSBcImJlaGF2aW9yXCIsICgpLT5cblx0XHR0ZXN0IFwic2hvdWxkIGNyZWF0ZSBhIHdyYXBwZXIgZWxlbWVudCBhcm91bmQgYm9keSBjb250ZW50c1wiLCAoKS0+XG5cdFx0XHRhc3NlcnQuZXF1YWwgdHlwZW9mIERPTS5xdWVyeSgnI2JvZHlXcmFwcGVyJyksICd1bmRlZmluZWQnXG5cdFx0XHRib2R5Q2hpbGRyZW4gPSBET00oZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4uc2xpY2UoKVxuXG5cdFx0XHRwb3B1cCA9IFBvcHVwKClcblx0XHRcdGFzc2VydC5lcXVhbCB0eXBlb2YgRE9NLnF1ZXJ5KCcjYm9keVdyYXBwZXInKSwgJ29iamVjdCdcblx0XHRcdGFzc2VydC5lcXVhbCBET00ucXVlcnkoJyNib2R5V3JhcHBlcicpLnBhcmVudCwgRE9NKGRvY3VtZW50LmJvZHkpXG5cdFx0XHRhc3NlcnQuZXF1YWwgRE9NKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuLmxlbmd0aCwgMlxuXHRcdFx0YXNzZXJ0LmVxdWFsIERPTS5xdWVyeSgnI2JvZHlXcmFwcGVyJykuY2hpbGRyZW4ubGVuZ3RoLCBib2R5Q2hpbGRyZW4ubGVuZ3RoXG5cdFx0XHRcblx0XHRcdFBvcHVwLnVud3JhcEJvZHkoKVxuXHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBET00ucXVlcnkoJyNib2R5V3JhcHBlcicpLCAndW5kZWZpbmVkJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIERPTShkb2N1bWVudC5ib2R5KS5jaGlsZHJlbi5sZW5ndGgsIGJvZHlDaGlsZHJlbi5sZW5ndGgrMVxuXG5cdFx0XHRwb3B1cC5kZXN0cm95KClcblx0XHRcdGFzc2VydC5lcXVhbCBET00oZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4ubGVuZ3RoLCBib2R5Q2hpbGRyZW4ubGVuZ3RoXG5cdFx0XHRcblx0XHRcdHBvcHVwID0gUG9wdXAoKVxuXHRcdFx0YXNzZXJ0LmVxdWFsIERPTShkb2N1bWVudC5ib2R5KS5jaGlsZHJlbi5sZW5ndGgsIDJcblx0XHRcdGFzc2VydC5lcXVhbCBET00ucXVlcnkoJyNib2R5V3JhcHBlcicpLmNoaWxkcmVuLmxlbmd0aCwgYm9keUNoaWxkcmVuLmxlbmd0aFxuXG5cdFx0dGVzdCBcIlBvcHVwLmNvbmZpZygpIHdpbGwgcmV0dXJuIGEgbmV3IGNvbnN0cnVjdG9yIHdpdGggY3VzdG9taXplZCBzZXR0aW5nIGRlZmF1bHRzICYgdGVtcGxhdGVzXCIsICgpLT5cblx0XHRcdFBvcHVwMiA9IFBvcHVwLmNvbmZpZyh7YW5pbWF0aW9uOjEwMH0pXG5cdFx0XHRhc3NlcnQubm90RXF1YWwgUG9wdXAyLCBQb3B1cFxuXHRcdFx0YXNzZXJ0LmVxdWFsIFBvcHVwMi5kZWZhdWx0cy5hbmltYXRpb24sIDEwMFxuXHRcdFx0YXNzZXJ0Lm5vdEVxdWFsIFBvcHVwLmRlZmF1bHRzLmFuaW1hdGlvbiwgMTAwXG5cdFx0XHRQb3B1cCgpXG5cdFx0XHRQb3B1cDIoKVxuXG5cblx0c3VpdGUgXCJvcGVuL2Nsb3NlXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT4gQFBvcHVwID0gUG9wdXAuY29uZmlnKHthbmltYXRpb246NTB9KVxuXHRcdHRlc3QgXCJ3aWxsIHJldHVybiBwcm9taXNlcyB0aGF0IHJlc29sdmUgd2hlbiBhbmltYXRpb24gZW5kc1wiLCAoKS0+XG5cdFx0XHRjb250ZW50ID0gRE9NLmRpdihudWxsLCAnYWJjMTIzJylcblx0XHRcdHBvcHVwID0gQFBvcHVwKGNvbnRlbnQpXG5cdFx0XHRzdGFydFRpbWUgPSBEYXRlLm5vdygpXG5cdFx0XHRvcGVuVGltZSA9IG51bGxcblxuXHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwLnN0YXRlLm9wZW4sIGZhbHNlXG5cblx0XHRcdG9wZW5Qcm9taXNlID0gcG9wdXAub3BlbigpXG5cdFx0XHRhc3NlcnQub2sgb3BlblByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0XHRhc3NlcnQub2sgb3BlblByb21pc2UuaXNQZW5kaW5nKClcblxuXHRcdFx0UHJvbWlzZS5iaW5kKEApXG5cdFx0XHRcdC50aGVuICgpLT4gb3BlblByb21pc2Vcblx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdG9wZW5UaW1lID0gRGF0ZS5ub3coKVxuXHRcdFx0XHRcdGFzc2VydC5pc0F0TGVhc3Qgb3BlblRpbWUtc3RhcnRUaW1lLCBAUG9wdXAuZGVmYXVsdHMuYW5pbWF0aW9uLzJcblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXAuc3RhdGUub3BlbiwgdHJ1ZVxuXG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXAuY2xvc2UoKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmlzQXRMZWFzdCBEYXRlLm5vdygpLW9wZW5UaW1lLCBAUG9wdXAuZGVmYXVsdHMuYW5pbWF0aW9uLzJcblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXAuc3RhdGUub3BlbiwgZmFsc2VcblxuXG5cdFx0dGVzdCBcIndpbGwgZW1pdCBldmVudHMgYmVmb3JlL3ByZXNlbnQvZmluaXNoIGZvciBvcGVuL2Nsb3NlXCIsICgpLT5cblx0XHRcdHBvcHVwID0gQFBvcHVwKClcblx0XHRcdGV2ZW50cyA9IFsnYmVmb3Jlb3BlbicsJ29wZW4nLCdmaW5pc2hvcGVuJywnYmVmb3JlY2xvc2UnLCdjbG9zZScsJ2ZpbmlzaGNsb3NlJ11cblx0XHRcdGNvdW50ID0ge31cblx0XHRcdGV2ZW50cy5mb3JFYWNoIChldmVudCktPlxuXHRcdFx0XHRjb3VudFtldmVudF0gPSAwXG5cdFx0XHRcdHBvcHVwLm9uIGV2ZW50LCAoKS0+IGNvdW50W2V2ZW50XSsrXG5cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuICgpLT4gYXNzZXJ0LmRlZXBFcXVhbCBjb3VudCwge2JlZm9yZW9wZW46MCwgb3BlbjowLCBmaW5pc2hvcGVuOjAsIGJlZm9yZWNsb3NlOjAsIGNsb3NlOjAsIGZpbmlzaGNsb3NlOjB9XG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXAub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT4gYXNzZXJ0LmRlZXBFcXVhbCBjb3VudCwge2JlZm9yZW9wZW46MSwgb3BlbjoxLCBmaW5pc2hvcGVuOjEsIGJlZm9yZWNsb3NlOjAsIGNsb3NlOjAsIGZpbmlzaGNsb3NlOjB9XG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXAuY2xvc2UoKVxuXHRcdFx0XHQudGhlbiAoKS0+IGFzc2VydC5kZWVwRXF1YWwgY291bnQsIHtiZWZvcmVvcGVuOjEsIG9wZW46MSwgZmluaXNob3BlbjoxLCBiZWZvcmVjbG9zZToxLCBjbG9zZToxLCBmaW5pc2hjbG9zZToxfVxuXG5cblx0XHR0ZXN0IFwid2lsbCBmYWlsIHRvIG9wZW4gaWYgYW5vdGhlciBwb3B1cCBpcyBvcGVuXCIsICgpLT5cblx0XHRcdHBvcHVwQSA9IEBQb3B1cCgpXG5cdFx0XHRwb3B1cEIgPSBAUG9wdXAoKVxuXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQS5zdGF0ZS5vcGVuLCBmYWxzZVxuXHRcdFx0XHRcdGFzc2VydC5lcXVhbCBwb3B1cEIuc3RhdGUub3BlbiwgZmFsc2Vcblx0XHRcdFx0XG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXBBLm9wZW4oKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQS5zdGF0ZS5vcGVuLCB0cnVlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCBmYWxzZVxuXG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXBCLm9wZW4oKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQS5zdGF0ZS5vcGVuLCB0cnVlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCBmYWxzZVxuXG5cblx0XHR0ZXN0IFwid2lsbCBjbG9zZSBhbGwgb3RoZXIgb3BlbiBwb3B1cHMgYW5kIHdpbGwgZm9yY2Ugb3BlbiB3aGVuIG9wdGlvbnMuZm9yY2VPcGVuXCIsICgpLT5cblx0XHRcdHBvcHVwQSA9IEBQb3B1cCgpXG5cdFx0XHRwb3B1cEIgPSBAUG9wdXAoZm9yY2VPcGVuOnRydWUpXG5cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIGZhbHNlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCBmYWxzZVxuXHRcdFx0XHRcblx0XHRcdFx0LnRoZW4gKCktPiBwb3B1cEEub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIHRydWVcblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBCLnN0YXRlLm9wZW4sIGZhbHNlXG5cblx0XHRcdFx0LnRoZW4gKCktPiBwb3B1cEIub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIGZhbHNlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCB0cnVlXG5cblx0XHRcdFx0LnRoZW4gKCktPiBwb3B1cEEub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIGZhbHNlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCB0cnVlXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJSRUdFWF9MRU5fVkFMIiwiUkVHRVhfRElHSVRTIiwiUkVHRVhfU1BBQ0UiLCJSRUdFWF9LRUJBQiIsIklNUE9SVEFOVCIsIlBPU1NJQkxFX1BSRUZJWEVTIiwiUkVRVUlSRVNfVU5JVF9WQUxVRSIsIlFVQURfU0hPUlRIQU5EUyIsIkRJUkVDVElPTlMiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJkaXJlY3Rpb24iLCJpIiwibGVuIiwicHVzaCIsImxlbmd0aCIsIlNBTVBMRV9TVFlMRSIsInN0eWxlQ29uZmlnIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJpbmNsdWRlcyIsInRhcmdldCIsIml0ZW0iLCJpbmRleE9mIiwiaXNJdGVyYWJsZSIsIm5vZGVUeXBlIiwidG9LZWJhYkNhc2UiLCJzdHJpbmciLCJyZXBsYWNlIiwiZSIsImxldHRlciIsImNvbmNhdCIsInRvTG93ZXJDYXNlIiwiaXNQcm9wU3VwcG9ydGVkIiwiaXNWYWx1ZVN1cHBvcnRlZCIsInZhbHVlIiwid2luZG93IiwiQ1NTIiwic3VwcG9ydHMiLCJnZXRQcmVmaXgiLCJza2lwSW5pdGlhbENoZWNrIiwiaiIsImxlbjEiLCJwcmVmaXgiLCJub3JtYWxpemVQcm9wZXJ0eSIsIm5vcm1hbGl6ZVZhbHVlIiwidGVzdCIsInNvcnQiLCJhcnJheSIsImdyZWF0IiwibGVzcyIsInBpdm90IiwiaGFzaCIsImhzaCIsImNoYXJDb2RlQXQiLCJydWxlVG9TdHJpbmciLCJydWxlIiwiaW1wb3J0YW50Iiwib3V0cHV0IiwicHJvcCIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImlubGluZVN0eWxlQ29uZmlnIiwiY3JlYXRlIiwiaW5saW5lU3R5bGUiLCJ2YWx1ZVRvU3RvcmUiLCJsZXZlbCIsImNvbmZpZyIsInN0eWxlRWwiLCJpZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImVsIiwiY29udGVudCIsImNhY2hlIiwidGV4dENvbnRlbnQiLCJjbGVhcklubGluZVN0eWxlIiwia2V5IiwidmVyc2lvbiIsIl9xdWlja2NzcyIsImluZGV4IiwicXVpY2tjc3MiLCJ0YXJnZXRFbCIsImNvbXB1dGVkU3R5bGUiLCJzdWJFbCIsInN1YlByb3BlcnR5Iiwic3ViVmFsdWUiLCJfY29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJzZXRQcm9wZXJ0eSIsImFuaW1hdGlvbiIsIm5hbWUiLCJmcmFtZXMiLCJmcmFtZSIsImdlbmVyYXRlZCIsInJ1bGVzIiwicmVnaXN0ZXIiLCJjbGFzc05hbWUiLCJyZWYiLCJjbGVhclJlZ2lzdGVyZWQiLCJVTlNFVCIsInN1cHBvcnRzUHJvcGVydHkiLCJfZXh0ZW5kIiwiaXNBcnJheSIsImlzT2JqZWN0IiwiX3Nob3VsZERlZXBFeHRlbmQiLCJBcnJheSIsInRvU3RyaW5nIiwiY2FsbCIsInNob3VsZERlZXBFeHRlbmQiLCJvcHRpb25zIiwicGFyZW50S2V5IiwiZGVlcCIsIm5vdERlZXAiLCJkZWVwT25seSIsImV4dGVuZCIsInNvdXJjZXMiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInN1YlRhcmdldCIsInRhcmdldFZhbHVlIiwiYWxsb3dOdWxsIiwibnVsbERlbGV0ZXMiLCJub3RLZXlzIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJnbG9iYWxGaWx0ZXIiLCJmaWx0ZXJzIiwiZ2xvYmFsVHJhbnNmb3JtIiwidHJhbnNmb3JtcyIsIm1vZGlmaWVycyIsIm5ld0J1aWxkZXIiLCJub3JtYWxpemVLZXlzIiwicHJpbWFyeUJ1aWxkZXIiLCJpc0Jhc2UiLCJfYnVpbGRlciIsImJ1aWxkZXIiLCJ0aGVUYXJnZXQiLCIkX2xlbiIsImFyZ3VtZW50cyIsIiRfaSIsInNoaWZ0IiwiZGVmaW5lUHJvcGVydGllcyIsImdldCIsIl8iLCJ0cmFuc2Zvcm0iLCJmaWx0ZXIiLCJwcmltYXJ5QnVpbGRlciQxIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiZGVmaW5lZCIsInN1YmplY3QiLCJvYmplY3QiLCJvYmplY3RQbGFpbiIsIm51bWJlciIsImlzTmFOIiwibnVtYmVyTG9vc2UiLCJOdW1iZXIiLCJpdGVyYWJsZSIsImZ1bmN0aW9uXyIsIm5hdGl2ZXMiLCJmcmVlemUiLCJkb21Eb2MiLCJkb21FbCIsImRvbVRleHQiLCJkb21Ob2RlIiwiZG9tVGV4dGFyZWEiLCJub2RlTmFtZSIsImRvbUlucHV0IiwiZG9tU2VsZWN0IiwiZG9tRmllbGQiLCJkb20iLCJBVkFJTF9TRVRTIiwiQ2hlY2tzIiwiYXJncyIsInNsaWNlIiwic2V0cyIsInNldCIsImxvYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiYXJyMiIsIml0ZXIiLCJmcm9tIiwidGVtcGxhdGUiLCJlbGVtZW50IiwiSVMiLCJJU18iLCJxdWlja0RvbUVsIiwiSVMkMSIsIlF1aWNrRWxlbWVudCIsIlF1aWNrV2luZG93IiwiX3F1aWNrZG9tIiwicXVpY2tkb20iLCJhcmciLCJwcmV2Q291bnQiLCJjb3VudCIsIl9wb3N0Q3JlYXRpb24iLCJhcmdzTGVuZ3RoIiwiY2hpbGQiLCJjaGlsZHJlbiIsInR5cGUiLCJhcHBseSIsInNwYXduIiwidXBkYXRlT3B0aW9ucyIsIl9xdWlja0VsZW1lbnQiLCJleGlzdGluZyIsInRleHQiLCJhcHBlbmQiLCJodG1sIiwiaW5uZXJIVE1MIiwiY29udGFpbmVyIiwiY2hpbGROb2RlcyIsImJhdGNoIiwiaXNRdWlja0VsIiwiaXNFbCIsImluaXQiLCJRdWlja0VsZW1lbnRfIiwiUXVpY2tXaW5kb3dfIiwicmVtb3ZlSXRlbSIsIml0ZW1JbmRleCIsInNwbGljZSIsIm5vcm1hbGl6ZUVsZW1lbnRBcmciLCJpc1N0YXRlU3R5bGUiLCJyZWdpc3RlclN0eWxlIiwiY2FjaGVkIiwic3R5bGVDYWNoZSIsImZucyIsIl9jbGFzcyIsInZhbHVlcyIsIlJFR0VYX1dISVRFU1BBQ0UiLCJvbl8iLCJldmVudE5hbWVzIiwiY2FsbGJhY2siLCJ1c2VDYXB0dXJlIiwiaXNQcml2YXRlIiwiX3RoaXMiLCJjYWxsYmFja1JlZiIsInNwbGl0IiwiX2V2ZW50Q2FsbGJhY2tzIiwiX19yZWZzIiwiX2luc2VydGVkIiwiX3BhcmVudCIsImV2ZW50TmFtZSIsImJhc2UiLCJfbGlzdGVuVG8iLCJldmVudCIsIl9pbnZva2VIYW5kbGVycyIsIm9uY2UiLCJfdGhpczIiLCJfb25jZUNhbGxiYWNrIiwib24iLCJvbmNlQ2FsbGJhY2siLCJvZmYiLCJvZmZfIiwiX3RoaXMzIiwiZW1pdCIsImJ1YmJsZXMiLCJ1bmRlZmluZWQiLCJjYW5jZWxhYmxlIiwiZGF0YSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImVtaXRQcml2YXRlIiwiY2FsbGJhY2tzIiwiY2IiLCJldmVudE5hbWVUb0xpc3RlbkZvciIsImxpc3Rlbk1ldGhvZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudHMiLCJyZXN1bHQiLCJyZWxhdGVkIiwiY3VycmVudFN0YXRlU3R5bGUiLCJ0aGVuIiwiZm9yY2VTdHlsZSIsInN0eWxlU2FmZSIsInNraXBDb21wdXRlZCIsImNvbXB1dGVkIiwic2FtcGxlIiwic3R5bGVQYXJzZWQiLCJwYXJzZUZsb2F0IiwicmVjYWxjU3R5bGUiLCJyZWNhbGNDaGlsZHJlbiIsInRhcmdldFN0eWxlcyIsIl9yZXNvbHZlRm5TdHlsZXMiLCJfZ2V0QWN0aXZlU3RhdGVzIiwiX2NoaWxkcmVuIiwic3RhdGUiLCJzdGF0ZXMiLCJfc3RhdGUiLCJfc3RhdGVTaGFyZWQiLCJfc3RhdGVzIiwiX3N0eWxlcyIsImhpZGUiLCJzaG93IiwiZGlzcGxheSIsIm9yaWVudGF0aW9uR2V0dGVyIiwid2lkdGgiLCJoZWlnaHQiLCJhc3BlY3RSYXRpb0dldHRlciIsInN0eWxlJDEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJRdWlja1dpbmRvdyQxIiwiUXVpY2tXaW5kb3ckMiIsInJhdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIk1lZGlhUXVlcnkiLCJSVUxFX0RFSUxJTUlURVIiLCJNZWRpYVF1ZXJ5JDEiLCJ0ZXN0UnVsZSIsInBhcnNlUXVlcnkiLCJxdWVyeVN0cmluZyIsInF1ZXJ5U3BsaXQiLCJwYXJlbnQiLCJwYXJlbnRNYXRjaGluZyIsIm1hcCIsImdldHRlciIsImtleVByZWZpeCIsIm1heCIsIm1pbiIsIm9yaWVudGF0aW9uIiwiYXNwZWN0UmF0aW8iLCJwYXJzZWRWYWx1ZSIsInN0cmluZ1ZhbHVlIiwicXVlcnkiLCJjdXJyZW50VmFsdWUiLCJwYXNzZWQiLCJTdGF0ZUNoYWluIiwiU3RhdGVDaGFpbiQxIiwiam9pbiIsIndpdGhvdXQiLCJpc0FwcGxpY2FibGUiLCJvdGhlckFjdGl2ZSIsImFjdGl2ZSIsIkJBU0VfU1RBVEVfVFJJR0dFUlMiLCJDQUNIRURfRk5fSU5TRVJURUQiLCJfbm9ybWFsaXplT3B0aW9ucyIsImJhc2UxIiwiYmFzZTIiLCJiYXNlMyIsImJhc2U0IiwiYmFzZTUiLCJyZWxhdGVkSW5zdGFuY2UiLCJ1cmwiLCJocmVmIiwidW5wYXNzYWJsZVN0YXRlcyIsInBhc3NTdGF0ZVRvQ2hpbGRyZW4iLCJwYXNzRGF0YVRvQ2hpbGRyZW4iLCJzdGF0ZVRyaWdnZXJzIiwiY2xvbmUiLCJfcGFyc2VUZXh0cyIsIl90ZXh0cyIsIl9wYXJzZVN0eWxlcyIsInN0eWxlcyIsInN0b3JlIiwiX21lZGlhU3RhdGVzIiwiX3Byb3ZpZGVkU3RhdGVzIiwiX3Byb3ZpZGVkU3RhdGVzU2hhcmVkIiwiX2ZsYXR0ZW5OZXN0ZWRTdGF0ZXMiLCJzcGVjaWFsU3RhdGVzIiwic3RhdGVTdHlsZXMiLCJzdGF0ZV8iLCIkYmFzZSIsImZsYXR0ZW5OZXN0ZWRTdGF0ZXMiLCJzdHlsZU9iamVjdCIsImNoYWluIiwiaGFzTm9uU3RhdGVQcm9wcyIsInN0YXRlQ2hhaW4iLCJzdHlsZUtleXMiLCJ0ZXh0cyIsIl9hcHBseU9wdGlvbnMiLCJoYW5kbGVyIiwibWV0aG9kIiwicmVmMSIsInJlZjIiLCJhdHRyIiwic3JjIiwic2VsZWN0ZWQiLCJjaGVja2VkIiwiYXR0cnMiLCJfYXBwbHlSZWdpc3RlcmVkU3R5bGUiLCJzdHlsZUFmdGVySW5zZXJ0IiwiaW52b2tlQ29tcHV0ZXJzT25jZSIsIl9pbnZva2VkQ29tcHV0ZXJzIiwicmVjYWxjT25SZXNpemUiLCJtZXRob2RzIiwiY29tcHV0ZXJzIiwiYXBwbHlEYXRhIiwiX2luaXQiLCJfcnVuQ29tcHV0ZXIiLCJfYXR0YWNoU3RhdGVFdmVudHMiLCJmb3JjZSIsImRpc2FibGVyIiwiZW5hYmxlciIsInRyaWdnZXIiLCJfcHJveHlQYXJlbnQiLCJuZXdQYXJlbnQiLCJsYXN0UGFyZW50IiwicGFyZW50cyIsImRvY3VtZW50RWxlbWVudCIsIl91bnByb3h5UGFyZW50IiwibWVkaWFTdGF0ZXMiLCJyZXN1bHRzIiwiaW5pdCQxIiwiYWxpYXNlcyIsInBhcmVudHNVbnRpbCIsIl9nZXRQYXJlbnRzIiwiaXNSZWYiLCJuZXh0UGFyZW50Iiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlBbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiX2dldENoaWxkUmVmcyIsImZyZXNoQ29weSIsImNoaWxkUmVmcyIsInJlZnMiLCJfY2hpbGRSZWZzIiwiX2dldEluZGV4QnlQcm9wIiwibWFpbiIsIl9maWx0ZXJFbGVtZW50cyIsInRyYXZlcnNpbmciLCJwYXJlbnROb2RlIiwibmV4dFNpYmxpbmciLCJuZXh0RWxlbWVudFNpYmxpbmciLCJuZXh0QWxsIiwic2libGluZ3MiLCJuZXh0IiwicHJldmlvdXNTaWJsaW5nIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInByZXZBbGwiLCJwcmV2U2libGluZyIsInByZXYiLCJyZXZlcnNlIiwiRFVNTVlfQVJSQVkiLCJ0YXJnZXRTdGF0ZSIsImFjdGl2ZVN0YXRlcyIsImRlc2lyZWRWYWx1ZSIsInRvZ2dsZSIsIl9zdGF0ZVBpcGVUYXJnZXQiLCJ0b2dnbGVTdGF0ZSIsInJlc2V0U3RhdGUiLCJhY3RpdmVTdGF0ZSIsInBpcGVTdGF0ZSIsInRhcmdldFN0eWxlIiwic3VwZXJpb3JTdGF0ZXMiLCJpbmNsdWRlQmFzZSIsInNraXBGbnMiLCJlbnRyeSIsImsiLCJzdXBlcmlvclN0eWxlcyIsImFkZENsYXNzIiwiX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSIsInJlc2V0VmFsdWUiLCJyZW1vdmVDbGFzcyIsIl90dXJuU3R5bGVPTiIsInNoYXJlZFN0YXRlcyIsIl9nZXRTdXBlcmlvclN0YXRlcyIsIl9nZXRTaGFyZWRTdGF0ZXMiLCJfdHVyblN0eWxlT0ZGIiwiYWN0aXZlU2hhcmVkU3RhdGVzIiwiX3R1cm5UZXh0T04iLCJ0YXJnZXRUZXh0IiwiX3R1cm5UZXh0T0ZGIiwic3RhdGVUb0V4Y2x1ZGUiLCJpbmNsdWRlU2hhcmVkU3RhdGVzIiwicGxhaW5TdGF0ZXMiLCJjYW5kaWRhdGUiLCJzdXBlcmlvciIsInRhcmdldFN0YXRlSW5kZXgiLCJzdGF0ZSQxIiwidG9UZW1wbGF0ZSIsImVsQ2xvbmUiLCJsZW4yIiwibmV3RWwiLCJjbG9uZU5vZGUiLCJwcmV2UGFyZW50IiwiX3JlbW92ZUNoaWxkIiwiX3JlZnJlc2hQYXJlbnQiLCJhcHBlbmRUbyIsInByZXBlbmQiLCJ1bnNoaWZ0IiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsInByZXBlbmRUbyIsImFmdGVyIiwibXlJbmRleCIsImluc2VydEFmdGVyIiwiYmVmb3JlIiwiZGV0YWNoIiwicmVtb3ZlIiwiZW1wdHkiLCJ3cmFwIiwiY3VycmVudFBhcmVudCIsInVud3JhcCIsImdyYW5kUGFyZW50IiwicGFyZW50Q2hpbGRyZW4iLCJwYXJlbnRTaWJsaW5nIiwiaGFzQ2xhc3MiLCJjbGFzc0xpc3QiLCJ0YXJnZXRJbmRleCIsInRvZ2dsZUNsYXNzIiwic2V0UmVmIiwidGFyZ2V0Q2hpbGQiLCJyZXBsYWNlbWVudENoaWxkIiwiaW5kZXhPZkNoaWxkIiwicmVwbGFjZUNoaWxkIiwicmVtb3ZlQ2hpbGQiLCJtYW5pcHVsYXRpb24iLCJuZXdWYWx1ZSIsInN2ZyIsImxpc3QiLCJwb3AiLCJ1cGRhdGVTdGF0ZVN0eWxlcyIsInBhcnNlZCIsInVwZGF0ZWRTdGF0ZXMiLCJ1cGRhdGVTdGF0ZVRleHRzIiwicGFzc1Rocm91Z2giLCJkZWZhdWx0cyIsImNvbXB1dGVyIiwiYXBwbGljYXRpb24iLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVzQW5kUHJvcGVydGllcyIsIlF1aWNrRWxlbWVudCQxIiwic3ZnTmFtZXNwYWNlIiwiUXVpY2tFbGVtZW50JDIiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsInRvSlNPTiIsInNjaGVtYSIsIm1hdGNoZXNTY2hlbWEiLCJQQVJTRV9FUlJPUl9QUkVGSVgiLCJwYXJzZVRyZWUiLCJwYXJzZVRyZWUkMSIsInRyZWUiLCJwYXJzZUNoaWxkcmVuIiwiRXJyb3IiLCJTdHJpbmciLCJOT1RfREVFUF9LRVlTIiwiTk9UX0tFWVMiLCJfZXh0ZW5kQnlSZWYiLCJleHRlbmRUZW1wbGF0ZSIsImV4dGVuZFRlbXBsYXRlJDEiLCJjdXJyZW50T3B0cyIsIm5ld09wdHMiLCJnbG9iYWxPcHRzIiwiY3VycmVudENoaWxkIiwiY3VycmVudENoaWxkcmVuIiwiZ2xvYmFsT3B0c1RyYW5zZm9ybSIsIm1heExlbmd0aCIsIm5lZWRzVGVtcGxhdGVXcmFwIiwibmV3Q2hpbGQiLCJuZXdDaGlsZFByb2Nlc3NlZCIsIm5ld0NoaWxkcmVuIiwibm9DaGFuZ2VzIiwicmVtYWluaW5nTmV3Q2hpbGRyZW4iLCJvcHRzIiwiTWF0aCIsIlF1aWNrVGVtcGxhdGUkMSIsImV4dGVuZEJ5UmVmIiwibmV3Q2hpbGRyZW5SZWZzIiwiUXVpY2tUZW1wbGF0ZSIsImlzVHJlZSIsIm5ld1ZhbHVlcyIsImNoaWxkRGF0YSIsIl9leHRlbmRUZW1wbGF0ZSIsImlzVGVtcGxhdGUiLCJRdWlja0JhdGNoIiwiUXVpY2tCYXRjaCQxIiwiZWxlbWVudHMiLCJyZXR1cm5SZXN1bHRzMSIsInJldHVyblJlc3VsdHMiLCJfcmV0dXJuIiwicmV0dXJuTmV4dCIsImxhc3RSZXN1bHRzIiwicmVzdWx0czEiLCJfZWxlbWVudCIsIlNIT1JUQ1VUUyIsInNob3J0Y3V0IiwicHJvbWlzZSIsIm9uRmluYWxseSIsInZhbCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyIiwiVGltZW91dEVycm9yIiwibWVzc2FnZSIsIm1zIiwiZmFsbGJhY2siLCJyZWplY3QiLCJ0aW1lciIsInNldFRpbWVvdXQiLCJwRmluYWxseSIsImNsZWFyVGltZW91dCIsImVtaXR0ZXIiLCJjYW5jZWwiLCJyZXQiLCJhc3NpZ24iLCJyZWplY3Rpb25FdmVudHMiLCJtdWx0aUFyZ3MiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJyZXNvbHZlSGFuZGxlciIsInJlamVjdEhhbmRsZXIiLCJyZWFzb24iLCJyZWplY3Rpb25FdmVudCIsInRpbWVvdXQiLCJwVGltZW91dCIsImNyZWF0ZUVuZEJyZWFrIiwiX19pc0VuZEJyZWFrIiwidHlwZXMiLCJlbGVtIiwicmVkdWNlIiwidHJhbnMiLCJFdmVudExpdGUiLCJtb2R1bGUiLCJMSVNURU5FUlMiLCJtaXhpbiIsImZ1bmMiLCJnZXRMaXN0ZW5lcnMiLCJ0aGF0Iiwib3JpZ2luYWxMaXN0ZW5lciIsImxpc3RuZXJzIiwibmUiLCJsaXN0ZW5lcnMiLCJhcmdsZW4iLCJ6ZXJvYXJnIiwib25lYXJnIiwibW9yZWFyZ3MiLCJyZWFkb25seSIsIkRPTSIsInBvcHVwIiwicG9zaXRpb24iLCJ6SW5kZXgiLCJ0b3AiLCJsZWZ0IiwibWluSGVpZ2h0IiwidmlzaWJpbGl0eSIsIm92ZXJmbG93IiwidHJhbnNpdGlvbiIsInNldHRpbmdzIiwiJG9wZW4iLCJvdmVybGF5Iiwib3BhY2l0eSIsImJhY2tncm91bmRDb2xvciIsIm92ZXJsYXlDb2xvciIsImJveFNpemluZyIsIm1heFdpZHRoIiwibWFyZ2luIiwicGFkZGluZyIsImNvbnRlbnRQYWRkaW5nIiwiZHVyYXRpb24iLCIkY2VudGVyUGxhY2VtZW50IiwiJHRvcFBsYWNlbWVudCIsIiRib3R0b21QbGFjZW1lbnQiLCJib3R0b20iLCJwbGFjZW1lbnQiLCJ2aXNpYmxlIiwiYWxpZ25Ub0NlbnRlciIsImNsb3NlIiwiaW5zaWRlIiwic2l6ZSIsInJpZ2h0IiwiY29sb3IiLCJ2aWV3Qm94IiwiZCIsImZpbGwiLCJib2R5V3JhcHBlciIsInRlbXBsYXRlcyIsIl9fcHJvdG9fXyIsImV4dGVuZFNldHRpbmdzIiwiY29uZGl0aW9uIiwiZnVuY3Rpb24iLCJvcGVuIiwidHJpZ2dlcnMiLCJzY2hlZHVsZVNjcm9sbFJlc2V0Iiwic2NoZWR1bGVOZXh0Iiwic2Nyb2xsIiwidHJhbnNpdGlvbkVuZCIsImRldGVjdEFuaW1hdGlvbiIsInNjcm9sbE9mZnNldCIsInNjcm9sbFkiLCJkb2N1bWVudE9mZnNldCIsImJvZHkiLCJ2aXNpYmlsaXR5QXBpS2V5cyIsImhpZGRlbiIsInZpc2liaWxpdHljaGFuZ2UiLCJtc0hpZGRlbiIsIndlYmtpdEhpZGRlbiIsImlzSUUiLCJhbGwiLCJhdG9iIiwiaXNJRTExIiwibmF2aWdhdG9yIiwibXNQb2ludGVyRW5hYmxlZCIsImlzRWRnZSIsInVzZXJBZ2VudCIsIlBvcHVwIiwiRXZlbnRFbWl0dGVyIiwid3JhcEJvZHkiLCJib2R5Q2hpbGRyZW4iLCJ1bndyYXBCb2R5IiwiZGVzdHJveUFsbCIsImluc3RhbmNlcyIsImRlc3Ryb3kiLCJ0ZW1wbGF0ZTEiLCJyb3VuZCIsInJhbmRvbSIsImRlc3Ryb3llZCIsIm9mZnNldCIsIl9jcmVhdGVFbGVtZW50cyIsIl9hdHRhY2hCaW5kaW5ncyIsIl9hcHBseVRlbXBsYXRlIiwiY3VzdG9tIiwiZXNjIiwia2V5Q29kZSIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZXhpdEludGVudCIsInRocmVzaG9sZCIsInlUaHJlc2hvbGQiLCJjbGllbnRZIiwibmF2aWdhdGlvbiIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJiYWNrIiwiX2RldGFjaEJpbmRpbmdzIiwiX3Rocm93RGVzdHJveWVkIiwic2V0Q29udGVudCIsInF1aWNrRWwiLCJyZXBsYWNlV2l0aCIsImNvbnRlbnRIZWlnaHQiLCJ3aW5kb3dIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ0cmlnZ2VyTmFtZSIsImhhc09wZW4iLCJmb3JjZU9wZW4iLCJvcGVuTGltaXQiLCJtaW5XaWR0aCIsInByb21pc2VCcmVhayIsIm9wZW5Qb3B1cHMiLCJwcm9taXNlRXZlbnQiLCJjYXRjaCIsImVuZCIsInByZXZlbnRSZXNldCIsIlBvcHVwJDEiLCJxdWlja3BvcHVwIiwibmV3U2V0dGluZ3MiLCJuZXdUZW1wbGF0ZXMiLCJvdXRwdXRTZXR0aW5ncyIsIm91dHB1dFRlbXBsYXRlcyIsInF1aWNrcG9wdXAkMSIsInJlc3RhcnRTYW5kYm94Iiwic2FuZGJveCIsImRpdiIsImJvcmRlciIsImV4Y2x1ZGUiLCJleGNsdWRlcyIsImV4Y2x1ZGVQcm9wcyIsInJlcyIsImV4dGVuZEV4Y2x1ZGUiLCJBc3NlcnRpb25FcnJvciIsIl9wcm9wcyIsInNzZiIsInNob3dEaWZmIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzdGFjayIsImhhc1Byb3BlcnR5IiwicGFyc2VQYXRoIiwicGF0aCIsInN0ciIsInBhcnRzIiwibWF0Y2giLCJtYXBNYXRjaGVzIiwicmVnZXhwIiwibUFyciIsImV4ZWMiLCJwIiwiaW50ZXJuYWxHZXRQYXRoVmFsdWUiLCJwYXRoRGVwdGgiLCJ0ZW1wb3JhcnlWYWx1ZSIsInBhcnQiLCJpbnRlcm5hbFNldFBhdGhWYWx1ZSIsInRlbXBPYmoiLCJwcm9wTmFtZSIsInByb3BWYWwiLCJnZXRQYXRoSW5mbyIsImxhc3QiLCJpbmZvIiwiZXhpc3RzIiwiZ2V0UGF0aFZhbHVlIiwic2V0UGF0aFZhbHVlIiwiZmxhZyIsImZsYWdzIiwiX19mbGFncyIsIm5lZ2F0ZSIsImV4cHIiLCJnbG9iYWwiLCJmYWN0b3J5IiwidGhpcyIsInByb21pc2VFeGlzdHMiLCJnbG9iYWxPYmplY3QiLCJzZWxmIiwic3ltYm9sRXhpc3RzIiwibWFwRXhpc3RzIiwiTWFwIiwic2V0RXhpc3RzIiwiU2V0Iiwid2Vha01hcEV4aXN0cyIsIldlYWtNYXAiLCJ3ZWFrU2V0RXhpc3RzIiwiV2Vha1NldCIsImRhdGFWaWV3RXhpc3RzIiwiRGF0YVZpZXciLCJzeW1ib2xJdGVyYXRvckV4aXN0cyIsInN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzIiwidG9TdHJpbmdUYWciLCJzZXRFbnRyaWVzRXhpc3RzIiwiZW50cmllcyIsIm1hcEVudHJpZXNFeGlzdHMiLCJzZXRJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwibWFwSXRlcmF0b3JQcm90b3R5cGUiLCJhcnJheUl0ZXJhdG9yRXhpc3RzIiwiYXJyYXlJdGVyYXRvclByb3RvdHlwZSIsInN0cmluZ0l0ZXJhdG9yRXhpc3RzIiwic3RyaW5nSXRlcmF0b3JQcm90b3R5cGUiLCJ0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCIsInRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCIsInR5cGVEZXRlY3QiLCJ0eXBlb2ZPYmoiLCJsb2NhdGlvbiIsIm1pbWVUeXBlcyIsInBsdWdpbnMiLCJIVE1MRWxlbWVudCIsInRhZ05hbWUiLCJzdHJpbmdUYWciLCJvYmpQcm90b3R5cGUiLCJSZWdFeHAiLCJEYXRlIiwiZXhwZWN0VHlwZXMiLCJmbGFnTXNnIiwic3NmaSIsInQiLCJhcnQiLCJjaGFyQXQiLCJvciIsIm9ialR5cGUiLCJzb21lIiwiZXhwZWN0ZWQiLCJnZXRBY3R1YWwiLCJfb2JqIiwiRnVuY3Rpb24iLCJmdW5jdGlvbk5hbWVNYXRjaCIsImdldEZ1bmNOYW1lIiwiYUZ1bmMiLCJnZXRQcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImFkZFByb3BlcnR5IiwicHJvdG8iLCJnZXRFbnVtZXJhYmxlUHJvcGVydGllcyIsImluY2x1ZGVTdGFjayIsInRydW5jYXRlVGhyZXNob2xkIiwidXNlUHJveHkiLCJwcm94eUV4Y2x1ZGVkS2V5cyIsImluc3BlY3QiLCJzaG93SGlkZGVuIiwiZGVwdGgiLCJjb2xvcnMiLCJjdHgiLCJzZWVuIiwic3R5bGl6ZSIsImZvcm1hdFZhbHVlIiwiaXNET01FbGVtZW50IiwicmVjdXJzZVRpbWVzIiwiZXhwb3J0cyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsIm91dGVySFRNTCIsInhtbFZlcnNpb24iLCJ4bWxTZXJpYWxpemVyIiwiWE1MU2VyaWFsaXplciIsInNlcmlhbGl6ZVRvU3RyaW5nIiwibnMiLCJ2aXNpYmxlS2V5cyIsIm5hbWVTdWZmaXgiLCJpc0Vycm9yIiwiZ2V0TmFtZSIsImlzUmVnRXhwIiwiaXNEYXRlIiwidG9VVENTdHJpbmciLCJmb3JtYXRFcnJvciIsInR5cGVkQXJyYXkiLCJicmFjZXMiLCJpc1R5cGVkQXJyYXkiLCJmb3JtYXRBcnJheSIsImZvcm1hdFR5cGVkQXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkluZmluaXR5IiwibCIsInByb3BEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwibGluZSIsInN1YnN0ciIsImN1ciIsImFyIiwib2JqZWN0VG9TdHJpbmciLCJyZSIsIm8iLCJvYmpEaXNwbGF5Iiwia3N0ciIsImdldE1lc3NhZ2UiLCJhY3R1YWwiLCJtc2ciLCJ0cmFuc2ZlckZsYWdzIiwiYXNzZXJ0aW9uIiwiaW5jbHVkZUFsbCIsIkZha2VNYXAiLCJfa2V5Iiwibm93IiwiZ2V0TWFwIiwic2V0TWFwIiwiaXNFeHRlbnNpYmxlIiwiTWVtb2l6ZU1hcCIsIm1lbW9pemVDb21wYXJlIiwibGVmdEhhbmRPcGVyYW5kIiwicmlnaHRIYW5kT3BlcmFuZCIsIm1lbW9pemVNYXAiLCJpc1ByaW1pdGl2ZSIsImxlZnRIYW5kTWFwIiwibWVtb2l6ZVNldCIsImRlZXBFcXVhbCIsImNvbXBhcmF0b3IiLCJleHRlbnNpdmVEZWVwRXF1YWwiLCJzaW1wbGVSZXN1bHQiLCJzaW1wbGVFcXVhbCIsIm1lbW9pemUiLCJtZW1vaXplUmVzdWx0TGVmdCIsIm1lbW9pemVSZXN1bHRSaWdodCIsImNvbXBhcmF0b3JSZXN1bHQiLCJsZWZ0SGFuZFR5cGUiLCJleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUiLCJ2YWx1ZU9mIiwiaXRlcmFibGVFcXVhbCIsInJlZ2V4cEVxdWFsIiwiZ2VuZXJhdG9yRXF1YWwiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiZW50cmllc0VxdWFsIiwib2JqZWN0RXF1YWwiLCJsZWZ0SGFuZEl0ZW1zIiwicmlnaHRIYW5kSXRlbXMiLCJnYXRoZXJFbnRyaWVzIiwiZ2V0R2VuZXJhdG9yRW50cmllcyIsImhhc0l0ZXJhdG9yRnVuY3Rpb24iLCJnZXRJdGVyYXRvckVudHJpZXMiLCJpdGVyYXRvckVycm9yIiwiZ2VuZXJhdG9yIiwiZ2VuZXJhdG9yUmVzdWx0IiwiYWNjdW11bGF0b3IiLCJkb25lIiwiZ2V0RW51bWVyYWJsZUtleXMiLCJrZXlzRXF1YWwiLCJsZWZ0SGFuZEtleXMiLCJyaWdodEhhbmRLZXlzIiwibGVmdEhhbmRFbnRyaWVzIiwicmlnaHRIYW5kRW50cmllcyIsImlzUHJveHlFbmFibGVkIiwiUHJveHkiLCJSZWZsZWN0IiwicHJvcGVydHlHZXR0ZXIiLCJuZXdBc3NlcnRpb24iLCJjaGFpIiwiQXNzZXJ0aW9uIiwiZm5MZW5ndGhEZXNjIiwiYWRkTGVuZ3RoR3VhcmQiLCJmbiIsImFzc2VydGlvbk5hbWUiLCJpc0NoYWluYWJsZSIsImJ1aWx0aW5zIiwicHJveGlmeSIsIm5vbkNoYWluYWJsZU1ldGhvZE5hbWUiLCJwcm94eUdldHRlciIsImhhcyIsInN1Z2dlc3Rpb24iLCJzdWdnZXN0aW9uRGlzdGFuY2UiLCJkaXN0Iiwic3RyaW5nRGlzdGFuY2VDYXBwZWQiLCJzdHJBIiwic3RyQiIsImNhcCIsImFicyIsIm1lbW8iLCJjaCIsImFkZE1ldGhvZCIsIm1ldGhvZFdyYXBwZXIiLCJvdmVyd3JpdGVQcm9wZXJ0eSIsIl9nZXQiLCJfc3VwZXIiLCJvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyIiwib3JpZ0xvY2tTc2ZpIiwib3ZlcndyaXRlTWV0aG9kIiwiX21ldGhvZCIsIm92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlciIsImNhblNldFByb3RvdHlwZSIsInNldFByb3RvdHlwZU9mIiwidGVzdEZuIiwiZXhjbHVkZU5hbWVzIiwicHJvcERlc2MiLCJhZGRDaGFpbmFibGVNZXRob2QiLCJjaGFpbmluZ0JlaGF2aW9yIiwiY2hhaW5hYmxlQmVoYXZpb3IiLCJfX21ldGhvZHMiLCJjaGFpbmFibGVNZXRob2RHZXR0ZXIiLCJjaGFpbmFibGVNZXRob2RXcmFwcGVyIiwiYXNzZXJ0ZXJOYW1lcyIsImFzc2VydGVyTmFtZSIsInBkIiwib3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIiwiX2NoYWluaW5nQmVoYXZpb3IiLCJvdmVyd3JpdGluZ0NoYWluYWJsZU1ldGhvZEdldHRlciIsIm92ZXJ3cml0aW5nQ2hhaW5hYmxlTWV0aG9kV3JhcHBlciIsImNvbXBhcmVCeUluc3BlY3QiLCJhIiwiYiIsImdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW0iLCJnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyIsImNvbXBhdGlibGVJbnN0YW5jZSIsInRocm93biIsImVycm9yTGlrZSIsImNvbXBhdGlibGVDb25zdHJ1Y3RvciIsImNvbXBhdGlibGVNZXNzYWdlIiwiZXJyTWF0Y2hlciIsImNvbXBhcmlzb25TdHJpbmciLCJnZXRGdW5jdGlvbk5hbWUiLCJjb25zdHJ1Y3RvckZuIiwiZ2V0Q29uc3RydWN0b3JOYW1lIiwiY29uc3RydWN0b3JOYW1lIiwidHJpbSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwicmVxdWlyZSQkNSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJwYXRodmFsIiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1IiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQyMCIsInJlcXVpcmUkJDIxIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMyIsInJlcXVpcmUkJDI0IiwiX2NoYWkiLCJ1dGlsIiwibG9ja1NzZmkiLCJjb25zb2xlIiwid2FybiIsImFzc2VydCIsIm5lZ2F0ZU1zZyIsIl9hY3R1YWwiLCJvayIsImFuIiwiYXJ0aWNsZSIsIlNhbWVWYWx1ZVplcm8iLCJpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciIsImluY2x1ZGUiLCJpc0RlZXAiLCJpbmNsdWRlZCIsImlzRXFsIiwiZXFsIiwiZmlyc3RFcnIiLCJudW1FcnJzIiwicHJvcEFzc2VydGlvbiIsImNoZWNrRXJyb3IiLCJpdGVtc0NvdW50IiwiY2hlY2tBcmd1bWVudHMiLCJhc3NlcnRFcXVhbCIsInByZXZMb2NrU3NmaSIsImFzc2VydEVxbCIsImFzc2VydEFib3ZlIiwibiIsImRvTGVuZ3RoIiwibXNnUHJlZml4IiwiblR5cGUiLCJlcnJvck1lc3NhZ2UiLCJzaG91bGRUaHJvdyIsInRvIiwiaGF2ZSIsInByaW50T2JqIiwiYXNzZXJ0TGVhc3QiLCJhc3NlcnRCZWxvdyIsImFzc2VydE1vc3QiLCJzdGFydCIsImZpbmlzaCIsInN0YXJ0VHlwZSIsImZpbmlzaFR5cGUiLCJyYW5nZSIsImFzc2VydEluc3RhbmNlT2YiLCJpc0luc3RhbmNlT2YiLCJhc3NlcnRQcm9wZXJ0eSIsImlzTmVzdGVkIiwiaXNPd24iLCJuYW1lVHlwZSIsInBhdGhJbmZvIiwiYXNzZXJ0T3duUHJvcGVydHkiLCJhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJhY3R1YWxEZXNjcmlwdG9yIiwiYXNzZXJ0TGVuZ3RoQ2hhaW4iLCJhc3NlcnRMZW5ndGgiLCJhc3NlcnRNYXRjaCIsImlzIiwiYXNzZXJ0S2V5cyIsImtleXNUeXBlIiwiZGVlcFN0ciIsIm1peGVkQXJnc01zZyIsImFueSIsImV4cGVjdGVkS2V5IiwiYWN0dWFsS2V5IiwiZXZlcnkiLCJhc3NlcnRUaHJvd3MiLCJlcnJNc2dNYXRjaGVyIiwiY2F1Z2h0RXJyIiwiZXZlcnlBcmdJc1VuZGVmaW5lZCIsImV2ZXJ5QXJnSXNEZWZpbmVkIiwiQm9vbGVhbiIsImVycm9yTGlrZUZhaWwiLCJlcnJNc2dNYXRjaGVyRmFpbCIsImVycm9yTGlrZVN0cmluZyIsImlzQ29tcGF0aWJsZUluc3RhbmNlIiwiaXNDb21wYXRpYmxlQ29uc3RydWN0b3IiLCJwbGFjZWhvbGRlciIsImlzQ29tcGF0aWJsZU1lc3NhZ2UiLCJyZXNwb25kVG8iLCJpdHNlbGYiLCJjb250ZXh0Iiwic2F0aXNmeSIsIm1hdGNoZXIiLCJjbG9zZVRvIiwiZGVsdGEiLCJpc1N1YnNldE9mIiwic3Vic2V0Iiwic3VwZXJzZXQiLCJjbXAiLCJjb250YWlucyIsIm9yZGVyZWQiLCJpZHgiLCJtYXRjaElkeCIsImVsZW0yIiwiYmUiLCJmYWlsTXNnIiwiZmFpbE5lZ2F0ZU1zZyIsIm9uZU9mIiwiYXNzZXJ0Q2hhbmdlcyIsImluaXRpYWwiLCJmaW5hbCIsIm1zZ09iaiIsImFzc2VydEluY3JlYXNlcyIsImFzc2VydERlY3JlYXNlcyIsImFzc2VydERlbHRhIiwiYmVoYXZpb3IiLCJyZWFsRGVsdGEiLCJleHByZXNzaW9uIiwiaXNTZWFsZWQiLCJpc0Zyb3plbiIsImlzRmluaXRlIiwiZXhwZWN0IiwiZmFpbCIsIm9wZXJhdG9yIiwibG9hZFNob3VsZCIsInNob3VsZEdldHRlciIsInNob3VsZFNldHRlciIsInNob3VsZCIsImVxdWFsIiwidmFsMSIsInZhbDIiLCJUaHJvdyIsImVycnQiLCJlcnJzIiwiZXhpc3QiLCJub3QiLCJTaG91bGQiLCJleHByZXNzIiwiZXJybXNnIiwiaXNPayIsImlzTm90T2siLCJhY3QiLCJleHAiLCJub3RFcXVhbCIsInN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJkZWVwU3RyaWN0RXF1YWwiLCJub3REZWVwRXF1YWwiLCJpc0Fib3ZlIiwiYWJ2IiwiYWJvdmUiLCJpc0F0TGVhc3QiLCJhdGxzdCIsImxlYXN0IiwiaXNCZWxvdyIsImJsdyIsImJlbG93IiwiaXNBdE1vc3QiLCJhdG1zdCIsIm1vc3QiLCJpc1RydWUiLCJpc05vdFRydWUiLCJpc0ZhbHNlIiwiaXNOb3RGYWxzZSIsImlzTnVsbCIsImlzTm90TnVsbCIsIk5hTiIsImlzTm90TmFOIiwibm90RXhpc3RzIiwiaXNVbmRlZmluZWQiLCJpc0RlZmluZWQiLCJpc0Z1bmN0aW9uIiwiaXNOb3RGdW5jdGlvbiIsImlzTm90T2JqZWN0IiwiaXNOb3RBcnJheSIsImlzU3RyaW5nIiwiaXNOb3RTdHJpbmciLCJpc051bWJlciIsImlzTm90TnVtYmVyIiwiZmluaXRlIiwiaXNCb29sZWFuIiwiaXNOb3RCb29sZWFuIiwidHlwZU9mIiwibm90VHlwZU9mIiwiaW5zdGFuY2VPZiIsIm5vdEluc3RhbmNlT2YiLCJpbmMiLCJub3RJbmNsdWRlIiwiZGVlcEluY2x1ZGUiLCJub3REZWVwSW5jbHVkZSIsIm5lc3RlZEluY2x1ZGUiLCJuZXN0ZWQiLCJub3ROZXN0ZWRJbmNsdWRlIiwiZGVlcE5lc3RlZEluY2x1ZGUiLCJub3REZWVwTmVzdGVkSW5jbHVkZSIsIm93bkluY2x1ZGUiLCJub3RPd25JbmNsdWRlIiwiZGVlcE93bkluY2x1ZGUiLCJub3REZWVwT3duSW5jbHVkZSIsIm5vdE1hdGNoIiwibm90UHJvcGVydHkiLCJwcm9wZXJ0eVZhbCIsIm5vdFByb3BlcnR5VmFsIiwiZGVlcFByb3BlcnR5VmFsIiwibm90RGVlcFByb3BlcnR5VmFsIiwib3duUHJvcGVydHkiLCJub3RPd25Qcm9wZXJ0eSIsIm93blByb3BlcnR5VmFsIiwibm90T3duUHJvcGVydHlWYWwiLCJkZWVwT3duUHJvcGVydHlWYWwiLCJub3REZWVwT3duUHJvcGVydHlWYWwiLCJuZXN0ZWRQcm9wZXJ0eSIsIm5vdE5lc3RlZFByb3BlcnR5IiwibmVzdGVkUHJvcGVydHlWYWwiLCJub3ROZXN0ZWRQcm9wZXJ0eVZhbCIsImRlZXBOZXN0ZWRQcm9wZXJ0eVZhbCIsIm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCIsImxlbmd0aE9mIiwiaGFzQW55S2V5cyIsImhhc0FsbEtleXMiLCJjb250YWluc0FsbEtleXMiLCJjb250YWluIiwiZG9lc05vdEhhdmVBbnlLZXlzIiwiZG9lc05vdEhhdmVBbGxLZXlzIiwiaGFzQW55RGVlcEtleXMiLCJoYXNBbGxEZWVwS2V5cyIsImNvbnRhaW5zQWxsRGVlcEtleXMiLCJkb2VzTm90SGF2ZUFueURlZXBLZXlzIiwiZG9lc05vdEhhdmVBbGxEZWVwS2V5cyIsInRocm93cyIsImFzc2VydEVyciIsInRocm93IiwiZG9lc05vdFRocm93IiwiYXBwcm94aW1hdGVseSIsInNhbWVNZW1iZXJzIiwic2V0MSIsInNldDIiLCJzYW1lIiwibWVtYmVycyIsIm5vdFNhbWVNZW1iZXJzIiwic2FtZURlZXBNZW1iZXJzIiwibm90U2FtZURlZXBNZW1iZXJzIiwic2FtZU9yZGVyZWRNZW1iZXJzIiwibm90U2FtZU9yZGVyZWRNZW1iZXJzIiwic2FtZURlZXBPcmRlcmVkTWVtYmVycyIsIm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMiLCJpbmNsdWRlTWVtYmVycyIsIm5vdEluY2x1ZGVNZW1iZXJzIiwiaW5jbHVkZURlZXBNZW1iZXJzIiwibm90SW5jbHVkZURlZXBNZW1iZXJzIiwiaW5jbHVkZU9yZGVyZWRNZW1iZXJzIiwibm90SW5jbHVkZU9yZGVyZWRNZW1iZXJzIiwiaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyIsIm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMiLCJpbkxpc3QiLCJjaGFuZ2VzIiwiY2hhbmdlIiwiY2hhbmdlc0J5IiwidG1wTXNnIiwiYnkiLCJkb2VzTm90Q2hhbmdlIiwiY2hhbmdlc0J1dE5vdEJ5IiwiYnV0IiwiaW5jcmVhc2VzIiwiaW5jcmVhc2UiLCJpbmNyZWFzZXNCeSIsImRvZXNOb3RJbmNyZWFzZSIsImluY3JlYXNlc0J1dE5vdEJ5IiwiZGVjcmVhc2VzIiwiZGVjcmVhc2UiLCJkZWNyZWFzZXNCeSIsImRvZXNOb3REZWNyZWFzZSIsImRvZXNOb3REZWNyZWFzZUJ5IiwiZGVjcmVhc2VzQnV0Tm90QnkiLCJpZkVycm9yIiwiZXh0ZW5zaWJsZSIsImlzTm90RXh0ZW5zaWJsZSIsInNlYWxlZCIsImlzTm90U2VhbGVkIiwiZnJvemVuIiwiaXNOb3RGcm96ZW4iLCJpc0VtcHR5IiwiaXNOb3RFbXB0eSIsImFsaWFzIiwiYXMiLCJ1c2VkIiwidXNlIiwiY29yZSIsImNoYWlEb20iLCJyZXF1aXJlIiwidXRpbHMiLCJlbFRvU3RyaW5nIiwiZGVzYyIsImlzTm9kZUxpc3QiLCJpc0hUTUxFbGVtZW50IiwiYXR0cmlidXRlcyIsImF0dHJBc3NlcnQiLCJvYmpEZXNjIiwidGV4dE1zZyIsImFjdHVhbExlbmd0aCIsIm1hdGNoZXMiLCJzdWJpdGVtIiwidG9VcHBlckNhc2UiLCJjaGFpU3R5bGUiLCJpc05vbkNvbG9ycyIsInByb3BlcnR5VmFsdWUiLCJjb21wYXJlQ1NTVmFsdWUiLCJlbGVtZW50VGFnIiwidGhyb3dNZXNzYWdlIiwidGhyb3dNZXNzYWdlTmVnYXRpdmUiLCJwcm9wZXJ0eUhpZmVuQ2FzZSIsImZha2UiLCJmb250U2l6ZSIsImlmcmFtZSIsImZha2VTdHlsZSIsImhhc0F1dG9WYWx1ZSIsInJlZyIsImVzY2FwZVJlZ0V4cCIsImNvbXBhcmlzb25SZXN1bHQiLCJnZXRQcm90b3R5cGVPZkV4aXN0cyIsImlzRG9tIiwiaHRtbEVsZW1lbnRFeGlzdHMiLCJpc0FycmF5RXhpc3RzIiwiY2xlYXIiLCJjbGVhck1hcCIsImRlbGV0ZSIsImRlbGV0ZU1hcCIsIkRFRkFVTFRfVE9MRVJBTkNFIiwiYm90aE51bWJlcnMiLCJhbG1vc3RFcXVhbCIsInRvbCIsInRvbGVyYW5jZSIsImNoYWlBbG1vc3QiLCJjdXN0b21Ub2xlcmFuY2UiLCJzdGFuZGFyZFRvbGVyYW5jZSIsIm92ZXJyaWRlQXNzZXJ0RXF1YWwiLCJvdmVycmlkZUFzc2VydEVxbCIsInRvbGVyYW5jZU92ZXJyaWRlIiwiZ2xvYmFscyIsInN0cmluZ3MiLCJtZXNzYWdlcyIsInByZWRpY2F0ZXMiLCJmdW5jdGlvbnMiLCJtYXliZSIsImNvbGxlY3Rpb25zIiwibmVnaW5mIiwicG9zaW5mIiwiaGF2ZVN5bWJvbHMiLCJ2IiwicyIsImFsIiwiZiIsImFzc2lnbmVkIiwiemVybyIsImluZmluaXR5IiwiaW50ZWdlciIsImV2ZW4iLCJvZGQiLCJncmVhdGVyIiwiYmV0d2VlbiIsImdyZWF0ZXJPckVxdWFsIiwibGVzc09yRXF1YWwiLCJpblJhbmdlIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsImVtcHR5U3RyaW5nIiwibm9uRW1wdHlTdHJpbmciLCJib29sZWFuIiwiZW1wdHlPYmplY3QiLCJub25FbXB0eU9iamVjdCIsImluc3RhbmNlU3RyaWN0IiwibGlrZSIsImVtcHR5QXJyYXkiLCJub25FbXB0eUFycmF5IiwiYXJyYXlMaWtlIiwiZGF0ZSIsImhhc0xlbmd0aCIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMiLCJhc3NlcnRNb2RpZmllciIsImFzc2VydEltcGwiLCJub3RNb2RpZmllciIsIm5vdEltcGwiLCJtYXliZU1vZGlmaWVyIiwibWF5YmVJbXBsIiwiY3JlYXRlTW9kaWZpZWRNb2RpZmllciIsImNyZWF0ZU9mUHJlZGljYXRlcyIsImNyZWF0ZU9mTW9kaWZpZXJzIiwiY3JlYXRlTWF5YmVPZk1vZGlmaWVycyIsImV4cG9ydEZ1bmN0aW9ucyIsImxocyIsInJocyIsIngiLCJ5Iiwic3Vic3RyaW5nIiwicmVnZXgiLCJlcnJvciIsImFyY2hldHlwZSIsIml0ZXJhdGlvbiIsImdldFRpbWUiLCJtYXBTaW1wbGUiLCJtYXBDb21wbGV4IiwicHJlZGljYXRlIiwibSIsInRlc3RBcnJheSIsInRlc3RPYmplY3QiLCJkZWZhdWx0TWVzc2FnZSIsImFzc2VydFByZWRpY2F0ZSIsImFyZ0NvdW50IiwiRXJyb3JUeXBlIiwibW9kaWZpZWRQcmVkaWNhdGUiLCJvZk1vZGlmaWVyIiwiY29sbGVjdGlvbiIsImNvZXJjZUNvbGxlY3Rpb24iLCJpZ25vcmUiLCJtb2RpZmllciIsImNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zIiwibW9kaWZpZWQiLCJvZiIsImNoZWNrIiwicGx1Z2luIiwiaXNFbWl0dGVyIiwiRXZlbnRUYXJnZXQiLCJub2RlIiwiYnJvd3NlciIsIl9uYW1lIiwiYXNzZXJ0RW1pc3Npb24iLCJjaGFpQXNzZXJ0dHlwZSIsImNoYWlFdmVudHMiLCJtb2NoYSIsInNldHVwIiwic2xvdyIsIl9fa2FybWFfXyIsImJhaWwiLCJzdWl0ZSIsImhlbHBlcnMiLCJ0ZWFyZG93biIsInBhY2thZ2VWZXJzaW9uIiwiZGVsYXkiLCJjb250ZW50cyIsImxhc3RDaGlsZCIsInNwYW4iLCJjbGFzcyIsInBvcHVwQSIsInBvcHVwQiIsIlBvcHVwMiIsInN1aXRlU2V0dXAiLCJvcGVuUHJvbWlzZSIsIm9wZW5UaW1lIiwic3RhcnRUaW1lIiwiaXNQZW5kaW5nIiwiYmVmb3Jlb3BlbiIsImZpbmlzaG9wZW4iLCJiZWZvcmVjbG9zZSIsImZpbmlzaGNsb3NlIl0sIm1hcHBpbmdzIjoiNkZBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDcEI7O0FBRUEsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU9BLE1BQU0sQ0FBQ0MsUUFBZCxLQUEyQixRQUEvRCxFQUF5RTtBQUN2RUgsSUFBQUEsT0FBTyxHQUFHLFVBQVVDLEdBQVYsRUFBZTtBQUN2QixhQUFPLE9BQU9BLEdBQWQ7QUFDRCxLQUZEO0FBR0QsR0FKRCxNQUlPO0FBQ0xELElBQUFBLE9BQU8sR0FBRyxVQUFVQyxHQUFWLEVBQWU7QUFDdkIsYUFBT0EsR0FBRyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsVUFBekIsSUFBdUNELEdBQUcsQ0FBQ0csV0FBSixLQUFvQkYsTUFBM0QsSUFBcUVELEdBQUcsS0FBS0MsTUFBTSxDQUFDRyxTQUFwRixHQUFnRyxRQUFoRyxHQUEyRyxPQUFPSixHQUF6SDtBQUNELEtBRkQ7QUFHRDs7QUFFRCxTQUFPRCxPQUFPLENBQUNDLEdBQUQsQ0FBZDtBQUNEOztBQUFBLElBQUlLLGFBQWEsR0FBRyxxQkFBcEI7QUFDRCxJQUFJQyxZQUFZLEdBQUcsTUFBbkI7QUFDQSxJQUFJQyxXQUFXLEdBQUcsSUFBbEI7QUFDQSxJQUFJQyxXQUFXLEdBQUcsV0FBbEI7QUFDQSxJQUFJQyxTQUFTLEdBQUcsV0FBaEI7QUFDQSxJQUFJQyxpQkFBaUIsR0FBRyxDQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCLElBQWxCLEVBQXdC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
